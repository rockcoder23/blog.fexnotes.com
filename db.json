{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/typing/source/css/donate.css","path":"css/donate.css","modified":0,"renderable":1},{"_id":"themes/typing/source/css/font-awesome.min.css","path":"css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/typing/source/css/source.css","path":"css/source.css","modified":0,"renderable":1},{"_id":"themes/typing/source/css/typing.css","path":"css/typing.css","modified":0,"renderable":1},{"_id":"themes/typing/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/typing/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/typing/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/typing/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/typing/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/typing/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/typing/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/typing/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/typing/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/typing/source/images/alipay.svg","path":"images/alipay.svg","modified":0,"renderable":1},{"_id":"themes/typing/source/images/bitcoin.svg","path":"images/bitcoin.svg","modified":0,"renderable":1},{"_id":"themes/typing/source/images/github.svg","path":"images/github.svg","modified":0,"renderable":1},{"_id":"themes/typing/source/images/like.svg","path":"images/like.svg","modified":0,"renderable":1},{"_id":"themes/typing/source/images/paypal.svg","path":"images/paypal.svg","modified":0,"renderable":1},{"_id":"themes/typing/source/js/typing.js","path":"js/typing.js","modified":0,"renderable":1},{"_id":"themes/typing/source/images/wechat.svg","path":"images/wechat.svg","modified":0,"renderable":1},{"_id":"themes/typing/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/typing/source/fonts/fontawesome-webfont.woff2","path":"fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/typing/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/typing/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/typing/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/typing/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/typing/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/typing/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/typing/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/typing/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/typing/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/typing/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/typing/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1533440093164},{"_id":"themes/typing/.gitignore","hash":"d83e98433e68316c1ba1260e46463447ad71aaa1","modified":1533440093164},{"_id":"themes/typing/LICENSE","hash":"e4bf48251989dd666899d2d22b351b8db4764992","modified":1533440093164},{"_id":"themes/typing/CHANGELOG.md","hash":"2721cbb008e0c97b0a4eab8003edec47820b18ca","modified":1533440093164},{"_id":"themes/typing/README.md","hash":"a74f23bff25068d36d9a4d98147589d0c4a32952","modified":1533440093165},{"_id":"themes/typing/_config.yml","hash":"751917a5b13132f3c6ad92aa84fea7163624b45b","modified":1533440093165},{"_id":"themes/typing/makefile","hash":"7c9528377cb1ca4a95a004c0637f3ea04c4b11a0","modified":1533440093173},{"_id":"themes/typing/package.json","hash":"6063249a867f28aecd64fdd1207498bb1d935375","modified":1533440093173},{"_id":"source/_posts/hello-world.md","hash":"c8efb8b14c4c7a535b82d980696cf1365bf390ef","modified":1533440848296},{"_id":"themes/typing/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1533440093160},{"_id":"themes/typing/.git/config","hash":"7a9136cca0dbffacc20c74c344a1460b789d8d8d","modified":1533440093162},{"_id":"themes/typing/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1533439924700},{"_id":"themes/typing/.git/index","hash":"fd5b0599892010f4747cb9356d94b2d0ad8c6b8a","modified":1533440093199},{"_id":"themes/typing/.git/packed-refs","hash":"f332c8226346eb29ec7ba8ef5321a8a81e2fa271","modified":1533440093156},{"_id":"themes/typing/languages/default.yml","hash":"bd8e9329c5636b85bc554b76f06830269869864d","modified":1533440093165},{"_id":"themes/typing/languages/en.yml","hash":"bd8e9329c5636b85bc554b76f06830269869864d","modified":1533440093165},{"_id":"themes/typing/languages/nl.yml","hash":"95fc8003c34e1353f73f6315291d0cb10b5d7e73","modified":1533440093166},{"_id":"themes/typing/languages/fr.yml","hash":"559b094ef6b9d02506c33044be8b50ebeda28a70","modified":1533440093166},{"_id":"themes/typing/languages/es.yml","hash":"23dc21c62927062829e31fcfd6c5d2c7e9257844","modified":1533440093166},{"_id":"themes/typing/languages/ru.yml","hash":"3d45b446862c8a305823533b868556f6111308fe","modified":1533440093167},{"_id":"themes/typing/languages/no.yml","hash":"53ba8ffd6353262138016bd1b4c3a65a113e6c52","modified":1533440093166},{"_id":"themes/typing/languages/zh-CN.yml","hash":"4f227318cce98303496e423d85de28b79fb01f00","modified":1533440093167},{"_id":"themes/typing/languages/zh-TW.yml","hash":"b68f12091eeae30b56847997d059f5ce29f086ac","modified":1533440093167},{"_id":"themes/typing/layout/category.ejs","hash":"a6f14dc7f869d6cd0663fef8747c708cdbb18fe7","modified":1533440093171},{"_id":"themes/typing/layout/archive.ejs","hash":"8e47406f108cb3998fb5d55052abe82f1dfa02c1","modified":1533440093171},{"_id":"themes/typing/layout/index.ejs","hash":"8ff309cafb42d8e28e55ce4dc7fdc27286bd1a33","modified":1533440093171},{"_id":"themes/typing/layout/layout.ejs","hash":"3701846fc68235aeeb9fb470d510780ca2dd037d","modified":1533440093172},{"_id":"themes/typing/layout/page.ejs","hash":"a05fd1a27e1c54c9dbab9e69a257a299b0f549cc","modified":1533440093172},{"_id":"themes/typing/layout/tag.ejs","hash":"b9558a0789e3549d6bbcaf86544af9bd3a7a472a","modified":1533440093173},{"_id":"themes/typing/layout/post.ejs","hash":"a05fd1a27e1c54c9dbab9e69a257a299b0f549cc","modified":1533440093172},{"_id":"themes/typing/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1533439924701},{"_id":"themes/typing/preview/preview.png","hash":"33b39c8a626db45ee473ce3e3d0e37ebd9fb83d3","modified":1533440093178},{"_id":"themes/typing/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1533439924700},{"_id":"themes/typing/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1533439924702},{"_id":"themes/typing/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1533439924701},{"_id":"themes/typing/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1533439924701},{"_id":"themes/typing/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1533439924700},{"_id":"themes/typing/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1533439924702},{"_id":"themes/typing/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1533439924701},{"_id":"themes/typing/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1533439924701},{"_id":"themes/typing/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1533439924702},{"_id":"themes/typing/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1533439924700},{"_id":"themes/typing/.git/logs/HEAD","hash":"e0b8a6b7dd55b9f8c04b7d36aa0b8e999d468de1","modified":1533440093161},{"_id":"themes/typing/layout/_partial/after-footer.ejs","hash":"166f0560dce0ef9c4f364f9dc4eb23f6936dbe05","modified":1533440093167},{"_id":"themes/typing/layout/_partial/archive-post.ejs","hash":"877b0b79538a63f1ae73407e372ee041f8b65e1b","modified":1533440093167},{"_id":"themes/typing/layout/_partial/archive.ejs","hash":"9665ed77377c8eb15d94c04a33905d26704f2e13","modified":1533440093168},{"_id":"themes/typing/layout/_partial/article.ejs","hash":"9053782b4845e039bb8c00760897123b059d1dbd","modified":1533440093168},{"_id":"themes/typing/layout/_partial/baidu_tongji.ejs","hash":"998936b5bf3fcef3b2de5e21fe24e956afa43f59","modified":1533440093168},{"_id":"themes/typing/layout/_partial/footer.ejs","hash":"8989208b7f3e14f0b87222363025a255998c65d3","modified":1533440093168},{"_id":"themes/typing/layout/_partial/head.ejs","hash":"4a39d4684f14d7852151924b2a74d7daf0d0e70d","modified":1533440093169},{"_id":"themes/typing/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1533440093169},{"_id":"themes/typing/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1533440093169},{"_id":"themes/typing/layout/_partial/header.ejs","hash":"c9b9f7d58879e416ea265b216dbe211ef6a2f93f","modified":1533440093169},{"_id":"themes/typing/source/css/donate.css","hash":"ddd86c23355b24bb3d36e6d16eb8af0f81aefbe7","modified":1533440093178},{"_id":"themes/typing/source/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1533440093179},{"_id":"themes/typing/source/css/source.css","hash":"74abd55491cff070d6a995bb644a2113da88e533","modified":1533440093179},{"_id":"themes/typing/source/css/typing.css","hash":"2ae4314da99ffdbf809939413fc12ac8ac45ce7c","modified":1533440093180},{"_id":"themes/typing/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1533440093180},{"_id":"themes/typing/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1533440093182},{"_id":"themes/typing/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1533440093181},{"_id":"themes/typing/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1533440093181},{"_id":"themes/typing/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1533440093181},{"_id":"themes/typing/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1533440093182},{"_id":"themes/typing/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1533440093184},{"_id":"themes/typing/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1533440093185},{"_id":"themes/typing/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1533440093184},{"_id":"themes/typing/source/images/alipay.svg","hash":"46cc0552a9f6d700d618db3fcad25e1b8e697e36","modified":1533440093196},{"_id":"themes/typing/source/images/bitcoin.svg","hash":"635f7cca5e675d192be2717788175c7a2146013a","modified":1533440093197},{"_id":"themes/typing/source/images/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1533440093197},{"_id":"themes/typing/source/images/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1533440093197},{"_id":"themes/typing/source/images/paypal.svg","hash":"92f3bc495f20a0190d3041be03345c46d6238c25","modified":1533440093198},{"_id":"themes/typing/source/js/typing.js","hash":"b793b6e7ec3284b7274033a01eb3341307acf068","modified":1533440093199},{"_id":"themes/typing/source/images/wechat.svg","hash":"330496ad42446a29f37a2b97fc388ebd77a8cb9f","modified":1533440093198},{"_id":"themes/typing/source/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1533440093195},{"_id":"themes/typing/source/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1533440093196},{"_id":"themes/typing/.git/objects/pack/pack-f0ec2c715c44ae48d1dc8d900e2f5455efc75416.idx","hash":"ae67d3004e01361de3837a405c0b749de2f01f26","modified":1533440092748},{"_id":"themes/typing/.git/refs/heads/master","hash":"caba5431914f9e4ca92a188f8fe509a4ab878426","modified":1533440093161},{"_id":"themes/typing/layout/_partial/post/category.ejs","hash":"6cd9c85b105db04a74678d0a6c5440e51d9d84f7","modified":1533440093169},{"_id":"themes/typing/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1533440093170},{"_id":"themes/typing/layout/_partial/post/nav.ejs","hash":"93e594128978c0e7310c9aef3e150effbf549f0e","modified":1533440093170},{"_id":"themes/typing/layout/_partial/post/date.ejs","hash":"38affd429d5ed376b349219f3094a7d530c58a70","modified":1533440093170},{"_id":"themes/typing/layout/_partial/post/tag.ejs","hash":"90209686eabc6c3e7a6a7ef2defd0b84611d9f41","modified":1533440093170},{"_id":"themes/typing/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1533440093170},{"_id":"themes/typing/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1533440093182},{"_id":"themes/typing/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1533440093182},{"_id":"themes/typing/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1533440093183},{"_id":"themes/typing/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1533440093183},{"_id":"themes/typing/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1533440093183},{"_id":"themes/typing/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1533440093183},{"_id":"themes/typing/source/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1533440093186},{"_id":"themes/typing/source/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1533440093188},{"_id":"themes/typing/source/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1533440093194},{"_id":"themes/typing/preview/preview-dark-mode.png","hash":"4eaf8d046cf3e06373d93efcefb2ef126d9486cc","modified":1533440093176},{"_id":"themes/typing/.git/logs/refs/heads/master","hash":"e0b8a6b7dd55b9f8c04b7d36aa0b8e999d468de1","modified":1533440093161},{"_id":"themes/typing/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1533440093160},{"_id":"themes/typing/.git/logs/refs/remotes/origin/HEAD","hash":"e0b8a6b7dd55b9f8c04b7d36aa0b8e999d468de1","modified":1533440093159},{"_id":"themes/typing/source/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1533440093192},{"_id":"themes/typing/.git/objects/pack/pack-f0ec2c715c44ae48d1dc8d900e2f5455efc75416.pack","hash":"da18468a2450b043c0fbd4c56ccc3ca92ec918b4","modified":1533440092747},{"_id":"source/_posts/bootsrap-learning.md","hash":"e3ef15e93bcafba61af4849dc7608def7562e6e0","modified":1533443879339},{"_id":"source/_posts/doctype-of-html.md","hash":"313396ec9ad151f362258328d88541fab7842b76","modified":1533443333558},{"_id":"source/_posts/es6-array-function.md","hash":"2bae2493c5b5fbea36ba5543d987a28d1a813e47","modified":1533444547814},{"_id":"source/_posts/es6-destructuring-in-depth.md","hash":"3d3b43b65cf2cc5476df63ef327b0f4f58eee4f9","modified":1533444482483},{"_id":"source/_posts/es6-spread-and-buffer.md","hash":"67b96acdf7f855cd0f7f6f3877a22b88a78096b8","modified":1533444532735},{"_id":"source/_posts/gate-of-old-beijing.md","hash":"a2522946afbf75b3c264a642030ce6fb7a14f275","modified":1533444580010},{"_id":"source/_posts/length-of-javascript-array.md","hash":"391715133730635eb7cd55bd57e08b03347bed4f","modified":1533443229565},{"_id":"source/_posts/lifecycle-of-java-object.md","hash":"6229275e2f86f2040180e9291e2dbf37fc46940c","modified":1533442867336},{"_id":"source/_posts/memory-model-of-jvm.md","hash":"46ea6a9c10af9c64ca385caf6d9fe7ef4c4399be","modified":1533443157119},{"_id":"source/_posts/nginx-config.md","hash":"da0beffce555578f9cb4541f48039480f06ea7f9","modified":1533443761560},{"_id":"source/_posts/python-web-learning.md","hash":"dcab4363394a1650299d967333dbbd8f449c66fe","modified":1533443971826},{"_id":"source/_posts/regex-of-javascript.md","hash":"e87287f64f216cfc2e3e1f4b3c47b9efd64ca913","modified":1533443636356},{"_id":"source/_posts/relative-path-in-java.md","hash":"5798ddb29c33517f63eaf21321cfd706e5e1989f","modified":1533442858545},{"_id":"source/_posts/the-detail-of-the-tcp-connection.md","hash":"f294162605405caeea6a38c8dcb26acfb9d6ca3e","modified":1533442852778},{"_id":"source/_posts/the-summary-of-2014.md","hash":"6b954fbada69e64380b4688506e6ff8476b982a5","modified":1533443704289},{"_id":"source/_posts/the-object-of-javascript.md","hash":"da39bacf3d2c30391f89c1d18b70622bef3ada65","modified":1533443087003},{"_id":"source/_posts/the-summery-of-2013.md","hash":"67b35ffed3c918f20e466d32968f9d43a72d7c6e","modified":1533443548783},{"_id":"source/_posts/the-way-visiting-jvm-object.md","hash":"5daf4d5c88c42be0ed7621a658ade5a0c16a250b","modified":1533442986313},{"_id":"source/_posts/this-of-javascript.md","hash":"f5aa5a900763c774c921631633d48a2513e96aa3","modified":1533442959951},{"_id":"source/_posts/why-socket-programing-is-under-application-layer-and-up-transport-layer.md","hash":"3d459bca77c37c688a67e5d790165fd27ccc4daf","modified":1533442829110}],"Category":[{"name":"Sports","_id":"cjkgb3bwa0000ue8ipq9amnt7"},{"name":"Baseball","parent":"cjkgb3bwa0000ue8ipq9amnt7","_id":"cjkgb3bwe0003ue8ix0844il4"},{"name":"Dream Big","_id":"cjkgbh63o000gue8i7avhjgh4"},{"name":"Shit Done","_id":"cjkgblykr000tue8i2rnsl3vl"}],"Data":[],"Page":[],"Post":[{"title":"老北京的城门","date":"2014-06-14T04:01:25.000Z","_content":"\n今天看一本[书](http://book.douban.com/subject/2074032/)有介绍到古代皇城的建造方式，觉得很有意思，遂记之~\n## 井田制\n\n话说古时有种耕田的方式是国家把田地划分为方形的耕地，称之为井田，其中最常见的是900亩大小为一井田，一井田又通常分为9份，每份100亩，就是九宫格的形式。其中中间一块为公田，周围八块为私田。大家得先耕作中间的公田(丰收成果得上交)后，才能耕作私田。这就是所谓的井田制。\n## 老北京城门\n\n这种把土地规划为九等分的制度或者说思想，反应在疆土上便是天下分为九州的概念。反应在城市建设中则是皇城居于城市的中央，庶民等人所居的八份在周围，这其实就是“井”字的形状。\n据《考工记》记载，理想的王城应该是一个南北与东西各九里的正方形城市，皇城居于城市的中心，皇城的左右设太庙，右边设社稷坛，前面设外朝，后面设市场。王城的每面开辟三座城门。城门之下修建道路，即每边都有三条道路，每条路三幅(中间行马车，两边走行人)。 这样王城就是有三条南北干道和三条东西干道，皇城居于中间。\n\n老北京城的城门目前分为内城， 外城， 皇城。 其实是遗留的明朝的建筑格局。而明朝又是在元朝的基础上进行改造的(由于北部荒芜，当初元朝北部只开了两门：德胜门和安定门)。主要改造为向南边进行扩充，为了防御增加了外城。在南部开辟了左安门，右安门与永定门，与内城南垣的崇文门，正阳门，宣武门互相对应。在东部开辟了广渠门，西部开辟了广安门。使得目前又恢复了井田的建筑思想上。即东边三门：东直门，朝阳门，广渠门；西边三门： 西直门，阜成门， 广安门。 由于增加东西对应的两个城门，所以增加了一条干道。即我们今天听到两广大街。所以老北京有句俗话叫做“内九外七皇城四，九门八点一口钟”。其中皇城四指的是： 天安门、地安门、东安门、西安门。整个前半句描述的就是下图(盗图一张)中的格局。\n\n![北京城门图](http://www.laozhq.cn/UploadFile/2013-5/20135512501345618.jpg)\n\n至于每座城门的名字由来和作用，后续有意思再讲：)\n","source":"_posts/gate-of-old-beijing.md","raw":"---\ntitle: 老北京的城门\ndate: 2014/6/14 12:01:25\ncategories:\n- Dream Big\ntags:\n- 历史 \n- 北京 \n- 城门 \n---\n\n今天看一本[书](http://book.douban.com/subject/2074032/)有介绍到古代皇城的建造方式，觉得很有意思，遂记之~\n## 井田制\n\n话说古时有种耕田的方式是国家把田地划分为方形的耕地，称之为井田，其中最常见的是900亩大小为一井田，一井田又通常分为9份，每份100亩，就是九宫格的形式。其中中间一块为公田，周围八块为私田。大家得先耕作中间的公田(丰收成果得上交)后，才能耕作私田。这就是所谓的井田制。\n## 老北京城门\n\n这种把土地规划为九等分的制度或者说思想，反应在疆土上便是天下分为九州的概念。反应在城市建设中则是皇城居于城市的中央，庶民等人所居的八份在周围，这其实就是“井”字的形状。\n据《考工记》记载，理想的王城应该是一个南北与东西各九里的正方形城市，皇城居于城市的中心，皇城的左右设太庙，右边设社稷坛，前面设外朝，后面设市场。王城的每面开辟三座城门。城门之下修建道路，即每边都有三条道路，每条路三幅(中间行马车，两边走行人)。 这样王城就是有三条南北干道和三条东西干道，皇城居于中间。\n\n老北京城的城门目前分为内城， 外城， 皇城。 其实是遗留的明朝的建筑格局。而明朝又是在元朝的基础上进行改造的(由于北部荒芜，当初元朝北部只开了两门：德胜门和安定门)。主要改造为向南边进行扩充，为了防御增加了外城。在南部开辟了左安门，右安门与永定门，与内城南垣的崇文门，正阳门，宣武门互相对应。在东部开辟了广渠门，西部开辟了广安门。使得目前又恢复了井田的建筑思想上。即东边三门：东直门，朝阳门，广渠门；西边三门： 西直门，阜成门， 广安门。 由于增加东西对应的两个城门，所以增加了一条干道。即我们今天听到两广大街。所以老北京有句俗话叫做“内九外七皇城四，九门八点一口钟”。其中皇城四指的是： 天安门、地安门、东安门、西安门。整个前半句描述的就是下图(盗图一张)中的格局。\n\n![北京城门图](http://www.laozhq.cn/UploadFile/2013-5/20135512501345618.jpg)\n\n至于每座城门的名字由来和作用，后续有意思再讲：)\n","slug":"gate-of-old-beijing","published":1,"updated":"2018-08-05T04:49:40.010Z","_id":"cjkgbd09f000aue8i8f9tn8dh","comments":1,"layout":"post","photos":[],"link":"","content":"<p>今天看一本<a href=\"http://book.douban.com/subject/2074032/\" target=\"_blank\" rel=\"noopener\">书</a>有介绍到古代皇城的建造方式，觉得很有意思，遂记之~</p>\n<h2 id=\"井田制\"><a href=\"#井田制\" class=\"headerlink\" title=\"井田制\"></a>井田制</h2><p>话说古时有种耕田的方式是国家把田地划分为方形的耕地，称之为井田，其中最常见的是900亩大小为一井田，一井田又通常分为9份，每份100亩，就是九宫格的形式。其中中间一块为公田，周围八块为私田。大家得先耕作中间的公田(丰收成果得上交)后，才能耕作私田。这就是所谓的井田制。</p>\n<h2 id=\"老北京城门\"><a href=\"#老北京城门\" class=\"headerlink\" title=\"老北京城门\"></a>老北京城门</h2><p>这种把土地规划为九等分的制度或者说思想，反应在疆土上便是天下分为九州的概念。反应在城市建设中则是皇城居于城市的中央，庶民等人所居的八份在周围，这其实就是“井”字的形状。<br>据《考工记》记载，理想的王城应该是一个南北与东西各九里的正方形城市，皇城居于城市的中心，皇城的左右设太庙，右边设社稷坛，前面设外朝，后面设市场。王城的每面开辟三座城门。城门之下修建道路，即每边都有三条道路，每条路三幅(中间行马车，两边走行人)。 这样王城就是有三条南北干道和三条东西干道，皇城居于中间。</p>\n<p>老北京城的城门目前分为内城， 外城， 皇城。 其实是遗留的明朝的建筑格局。而明朝又是在元朝的基础上进行改造的(由于北部荒芜，当初元朝北部只开了两门：德胜门和安定门)。主要改造为向南边进行扩充，为了防御增加了外城。在南部开辟了左安门，右安门与永定门，与内城南垣的崇文门，正阳门，宣武门互相对应。在东部开辟了广渠门，西部开辟了广安门。使得目前又恢复了井田的建筑思想上。即东边三门：东直门，朝阳门，广渠门；西边三门： 西直门，阜成门， 广安门。 由于增加东西对应的两个城门，所以增加了一条干道。即我们今天听到两广大街。所以老北京有句俗话叫做“内九外七皇城四，九门八点一口钟”。其中皇城四指的是： 天安门、地安门、东安门、西安门。整个前半句描述的就是下图(盗图一张)中的格局。</p>\n<p><img src=\"http://www.laozhq.cn/UploadFile/2013-5/20135512501345618.jpg\" alt=\"北京城门图\"></p>\n<p>至于每座城门的名字由来和作用，后续有意思再讲：)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天看一本<a href=\"http://book.douban.com/subject/2074032/\" target=\"_blank\" rel=\"noopener\">书</a>有介绍到古代皇城的建造方式，觉得很有意思，遂记之~</p>\n<h2 id=\"井田制\"><a href=\"#井田制\" class=\"headerlink\" title=\"井田制\"></a>井田制</h2><p>话说古时有种耕田的方式是国家把田地划分为方形的耕地，称之为井田，其中最常见的是900亩大小为一井田，一井田又通常分为9份，每份100亩，就是九宫格的形式。其中中间一块为公田，周围八块为私田。大家得先耕作中间的公田(丰收成果得上交)后，才能耕作私田。这就是所谓的井田制。</p>\n<h2 id=\"老北京城门\"><a href=\"#老北京城门\" class=\"headerlink\" title=\"老北京城门\"></a>老北京城门</h2><p>这种把土地规划为九等分的制度或者说思想，反应在疆土上便是天下分为九州的概念。反应在城市建设中则是皇城居于城市的中央，庶民等人所居的八份在周围，这其实就是“井”字的形状。<br>据《考工记》记载，理想的王城应该是一个南北与东西各九里的正方形城市，皇城居于城市的中心，皇城的左右设太庙，右边设社稷坛，前面设外朝，后面设市场。王城的每面开辟三座城门。城门之下修建道路，即每边都有三条道路，每条路三幅(中间行马车，两边走行人)。 这样王城就是有三条南北干道和三条东西干道，皇城居于中间。</p>\n<p>老北京城的城门目前分为内城， 外城， 皇城。 其实是遗留的明朝的建筑格局。而明朝又是在元朝的基础上进行改造的(由于北部荒芜，当初元朝北部只开了两门：德胜门和安定门)。主要改造为向南边进行扩充，为了防御增加了外城。在南部开辟了左安门，右安门与永定门，与内城南垣的崇文门，正阳门，宣武门互相对应。在东部开辟了广渠门，西部开辟了广安门。使得目前又恢复了井田的建筑思想上。即东边三门：东直门，朝阳门，广渠门；西边三门： 西直门，阜成门， 广安门。 由于增加东西对应的两个城门，所以增加了一条干道。即我们今天听到两广大街。所以老北京有句俗话叫做“内九外七皇城四，九门八点一口钟”。其中皇城四指的是： 天安门、地安门、东安门、西安门。整个前半句描述的就是下图(盗图一张)中的格局。</p>\n<p><img src=\"http://www.laozhq.cn/UploadFile/2013-5/20135512501345618.jpg\" alt=\"北京城门图\"></p>\n<p>至于每座城门的名字由来和作用，后续有意思再讲：)</p>\n"},{"title":"JAVA 项目中的相对路径","date":"2013-08-09T09:57:30.000Z","_content":"File类是用来构造文件或文件夹的类,在其构造函数中要求传入一个String类型的参数,用于指示文件所在的路径.以前一直使用绝对路径作为参数,其实这里也可以使用相对路径.使用绝对路径不用说,很容易就能定位到文件,那么使用了相对路径jvm如何定位文件的呢?\n\n按照jdk Doc上的说法”绝对路径名是完整的路径名，不需要任何其他信息就可以定位自身表示的文件。相反，相对路径名必须使用来自其他路径名的信息进行解释。默认情况下，java.io 包中的类总是根据当前用户目录来分析相对路径名。此目录由系统属性user.dir指定，通常是 Java 虚拟机的调用目录.”\n\n相对路径顾名思义,相对于某个路径,那么究竟相对于什么路径我们必须弄明白.按照上面jdk文档上讲的这个路径是”当前用户目录”也就是”java虚拟机的调用目录”.更明白的说这个路径其实是我们在哪里调用jvm的路径.举个例子:\n\n> 先说在dos下的情况，假设有一java源文件Example.java在d盘根目录下,该文件不含package信息.我们进入命令行窗口,然后使用”d:”命令切换到d盘根目录下,然后用javac Example.java来编译此文件,编译无错后,会在d盘根目录下自动生成Example.class文件.我们在调用java Example来运行该程序.此时我们已经启动了一个jvm,这个jvm是在d盘根目录下被启动的,所以此jvm所加载的程序中File类的相对路径也就是相对这个路径的,即d盘根目录:D:.同时” 当前用户目录”也是D:.在System.getProperty(“user.dir”);系统变量user.dir存放的也是这个值. 我们可以多做几次试验,把Example.class移动到不同路径下,同时在那些路径下,执行java Example命令启动jvm,我们会发现这个”当前用户目录”是不断变化的,它的路径始终和我们在哪启动jvm的路径是一致的.\n\n搞清了这些,我们可以使用相对路径来创建文件,例如:\n\n> ``` java\n> File file = new File(“a.txt”);\n> File.createNewFile();\n> ```\n> \n> 假设jvm是在D:\\下启动的,那么a.txt就会生成在D:\\a.txt; 此外,这个参数还可以使用一些常用的路径表示方法,例如”.”或”.\\”代表当前目录,这个目录也就是jvm启动路径.所以如下代码能得到当前目录完整路径:\n> \n> ``` java\n> File f = new File(“.”);\n> String absolutePath = f.getAbsolutePath();\n> System.out.println(absolutePath);//D:\\\n> ```\n> \n> 说说在eclipse中的情况: Eclipse中启动jvm都是在项目根路径上启动的.比如有个项目名为blog,其完整路径为:D:\\work\\IDE\\workspace\\blog.那么这个路径就是jvm的启动路径了.所以以上代码如果在eclipse里运行,则输出结果为” D:\\work\\IDE\\workspace\\blog.”\n\nTomcat中的情况. 如果在tomcat中运行web应用,此时,如果我们在某个类中使用如下代码:\n\n``` java\nFile f = new File(“.”);\nString absolutePath = f.getAbsolutePath();\nSystem.out.println(absolutePath);\n```\n\n那么输出的将是tomcat下的bin目录.我的机器就是” D:\\work\\server\\jakarta-tomcat-5.0.28\\bin.”,由此可以看出tomcat服务器是在bin目录下启动jvm的.其实是在bin目录下的” catalina.bat”文件中启动jvm的.\n\n总结：默认情况下，java.io 包中的类总是根据当前用户目录来分析相对路径名。此目录由系统属性user.dir指定，通常是Java虚拟机的调用目录.我们可以通过以下代码进行测试后，在进行处理；\n\n``` java\nFile f = new File(“.”);\nString absolutePath = f.getAbsolutePath();\nSystem.out.println(absolutePath);//D:\\\nSystem.getProperty(“user.dir”)\n```\n","source":"_posts/relative-path-in-java.md","raw":"---\ntitle: JAVA 项目中的相对路径\ndate: 2013/8/9 17:57:30\ncategories:\n- Shit Done\ntags:\n- java \n- 相对路径\n---\nFile类是用来构造文件或文件夹的类,在其构造函数中要求传入一个String类型的参数,用于指示文件所在的路径.以前一直使用绝对路径作为参数,其实这里也可以使用相对路径.使用绝对路径不用说,很容易就能定位到文件,那么使用了相对路径jvm如何定位文件的呢?\n\n按照jdk Doc上的说法”绝对路径名是完整的路径名，不需要任何其他信息就可以定位自身表示的文件。相反，相对路径名必须使用来自其他路径名的信息进行解释。默认情况下，java.io 包中的类总是根据当前用户目录来分析相对路径名。此目录由系统属性user.dir指定，通常是 Java 虚拟机的调用目录.”\n\n相对路径顾名思义,相对于某个路径,那么究竟相对于什么路径我们必须弄明白.按照上面jdk文档上讲的这个路径是”当前用户目录”也就是”java虚拟机的调用目录”.更明白的说这个路径其实是我们在哪里调用jvm的路径.举个例子:\n\n> 先说在dos下的情况，假设有一java源文件Example.java在d盘根目录下,该文件不含package信息.我们进入命令行窗口,然后使用”d:”命令切换到d盘根目录下,然后用javac Example.java来编译此文件,编译无错后,会在d盘根目录下自动生成Example.class文件.我们在调用java Example来运行该程序.此时我们已经启动了一个jvm,这个jvm是在d盘根目录下被启动的,所以此jvm所加载的程序中File类的相对路径也就是相对这个路径的,即d盘根目录:D:.同时” 当前用户目录”也是D:.在System.getProperty(“user.dir”);系统变量user.dir存放的也是这个值. 我们可以多做几次试验,把Example.class移动到不同路径下,同时在那些路径下,执行java Example命令启动jvm,我们会发现这个”当前用户目录”是不断变化的,它的路径始终和我们在哪启动jvm的路径是一致的.\n\n搞清了这些,我们可以使用相对路径来创建文件,例如:\n\n> ``` java\n> File file = new File(“a.txt”);\n> File.createNewFile();\n> ```\n> \n> 假设jvm是在D:\\下启动的,那么a.txt就会生成在D:\\a.txt; 此外,这个参数还可以使用一些常用的路径表示方法,例如”.”或”.\\”代表当前目录,这个目录也就是jvm启动路径.所以如下代码能得到当前目录完整路径:\n> \n> ``` java\n> File f = new File(“.”);\n> String absolutePath = f.getAbsolutePath();\n> System.out.println(absolutePath);//D:\\\n> ```\n> \n> 说说在eclipse中的情况: Eclipse中启动jvm都是在项目根路径上启动的.比如有个项目名为blog,其完整路径为:D:\\work\\IDE\\workspace\\blog.那么这个路径就是jvm的启动路径了.所以以上代码如果在eclipse里运行,则输出结果为” D:\\work\\IDE\\workspace\\blog.”\n\nTomcat中的情况. 如果在tomcat中运行web应用,此时,如果我们在某个类中使用如下代码:\n\n``` java\nFile f = new File(“.”);\nString absolutePath = f.getAbsolutePath();\nSystem.out.println(absolutePath);\n```\n\n那么输出的将是tomcat下的bin目录.我的机器就是” D:\\work\\server\\jakarta-tomcat-5.0.28\\bin.”,由此可以看出tomcat服务器是在bin目录下启动jvm的.其实是在bin目录下的” catalina.bat”文件中启动jvm的.\n\n总结：默认情况下，java.io 包中的类总是根据当前用户目录来分析相对路径名。此目录由系统属性user.dir指定，通常是Java虚拟机的调用目录.我们可以通过以下代码进行测试后，在进行处理；\n\n``` java\nFile f = new File(“.”);\nString absolutePath = f.getAbsolutePath();\nSystem.out.println(absolutePath);//D:\\\nSystem.getProperty(“user.dir”)\n```\n","slug":"relative-path-in-java","published":1,"updated":"2018-08-05T04:20:58.545Z","_id":"cjkgbk2o5000oue8igvn28cv4","comments":1,"layout":"post","photos":[],"link":"","content":"<p>File类是用来构造文件或文件夹的类,在其构造函数中要求传入一个String类型的参数,用于指示文件所在的路径.以前一直使用绝对路径作为参数,其实这里也可以使用相对路径.使用绝对路径不用说,很容易就能定位到文件,那么使用了相对路径jvm如何定位文件的呢?</p>\n<p>按照jdk Doc上的说法”绝对路径名是完整的路径名，不需要任何其他信息就可以定位自身表示的文件。相反，相对路径名必须使用来自其他路径名的信息进行解释。默认情况下，java.io 包中的类总是根据当前用户目录来分析相对路径名。此目录由系统属性user.dir指定，通常是 Java 虚拟机的调用目录.”</p>\n<p>相对路径顾名思义,相对于某个路径,那么究竟相对于什么路径我们必须弄明白.按照上面jdk文档上讲的这个路径是”当前用户目录”也就是”java虚拟机的调用目录”.更明白的说这个路径其实是我们在哪里调用jvm的路径.举个例子:</p>\n<blockquote>\n<p>先说在dos下的情况，假设有一java源文件Example.java在d盘根目录下,该文件不含package信息.我们进入命令行窗口,然后使用”d:”命令切换到d盘根目录下,然后用javac Example.java来编译此文件,编译无错后,会在d盘根目录下自动生成Example.class文件.我们在调用java Example来运行该程序.此时我们已经启动了一个jvm,这个jvm是在d盘根目录下被启动的,所以此jvm所加载的程序中File类的相对路径也就是相对这个路径的,即d盘根目录:D:.同时” 当前用户目录”也是D:.在System.getProperty(“user.dir”);系统变量user.dir存放的也是这个值. 我们可以多做几次试验,把Example.class移动到不同路径下,同时在那些路径下,执行java Example命令启动jvm,我们会发现这个”当前用户目录”是不断变化的,它的路径始终和我们在哪启动jvm的路径是一致的.</p>\n</blockquote>\n<p>搞清了这些,我们可以使用相对路径来创建文件,例如:</p>\n<blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; File file = <span class=\"keyword\">new</span> File(“a.txt”);</span><br><span class=\"line\">&gt; File.createNewFile();</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>假设jvm是在D:\\下启动的,那么a.txt就会生成在D:\\a.txt; 此外,这个参数还可以使用一些常用的路径表示方法,例如”.”或”.\\”代表当前目录,这个目录也就是jvm启动路径.所以如下代码能得到当前目录完整路径:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; File f = <span class=\"keyword\">new</span> File(“.”);</span><br><span class=\"line\">&gt; String absolutePath = f.getAbsolutePath();</span><br><span class=\"line\">&gt; System.out.println(absolutePath);<span class=\"comment\">//D:\\</span></span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>说说在eclipse中的情况: Eclipse中启动jvm都是在项目根路径上启动的.比如有个项目名为blog,其完整路径为:D:\\work\\IDE\\workspace\\blog.那么这个路径就是jvm的启动路径了.所以以上代码如果在eclipse里运行,则输出结果为” D:\\work\\IDE\\workspace\\blog.”</p>\n</blockquote>\n<p>Tomcat中的情况. 如果在tomcat中运行web应用,此时,如果我们在某个类中使用如下代码:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File f = <span class=\"keyword\">new</span> File(“.”);</span><br><span class=\"line\">String absolutePath = f.getAbsolutePath();</span><br><span class=\"line\">System.out.println(absolutePath);</span><br></pre></td></tr></table></figure>\n<p>那么输出的将是tomcat下的bin目录.我的机器就是” D:\\work\\server\\jakarta-tomcat-5.0.28\\bin.”,由此可以看出tomcat服务器是在bin目录下启动jvm的.其实是在bin目录下的” catalina.bat”文件中启动jvm的.</p>\n<p>总结：默认情况下，java.io 包中的类总是根据当前用户目录来分析相对路径名。此目录由系统属性user.dir指定，通常是Java虚拟机的调用目录.我们可以通过以下代码进行测试后，在进行处理；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File f = <span class=\"keyword\">new</span> File(“.”);</span><br><span class=\"line\">String absolutePath = f.getAbsolutePath();</span><br><span class=\"line\">System.out.println(absolutePath);<span class=\"comment\">//D:\\</span></span><br><span class=\"line\">System.getProperty(“user.dir”)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>File类是用来构造文件或文件夹的类,在其构造函数中要求传入一个String类型的参数,用于指示文件所在的路径.以前一直使用绝对路径作为参数,其实这里也可以使用相对路径.使用绝对路径不用说,很容易就能定位到文件,那么使用了相对路径jvm如何定位文件的呢?</p>\n<p>按照jdk Doc上的说法”绝对路径名是完整的路径名，不需要任何其他信息就可以定位自身表示的文件。相反，相对路径名必须使用来自其他路径名的信息进行解释。默认情况下，java.io 包中的类总是根据当前用户目录来分析相对路径名。此目录由系统属性user.dir指定，通常是 Java 虚拟机的调用目录.”</p>\n<p>相对路径顾名思义,相对于某个路径,那么究竟相对于什么路径我们必须弄明白.按照上面jdk文档上讲的这个路径是”当前用户目录”也就是”java虚拟机的调用目录”.更明白的说这个路径其实是我们在哪里调用jvm的路径.举个例子:</p>\n<blockquote>\n<p>先说在dos下的情况，假设有一java源文件Example.java在d盘根目录下,该文件不含package信息.我们进入命令行窗口,然后使用”d:”命令切换到d盘根目录下,然后用javac Example.java来编译此文件,编译无错后,会在d盘根目录下自动生成Example.class文件.我们在调用java Example来运行该程序.此时我们已经启动了一个jvm,这个jvm是在d盘根目录下被启动的,所以此jvm所加载的程序中File类的相对路径也就是相对这个路径的,即d盘根目录:D:.同时” 当前用户目录”也是D:.在System.getProperty(“user.dir”);系统变量user.dir存放的也是这个值. 我们可以多做几次试验,把Example.class移动到不同路径下,同时在那些路径下,执行java Example命令启动jvm,我们会发现这个”当前用户目录”是不断变化的,它的路径始终和我们在哪启动jvm的路径是一致的.</p>\n</blockquote>\n<p>搞清了这些,我们可以使用相对路径来创建文件,例如:</p>\n<blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; File file = <span class=\"keyword\">new</span> File(“a.txt”);</span><br><span class=\"line\">&gt; File.createNewFile();</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>假设jvm是在D:\\下启动的,那么a.txt就会生成在D:\\a.txt; 此外,这个参数还可以使用一些常用的路径表示方法,例如”.”或”.\\”代表当前目录,这个目录也就是jvm启动路径.所以如下代码能得到当前目录完整路径:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; File f = <span class=\"keyword\">new</span> File(“.”);</span><br><span class=\"line\">&gt; String absolutePath = f.getAbsolutePath();</span><br><span class=\"line\">&gt; System.out.println(absolutePath);<span class=\"comment\">//D:\\</span></span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>说说在eclipse中的情况: Eclipse中启动jvm都是在项目根路径上启动的.比如有个项目名为blog,其完整路径为:D:\\work\\IDE\\workspace\\blog.那么这个路径就是jvm的启动路径了.所以以上代码如果在eclipse里运行,则输出结果为” D:\\work\\IDE\\workspace\\blog.”</p>\n</blockquote>\n<p>Tomcat中的情况. 如果在tomcat中运行web应用,此时,如果我们在某个类中使用如下代码:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File f = <span class=\"keyword\">new</span> File(“.”);</span><br><span class=\"line\">String absolutePath = f.getAbsolutePath();</span><br><span class=\"line\">System.out.println(absolutePath);</span><br></pre></td></tr></table></figure>\n<p>那么输出的将是tomcat下的bin目录.我的机器就是” D:\\work\\server\\jakarta-tomcat-5.0.28\\bin.”,由此可以看出tomcat服务器是在bin目录下启动jvm的.其实是在bin目录下的” catalina.bat”文件中启动jvm的.</p>\n<p>总结：默认情况下，java.io 包中的类总是根据当前用户目录来分析相对路径名。此目录由系统属性user.dir指定，通常是Java虚拟机的调用目录.我们可以通过以下代码进行测试后，在进行处理；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File f = <span class=\"keyword\">new</span> File(“.”);</span><br><span class=\"line\">String absolutePath = f.getAbsolutePath();</span><br><span class=\"line\">System.out.println(absolutePath);<span class=\"comment\">//D:\\</span></span><br><span class=\"line\">System.getProperty(“user.dir”)</span><br></pre></td></tr></table></figure>\n"},{"title":"JVM 中的内存模型","date":"2013-08-12T08:03:29.000Z","_content":"一. 引言：\n\n众所周知java的内存管理是由jvm来代劳的，这使得程序员在敲代码的时候简单了很多，但是一旦出现了内存泄漏或者溢出方面的问题，如果不了解虚拟机的管理内存的原理，那排错起来将会很艰难。\n\n二.java内存模型：\n\njvm在执行java程序的过程中会把内存划分为若干个不同的数据区域，这些区域的生命周期和作用各不相同。根据《java虚拟机规范（第二版）》jvm把所管理的内存划分爲如下图几个区域：\n\n![](http://img.my.csdn.net/uploads/201209/29/1348934141_8447.jpg)\n1. 程序计数器（Program Counter Register）\n\n作用： 程序计数器是一块较小的内存空间，它是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。为了线程切换后能恢复到正确的执行位置，每条线程都需要由一个独立的程序计数器，各个线程之间的计数器互不影晌，独立存储，是“线程私有”的内存。\n\n生命周期： 其生命周期与线程生命周期一致。\n1. java虚拟机栈（java Virtual Machine Stacks）\n\n作用： 每个方法执行的时候都会开辟栈空间，我们称之爲“栈帧”。栈帧主要用于存储方法体内的局部变量表，操作数栈，动态链接，方法出口等信息。每个方法调用完后，对映着一个栈帧在虚拟机栈中从入栈到出栈的过程。\n\n局部变量表存放了编译器可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(引用指针，并非对象本身)，其中64位长度的long和double类型的数据会占用2个局部变量的空间，其余数据类型只占1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量是完全确定的，在运行期间栈帧不会改变局部变量表的大小空间。\n\n生命周期： 属于“线程私有”的内存，其生命周期与线程生命周期一致。\n\n异常: jvm规范中规定了这个区域的两种异常：当线程请求的栈深度大于虚拟机所允许的深度时，将抛出StackOverflowError异常。栈深度大多数情况下达到1000-2000完全没问题（java虚拟机栈大小/每个栈帧大小），对正常的方法调用这个深度是够用了，所以出现了这个异常，一般可能会是递归时进入了死循环导致。 另一种是如果虚拟机栈可以动态扩展（一般都支持），当扩展时无法申请到足够的存储器时就会抛出OutOfMemoryError异常。\n1. 本地方法栈（Native Method Stack）\n\n与虚拟机栈基本类似，区别在于虚拟机栈为虚拟机执行的java方法服务，而本地方法栈则是为Native方法服务。由的虚拟机（譬如Sun HotSpot虚拟机） 直接把本地方法栈和虚拟机栈合二爲一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError异常和OutOfMemoryError异常。其生命周期也是与线程一致，属于线程私有。\n1. java堆（java Heap/ GC堆）\n\n作用： 对于大多数应用来说，java堆是jvm管理的内存中最大的一块。是被各个线程共享的内存区域，在虚拟机创建时啓动。此内存区域的唯一目的就是存放对象实例，几乎所有的实例对象和数组都在这里分配。其大小通过-Xms(最小值)和-Xmx(最大值)参数设置，-Xms为JVM启动时申请的最小内存，默认为操作系统物理内存的1/64但小于1G，-Xmx为JVM可申请的最大内存，默认为物理内存的1/4但小于1G，默认当空余堆内存小于40%时，JVM会增大Heap到-Xmx指定的大小，可通过-XX:MinHeapFreeRation=来指定这个比列；当空余堆内存大于70%时，JVM会减小heap的大小到-Xms指定的大小，可通过XX:MaxHeapFreeRation=来指定这个比列，对于运行系统，为避免在运行时频繁调整Heap的大小，通常-Xms与-Xmx的值设成一样。\n\n由于现在收集器都是采用分代收集算法，堆被划分为新生代和老年代。新生代主要存储新创建的对象和尚未进入老年代的对象。老年代存储经过多次新生代GC(Minor GC)任然存活的对象。但是无论如何划分，都与存放内容无关，无论哪个区域存的都是实例对象。这样划分只是爲了更好的分配内存和回收内存\n\n新生代： 程序新创建的对象都是从新生代分配内存，新生代由Eden Space和两块相同大小的Survivor Space(通常又称S0和S1或From和To)构成，可通过-Xmn参数来指定新生代的大小，也可以通过-XX:SurvivorRation来调整Eden Space及Survivor Space的大小。\n\n老年代： 用于存放经过多次新生代GC任然存活的对象，例如缓存对象，新建的对象也有可能直接进入老年代，主要有两种情况：①.大对象，可通过启动参数设置-XX:PretenureSizeThreshold=1024(单位为字节，默认为0)来代表超过多大时就不在新生代分配，而是直接在老年代分配。②.大的数组对象，切数组中无引用外部对象。老年代所占的内存大小为-Xmx对应的值减去-Xmn对应的值。\n![](http://img.my.csdn.net/uploads/201209/30/1349009313_6062.jpg)\n生命周期： 随jvm的啓动而创建，随jvm的关闭和消亡。是线程共享的区域。\n\n异常： java虚拟机可以处于不连续的内存空间，只要逻辑上是连续的即可，就像我们磁盘空间一样。如果堆没有内存完成实例饿分配，并且也无法扩展时，会抛出OutOfMemoryErro异常。\n1. 方法区（Method Area）\n\n也称\"永久代” 、“非堆”， 它用于存储虚拟机加载的类信息、常量、静态变量、是各个线程共享的内存区域。默认最小值为16MB，最大值为64MB，可以通过-XX:PermSize 和 -XX:MaxPermSize 参数限制方法区的大小。 运行时常量池：是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。\n1. 直接内存（Direct Memory）\n\n直接内存并不是虚拟机内存的一部分，也不是Java虚拟机规范中定义的内存区域。jdk1.4中新加入的NIO，引入了通道与缓冲区的IO方式，它可以调用Native方法直接分配堆外内存，这个堆外内存就是本机内存，不会影响到堆内存的大小。\n","source":"_posts/memory-model-of-jvm.md","raw":"---\ntitle: JVM 中的内存模型\ndate: 2013/8/12 16:03:29\ncategories:\n- Shit Done\ntags:\n- JVM\n- 内存模型\n---\n一. 引言：\n\n众所周知java的内存管理是由jvm来代劳的，这使得程序员在敲代码的时候简单了很多，但是一旦出现了内存泄漏或者溢出方面的问题，如果不了解虚拟机的管理内存的原理，那排错起来将会很艰难。\n\n二.java内存模型：\n\njvm在执行java程序的过程中会把内存划分为若干个不同的数据区域，这些区域的生命周期和作用各不相同。根据《java虚拟机规范（第二版）》jvm把所管理的内存划分爲如下图几个区域：\n\n![](http://img.my.csdn.net/uploads/201209/29/1348934141_8447.jpg)\n1. 程序计数器（Program Counter Register）\n\n作用： 程序计数器是一块较小的内存空间，它是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。为了线程切换后能恢复到正确的执行位置，每条线程都需要由一个独立的程序计数器，各个线程之间的计数器互不影晌，独立存储，是“线程私有”的内存。\n\n生命周期： 其生命周期与线程生命周期一致。\n1. java虚拟机栈（java Virtual Machine Stacks）\n\n作用： 每个方法执行的时候都会开辟栈空间，我们称之爲“栈帧”。栈帧主要用于存储方法体内的局部变量表，操作数栈，动态链接，方法出口等信息。每个方法调用完后，对映着一个栈帧在虚拟机栈中从入栈到出栈的过程。\n\n局部变量表存放了编译器可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(引用指针，并非对象本身)，其中64位长度的long和double类型的数据会占用2个局部变量的空间，其余数据类型只占1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量是完全确定的，在运行期间栈帧不会改变局部变量表的大小空间。\n\n生命周期： 属于“线程私有”的内存，其生命周期与线程生命周期一致。\n\n异常: jvm规范中规定了这个区域的两种异常：当线程请求的栈深度大于虚拟机所允许的深度时，将抛出StackOverflowError异常。栈深度大多数情况下达到1000-2000完全没问题（java虚拟机栈大小/每个栈帧大小），对正常的方法调用这个深度是够用了，所以出现了这个异常，一般可能会是递归时进入了死循环导致。 另一种是如果虚拟机栈可以动态扩展（一般都支持），当扩展时无法申请到足够的存储器时就会抛出OutOfMemoryError异常。\n1. 本地方法栈（Native Method Stack）\n\n与虚拟机栈基本类似，区别在于虚拟机栈为虚拟机执行的java方法服务，而本地方法栈则是为Native方法服务。由的虚拟机（譬如Sun HotSpot虚拟机） 直接把本地方法栈和虚拟机栈合二爲一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError异常和OutOfMemoryError异常。其生命周期也是与线程一致，属于线程私有。\n1. java堆（java Heap/ GC堆）\n\n作用： 对于大多数应用来说，java堆是jvm管理的内存中最大的一块。是被各个线程共享的内存区域，在虚拟机创建时啓动。此内存区域的唯一目的就是存放对象实例，几乎所有的实例对象和数组都在这里分配。其大小通过-Xms(最小值)和-Xmx(最大值)参数设置，-Xms为JVM启动时申请的最小内存，默认为操作系统物理内存的1/64但小于1G，-Xmx为JVM可申请的最大内存，默认为物理内存的1/4但小于1G，默认当空余堆内存小于40%时，JVM会增大Heap到-Xmx指定的大小，可通过-XX:MinHeapFreeRation=来指定这个比列；当空余堆内存大于70%时，JVM会减小heap的大小到-Xms指定的大小，可通过XX:MaxHeapFreeRation=来指定这个比列，对于运行系统，为避免在运行时频繁调整Heap的大小，通常-Xms与-Xmx的值设成一样。\n\n由于现在收集器都是采用分代收集算法，堆被划分为新生代和老年代。新生代主要存储新创建的对象和尚未进入老年代的对象。老年代存储经过多次新生代GC(Minor GC)任然存活的对象。但是无论如何划分，都与存放内容无关，无论哪个区域存的都是实例对象。这样划分只是爲了更好的分配内存和回收内存\n\n新生代： 程序新创建的对象都是从新生代分配内存，新生代由Eden Space和两块相同大小的Survivor Space(通常又称S0和S1或From和To)构成，可通过-Xmn参数来指定新生代的大小，也可以通过-XX:SurvivorRation来调整Eden Space及Survivor Space的大小。\n\n老年代： 用于存放经过多次新生代GC任然存活的对象，例如缓存对象，新建的对象也有可能直接进入老年代，主要有两种情况：①.大对象，可通过启动参数设置-XX:PretenureSizeThreshold=1024(单位为字节，默认为0)来代表超过多大时就不在新生代分配，而是直接在老年代分配。②.大的数组对象，切数组中无引用外部对象。老年代所占的内存大小为-Xmx对应的值减去-Xmn对应的值。\n![](http://img.my.csdn.net/uploads/201209/30/1349009313_6062.jpg)\n生命周期： 随jvm的啓动而创建，随jvm的关闭和消亡。是线程共享的区域。\n\n异常： java虚拟机可以处于不连续的内存空间，只要逻辑上是连续的即可，就像我们磁盘空间一样。如果堆没有内存完成实例饿分配，并且也无法扩展时，会抛出OutOfMemoryErro异常。\n1. 方法区（Method Area）\n\n也称\"永久代” 、“非堆”， 它用于存储虚拟机加载的类信息、常量、静态变量、是各个线程共享的内存区域。默认最小值为16MB，最大值为64MB，可以通过-XX:PermSize 和 -XX:MaxPermSize 参数限制方法区的大小。 运行时常量池：是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。\n1. 直接内存（Direct Memory）\n\n直接内存并不是虚拟机内存的一部分，也不是Java虚拟机规范中定义的内存区域。jdk1.4中新加入的NIO，引入了通道与缓冲区的IO方式，它可以调用Native方法直接分配堆外内存，这个堆外内存就是本机内存，不会影响到堆内存的大小。\n","slug":"memory-model-of-jvm","published":1,"updated":"2018-08-05T04:25:57.119Z","_id":"cjkgbngp3000zue8irap9w3m9","comments":1,"layout":"post","photos":[],"link":"","content":"<p>一. 引言：</p>\n<p>众所周知java的内存管理是由jvm来代劳的，这使得程序员在敲代码的时候简单了很多，但是一旦出现了内存泄漏或者溢出方面的问题，如果不了解虚拟机的管理内存的原理，那排错起来将会很艰难。</p>\n<p>二.java内存模型：</p>\n<p>jvm在执行java程序的过程中会把内存划分为若干个不同的数据区域，这些区域的生命周期和作用各不相同。根据《java虚拟机规范（第二版）》jvm把所管理的内存划分爲如下图几个区域：</p>\n<p><img src=\"http://img.my.csdn.net/uploads/201209/29/1348934141_8447.jpg\" alt=\"\"></p>\n<ol>\n<li>程序计数器（Program Counter Register）</li>\n</ol>\n<p>作用： 程序计数器是一块较小的内存空间，它是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。为了线程切换后能恢复到正确的执行位置，每条线程都需要由一个独立的程序计数器，各个线程之间的计数器互不影晌，独立存储，是“线程私有”的内存。</p>\n<p>生命周期： 其生命周期与线程生命周期一致。</p>\n<ol>\n<li>java虚拟机栈（java Virtual Machine Stacks）</li>\n</ol>\n<p>作用： 每个方法执行的时候都会开辟栈空间，我们称之爲“栈帧”。栈帧主要用于存储方法体内的局部变量表，操作数栈，动态链接，方法出口等信息。每个方法调用完后，对映着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>\n<p>局部变量表存放了编译器可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(引用指针，并非对象本身)，其中64位长度的long和double类型的数据会占用2个局部变量的空间，其余数据类型只占1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量是完全确定的，在运行期间栈帧不会改变局部变量表的大小空间。</p>\n<p>生命周期： 属于“线程私有”的内存，其生命周期与线程生命周期一致。</p>\n<p>异常: jvm规范中规定了这个区域的两种异常：当线程请求的栈深度大于虚拟机所允许的深度时，将抛出StackOverflowError异常。栈深度大多数情况下达到1000-2000完全没问题（java虚拟机栈大小/每个栈帧大小），对正常的方法调用这个深度是够用了，所以出现了这个异常，一般可能会是递归时进入了死循环导致。 另一种是如果虚拟机栈可以动态扩展（一般都支持），当扩展时无法申请到足够的存储器时就会抛出OutOfMemoryError异常。</p>\n<ol>\n<li>本地方法栈（Native Method Stack）</li>\n</ol>\n<p>与虚拟机栈基本类似，区别在于虚拟机栈为虚拟机执行的java方法服务，而本地方法栈则是为Native方法服务。由的虚拟机（譬如Sun HotSpot虚拟机） 直接把本地方法栈和虚拟机栈合二爲一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError异常和OutOfMemoryError异常。其生命周期也是与线程一致，属于线程私有。</p>\n<ol>\n<li>java堆（java Heap/ GC堆）</li>\n</ol>\n<p>作用： 对于大多数应用来说，java堆是jvm管理的内存中最大的一块。是被各个线程共享的内存区域，在虚拟机创建时啓动。此内存区域的唯一目的就是存放对象实例，几乎所有的实例对象和数组都在这里分配。其大小通过-Xms(最小值)和-Xmx(最大值)参数设置，-Xms为JVM启动时申请的最小内存，默认为操作系统物理内存的1/64但小于1G，-Xmx为JVM可申请的最大内存，默认为物理内存的1/4但小于1G，默认当空余堆内存小于40%时，JVM会增大Heap到-Xmx指定的大小，可通过-XX:MinHeapFreeRation=来指定这个比列；当空余堆内存大于70%时，JVM会减小heap的大小到-Xms指定的大小，可通过XX:MaxHeapFreeRation=来指定这个比列，对于运行系统，为避免在运行时频繁调整Heap的大小，通常-Xms与-Xmx的值设成一样。</p>\n<p>由于现在收集器都是采用分代收集算法，堆被划分为新生代和老年代。新生代主要存储新创建的对象和尚未进入老年代的对象。老年代存储经过多次新生代GC(Minor GC)任然存活的对象。但是无论如何划分，都与存放内容无关，无论哪个区域存的都是实例对象。这样划分只是爲了更好的分配内存和回收内存</p>\n<p>新生代： 程序新创建的对象都是从新生代分配内存，新生代由Eden Space和两块相同大小的Survivor Space(通常又称S0和S1或From和To)构成，可通过-Xmn参数来指定新生代的大小，也可以通过-XX:SurvivorRation来调整Eden Space及Survivor Space的大小。</p>\n<p>老年代： 用于存放经过多次新生代GC任然存活的对象，例如缓存对象，新建的对象也有可能直接进入老年代，主要有两种情况：①.大对象，可通过启动参数设置-XX:PretenureSizeThreshold=1024(单位为字节，默认为0)来代表超过多大时就不在新生代分配，而是直接在老年代分配。②.大的数组对象，切数组中无引用外部对象。老年代所占的内存大小为-Xmx对应的值减去-Xmn对应的值。<br><img src=\"http://img.my.csdn.net/uploads/201209/30/1349009313_6062.jpg\" alt=\"\"><br>生命周期： 随jvm的啓动而创建，随jvm的关闭和消亡。是线程共享的区域。</p>\n<p>异常： java虚拟机可以处于不连续的内存空间，只要逻辑上是连续的即可，就像我们磁盘空间一样。如果堆没有内存完成实例饿分配，并且也无法扩展时，会抛出OutOfMemoryErro异常。</p>\n<ol>\n<li>方法区（Method Area）</li>\n</ol>\n<p>也称”永久代” 、“非堆”， 它用于存储虚拟机加载的类信息、常量、静态变量、是各个线程共享的内存区域。默认最小值为16MB，最大值为64MB，可以通过-XX:PermSize 和 -XX:MaxPermSize 参数限制方法区的大小。 运行时常量池：是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。</p>\n<ol>\n<li>直接内存（Direct Memory）</li>\n</ol>\n<p>直接内存并不是虚拟机内存的一部分，也不是Java虚拟机规范中定义的内存区域。jdk1.4中新加入的NIO，引入了通道与缓冲区的IO方式，它可以调用Native方法直接分配堆外内存，这个堆外内存就是本机内存，不会影响到堆内存的大小。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>一. 引言：</p>\n<p>众所周知java的内存管理是由jvm来代劳的，这使得程序员在敲代码的时候简单了很多，但是一旦出现了内存泄漏或者溢出方面的问题，如果不了解虚拟机的管理内存的原理，那排错起来将会很艰难。</p>\n<p>二.java内存模型：</p>\n<p>jvm在执行java程序的过程中会把内存划分为若干个不同的数据区域，这些区域的生命周期和作用各不相同。根据《java虚拟机规范（第二版）》jvm把所管理的内存划分爲如下图几个区域：</p>\n<p><img src=\"http://img.my.csdn.net/uploads/201209/29/1348934141_8447.jpg\" alt=\"\"></p>\n<ol>\n<li>程序计数器（Program Counter Register）</li>\n</ol>\n<p>作用： 程序计数器是一块较小的内存空间，它是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。为了线程切换后能恢复到正确的执行位置，每条线程都需要由一个独立的程序计数器，各个线程之间的计数器互不影晌，独立存储，是“线程私有”的内存。</p>\n<p>生命周期： 其生命周期与线程生命周期一致。</p>\n<ol>\n<li>java虚拟机栈（java Virtual Machine Stacks）</li>\n</ol>\n<p>作用： 每个方法执行的时候都会开辟栈空间，我们称之爲“栈帧”。栈帧主要用于存储方法体内的局部变量表，操作数栈，动态链接，方法出口等信息。每个方法调用完后，对映着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>\n<p>局部变量表存放了编译器可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(引用指针，并非对象本身)，其中64位长度的long和double类型的数据会占用2个局部变量的空间，其余数据类型只占1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量是完全确定的，在运行期间栈帧不会改变局部变量表的大小空间。</p>\n<p>生命周期： 属于“线程私有”的内存，其生命周期与线程生命周期一致。</p>\n<p>异常: jvm规范中规定了这个区域的两种异常：当线程请求的栈深度大于虚拟机所允许的深度时，将抛出StackOverflowError异常。栈深度大多数情况下达到1000-2000完全没问题（java虚拟机栈大小/每个栈帧大小），对正常的方法调用这个深度是够用了，所以出现了这个异常，一般可能会是递归时进入了死循环导致。 另一种是如果虚拟机栈可以动态扩展（一般都支持），当扩展时无法申请到足够的存储器时就会抛出OutOfMemoryError异常。</p>\n<ol>\n<li>本地方法栈（Native Method Stack）</li>\n</ol>\n<p>与虚拟机栈基本类似，区别在于虚拟机栈为虚拟机执行的java方法服务，而本地方法栈则是为Native方法服务。由的虚拟机（譬如Sun HotSpot虚拟机） 直接把本地方法栈和虚拟机栈合二爲一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError异常和OutOfMemoryError异常。其生命周期也是与线程一致，属于线程私有。</p>\n<ol>\n<li>java堆（java Heap/ GC堆）</li>\n</ol>\n<p>作用： 对于大多数应用来说，java堆是jvm管理的内存中最大的一块。是被各个线程共享的内存区域，在虚拟机创建时啓动。此内存区域的唯一目的就是存放对象实例，几乎所有的实例对象和数组都在这里分配。其大小通过-Xms(最小值)和-Xmx(最大值)参数设置，-Xms为JVM启动时申请的最小内存，默认为操作系统物理内存的1/64但小于1G，-Xmx为JVM可申请的最大内存，默认为物理内存的1/4但小于1G，默认当空余堆内存小于40%时，JVM会增大Heap到-Xmx指定的大小，可通过-XX:MinHeapFreeRation=来指定这个比列；当空余堆内存大于70%时，JVM会减小heap的大小到-Xms指定的大小，可通过XX:MaxHeapFreeRation=来指定这个比列，对于运行系统，为避免在运行时频繁调整Heap的大小，通常-Xms与-Xmx的值设成一样。</p>\n<p>由于现在收集器都是采用分代收集算法，堆被划分为新生代和老年代。新生代主要存储新创建的对象和尚未进入老年代的对象。老年代存储经过多次新生代GC(Minor GC)任然存活的对象。但是无论如何划分，都与存放内容无关，无论哪个区域存的都是实例对象。这样划分只是爲了更好的分配内存和回收内存</p>\n<p>新生代： 程序新创建的对象都是从新生代分配内存，新生代由Eden Space和两块相同大小的Survivor Space(通常又称S0和S1或From和To)构成，可通过-Xmn参数来指定新生代的大小，也可以通过-XX:SurvivorRation来调整Eden Space及Survivor Space的大小。</p>\n<p>老年代： 用于存放经过多次新生代GC任然存活的对象，例如缓存对象，新建的对象也有可能直接进入老年代，主要有两种情况：①.大对象，可通过启动参数设置-XX:PretenureSizeThreshold=1024(单位为字节，默认为0)来代表超过多大时就不在新生代分配，而是直接在老年代分配。②.大的数组对象，切数组中无引用外部对象。老年代所占的内存大小为-Xmx对应的值减去-Xmn对应的值。<br><img src=\"http://img.my.csdn.net/uploads/201209/30/1349009313_6062.jpg\" alt=\"\"><br>生命周期： 随jvm的啓动而创建，随jvm的关闭和消亡。是线程共享的区域。</p>\n<p>异常： java虚拟机可以处于不连续的内存空间，只要逻辑上是连续的即可，就像我们磁盘空间一样。如果堆没有内存完成实例饿分配，并且也无法扩展时，会抛出OutOfMemoryErro异常。</p>\n<ol>\n<li>方法区（Method Area）</li>\n</ol>\n<p>也称”永久代” 、“非堆”， 它用于存储虚拟机加载的类信息、常量、静态变量、是各个线程共享的内存区域。默认最小值为16MB，最大值为64MB，可以通过-XX:PermSize 和 -XX:MaxPermSize 参数限制方法区的大小。 运行时常量池：是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。</p>\n<ol>\n<li>直接内存（Direct Memory）</li>\n</ol>\n<p>直接内存并不是虚拟机内存的一部分，也不是Java虚拟机规范中定义的内存区域。jdk1.4中新加入的NIO，引入了通道与缓冲区的IO方式，它可以调用Native方法直接分配堆外内存，这个堆外内存就是本机内存，不会影响到堆内存的大小。</p>\n"},{"title":"JAVA 对象得生命周期","date":"2013-08-15T12:47:30.000Z","_content":"\n### **一.垃回收器判断java对象死活的算法**\n\n堆中几乎存放着java 世界的所有对象，垃圾回收器在对堆回收前，第一件事情就是判断对象那些是“活”的，哪些是“死”的。那判断的算法是什么呢？\n#### **1. 引用计数算法**\n\n引用计数算法是对每个对象配置一个引用计数器，当一个地方引用它时，它的引用计数器就加1，当引用失效后，计数器减1.当计数器的值为0时，就表示这个对象不可用了，也即是“死”了。\n\n引用计数算法的实现很简单，判定效率很高，很多时候都是一个不错的算法。\n\n<!--more-->\n#### **2. 根搜索算法**\n\n根搜索算法基本思路就是通过一系列称为 “GC Roots” 的对象作为起始点，从这些节点向下搜索，搜索走过的路径称为“引用链（Refenrence Chain）”，当一个对象到所有的GC Roots都没有引用链的时候，则证明这个对象是不可用的。则将会被判断为可回收的对象。如下图中的对象5， 6， 7，虽然它门之间有关联，但是它门与GC Roots之间没有引用链，所以在垃圾回收的时候是会被认为是可回收的。\n\n{% img ../images/GC_Roots.png %}\n\n那java中到底使用了是哪种算法呢，我们通过一段代码来验证：\n\n``` java\n\n    public class ReferenceCountingGC {\n        public Object instance = null;\n\n        private static final int _1MB = 1024 * 1024;\n\n        //这个成员设计目的是为了占内存，以便能在GC日志中看到清楚是否被回收过\n        private byte[] bigSize = new byte[2 * _1MB];\n\n        public static void testGC() {\n            ReferenceCountingGC objA = new ReferenceCountingGC();\n            ReferenceCountingGC objB = new ReferenceCountingGC();\n\n            //让它门相互引用,满足了算法一\n            objA.instance = objB;\n            objB.instance = objA;\n\n            //置空它们，满足了算法二\n            objA = null;\n            objB = null;\n\n            //开启回收\n            System.gc();\n        }\n\n        public static void main(String[] args) {\n            ReferenceCountingGC.testGC();\n        }\n    }\n```\n\n看GC日志（eclipse中gc日志输出设置，参见：http://www.myexception.cn/eclipse/1268020.html）\n\n{% img ../images/gclog.png %}\n\n可以看到两个对象4M（`4612K->375K`）左右被回收了，也就是数说从侧面证明了java不是使用引用计数算法，而是根搜索算法。这是因为引用计数算法无法解决对象之间相互循环的引用的问题。顺便提一句python是使用了计数引用算法。\n### **二. 对象的真正审判**\n#### **1. java中的引用**\n\n无论是以上两种的哪种算法，都是依靠引用来判断的。在JDK1.2之后，java对引用的概念进行了扩充，将引用分为：\n- 强引用：指代码中最常见的Object obj = new Object()这种引用，只要强引用存在这个对象就永远不会被回收掉。\n-  软引用：用来描述一些还有用,但是并非必须的对象。对于软引用关联着对象，在系统将要发生内存溢出之前，将这些对象列入回收的范围，进行第二次回收，但是回收后还不够内存的话，才会抛出溢出异常。JDK1.2之后，提供了SoftReference类来实现软引用。\n-  弱引用：用来描述一些非必须的对象，相对软引用的强度较弱。被弱引用关联的对像只能活到下次垃圾收集发生之前，无论当前内存是否足够。\n-  虚引用： 也称为幽灵引用，虚引用关联的对象与对象的生命周期无关，也不能通过虚引用获取对象，只是能在回收的时候接受到一个系统通知。\n#### **2. 存活还是死亡**\n\n在经过了根搜索算法无法到达后，基本这个对象被定为了死刑。但是也不是绝对的。\n垃圾收集器对所有无法达到的对象进行一次标记和筛选，筛选出需要执行`finalize（）`的对象。\n\n判断一个对象`无需`执行`finallize（）`方法的标准是：这个对象没有重写fianlize（）方法或者finalize（）方法被虚拟机调用过了。这些无需执行`finalize（）`方法的对象将会被直接回；而需要执行`finalize（）`的对象将在执行完后再判断是否要回收，也就是`fianlize（）`是对象的最后一棵救命的稻草。可以从下面的代码验证：\n\n``` java\n\n    public class FinalizeEscapeGC {\n    public static FinalizeEscapeGC SAVE_HOOK = null;\n\n    public void isAlive(){\n        System.out.println(\"yes, I am still alive :)\");\n    }\n\n\n    @Override\n    protected void finalize() throws Throwable {\n        super.finalize();\n        System.out.println(\"finalize method executed...\");\n        FinalizeEscapeGC.SAVE_HOOK = this;   //再finalize（）方法中拯救自己\n    }\n\n    public static void  main(String[] args) throws InterruptedException{\n        SAVE_HOOK = new FinalizeEscapeGC();\n\n        //置空SAVE_HOOK,然后调用回收机制，第一次调用finalize（），发现没有被回收。\n        SAVE_HOOK = null;\n        System.gc();\n\n        Thread.sleep(500);\n        if(SAVE_HOOK != null){\n            SAVE_HOOK.isAlive();\n        } else{\n            System.out.println(\"no, I am dead :( \");\n        }\n\n        //第二次执行一样的代码，但是却被回收了。\n        SAVE_HOOK = null;\n        System.gc();\n\n        Thread.sleep(500);\n        if(SAVE_HOOK != null){\n            SAVE_HOOK.isAlive();\n        } else{\n            System.out.print(\"no, I am dead :( \");\n        }\n\n    }\n}\n\n```\n\n代码的输出为：\n\n``` java\n        finalize method executed...\n        yes, I am still alive :)\n        no, I am dead :( \n```\n\n可以看到第一次垃圾回收的时候执行了`finalize()`方法，而方法体中对对象进行了拯救，所以对象没有被回收，但是第二次垃圾回收到来的时候，由于`fianlize（）`已经被执行过一次了，所以不会被执行，这就是对象被回收的原因。\n","source":"_posts/lifecycle-of-java-object.md","raw":"---\ntitle: JAVA 对象得生命周期\ndate: 2013/8/15 20:47:30\ncategories:\n- Shit Done\ntags:\n- java \n- 对象的生命周期\n---\n\n### **一.垃回收器判断java对象死活的算法**\n\n堆中几乎存放着java 世界的所有对象，垃圾回收器在对堆回收前，第一件事情就是判断对象那些是“活”的，哪些是“死”的。那判断的算法是什么呢？\n#### **1. 引用计数算法**\n\n引用计数算法是对每个对象配置一个引用计数器，当一个地方引用它时，它的引用计数器就加1，当引用失效后，计数器减1.当计数器的值为0时，就表示这个对象不可用了，也即是“死”了。\n\n引用计数算法的实现很简单，判定效率很高，很多时候都是一个不错的算法。\n\n<!--more-->\n#### **2. 根搜索算法**\n\n根搜索算法基本思路就是通过一系列称为 “GC Roots” 的对象作为起始点，从这些节点向下搜索，搜索走过的路径称为“引用链（Refenrence Chain）”，当一个对象到所有的GC Roots都没有引用链的时候，则证明这个对象是不可用的。则将会被判断为可回收的对象。如下图中的对象5， 6， 7，虽然它门之间有关联，但是它门与GC Roots之间没有引用链，所以在垃圾回收的时候是会被认为是可回收的。\n\n{% img ../images/GC_Roots.png %}\n\n那java中到底使用了是哪种算法呢，我们通过一段代码来验证：\n\n``` java\n\n    public class ReferenceCountingGC {\n        public Object instance = null;\n\n        private static final int _1MB = 1024 * 1024;\n\n        //这个成员设计目的是为了占内存，以便能在GC日志中看到清楚是否被回收过\n        private byte[] bigSize = new byte[2 * _1MB];\n\n        public static void testGC() {\n            ReferenceCountingGC objA = new ReferenceCountingGC();\n            ReferenceCountingGC objB = new ReferenceCountingGC();\n\n            //让它门相互引用,满足了算法一\n            objA.instance = objB;\n            objB.instance = objA;\n\n            //置空它们，满足了算法二\n            objA = null;\n            objB = null;\n\n            //开启回收\n            System.gc();\n        }\n\n        public static void main(String[] args) {\n            ReferenceCountingGC.testGC();\n        }\n    }\n```\n\n看GC日志（eclipse中gc日志输出设置，参见：http://www.myexception.cn/eclipse/1268020.html）\n\n{% img ../images/gclog.png %}\n\n可以看到两个对象4M（`4612K->375K`）左右被回收了，也就是数说从侧面证明了java不是使用引用计数算法，而是根搜索算法。这是因为引用计数算法无法解决对象之间相互循环的引用的问题。顺便提一句python是使用了计数引用算法。\n### **二. 对象的真正审判**\n#### **1. java中的引用**\n\n无论是以上两种的哪种算法，都是依靠引用来判断的。在JDK1.2之后，java对引用的概念进行了扩充，将引用分为：\n- 强引用：指代码中最常见的Object obj = new Object()这种引用，只要强引用存在这个对象就永远不会被回收掉。\n-  软引用：用来描述一些还有用,但是并非必须的对象。对于软引用关联着对象，在系统将要发生内存溢出之前，将这些对象列入回收的范围，进行第二次回收，但是回收后还不够内存的话，才会抛出溢出异常。JDK1.2之后，提供了SoftReference类来实现软引用。\n-  弱引用：用来描述一些非必须的对象，相对软引用的强度较弱。被弱引用关联的对像只能活到下次垃圾收集发生之前，无论当前内存是否足够。\n-  虚引用： 也称为幽灵引用，虚引用关联的对象与对象的生命周期无关，也不能通过虚引用获取对象，只是能在回收的时候接受到一个系统通知。\n#### **2. 存活还是死亡**\n\n在经过了根搜索算法无法到达后，基本这个对象被定为了死刑。但是也不是绝对的。\n垃圾收集器对所有无法达到的对象进行一次标记和筛选，筛选出需要执行`finalize（）`的对象。\n\n判断一个对象`无需`执行`finallize（）`方法的标准是：这个对象没有重写fianlize（）方法或者finalize（）方法被虚拟机调用过了。这些无需执行`finalize（）`方法的对象将会被直接回；而需要执行`finalize（）`的对象将在执行完后再判断是否要回收，也就是`fianlize（）`是对象的最后一棵救命的稻草。可以从下面的代码验证：\n\n``` java\n\n    public class FinalizeEscapeGC {\n    public static FinalizeEscapeGC SAVE_HOOK = null;\n\n    public void isAlive(){\n        System.out.println(\"yes, I am still alive :)\");\n    }\n\n\n    @Override\n    protected void finalize() throws Throwable {\n        super.finalize();\n        System.out.println(\"finalize method executed...\");\n        FinalizeEscapeGC.SAVE_HOOK = this;   //再finalize（）方法中拯救自己\n    }\n\n    public static void  main(String[] args) throws InterruptedException{\n        SAVE_HOOK = new FinalizeEscapeGC();\n\n        //置空SAVE_HOOK,然后调用回收机制，第一次调用finalize（），发现没有被回收。\n        SAVE_HOOK = null;\n        System.gc();\n\n        Thread.sleep(500);\n        if(SAVE_HOOK != null){\n            SAVE_HOOK.isAlive();\n        } else{\n            System.out.println(\"no, I am dead :( \");\n        }\n\n        //第二次执行一样的代码，但是却被回收了。\n        SAVE_HOOK = null;\n        System.gc();\n\n        Thread.sleep(500);\n        if(SAVE_HOOK != null){\n            SAVE_HOOK.isAlive();\n        } else{\n            System.out.print(\"no, I am dead :( \");\n        }\n\n    }\n}\n\n```\n\n代码的输出为：\n\n``` java\n        finalize method executed...\n        yes, I am still alive :)\n        no, I am dead :( \n```\n\n可以看到第一次垃圾回收的时候执行了`finalize()`方法，而方法体中对对象进行了拯救，所以对象没有被回收，但是第二次垃圾回收到来的时候，由于`fianlize（）`已经被执行过一次了，所以不会被执行，这就是对象被回收的原因。\n","slug":"lifecycle-of-java-object","published":1,"updated":"2018-08-05T04:21:07.336Z","_id":"cjkgbqfsi0017ue8in3169kxq","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"一-垃回收器判断java对象死活的算法\"><a href=\"#一-垃回收器判断java对象死活的算法\" class=\"headerlink\" title=\"一.垃回收器判断java对象死活的算法\"></a><strong>一.垃回收器判断java对象死活的算法</strong></h3><p>堆中几乎存放着java 世界的所有对象，垃圾回收器在对堆回收前，第一件事情就是判断对象那些是“活”的，哪些是“死”的。那判断的算法是什么呢？</p>\n<h4 id=\"1-引用计数算法\"><a href=\"#1-引用计数算法\" class=\"headerlink\" title=\"1. 引用计数算法\"></a><strong>1. 引用计数算法</strong></h4><p>引用计数算法是对每个对象配置一个引用计数器，当一个地方引用它时，它的引用计数器就加1，当引用失效后，计数器减1.当计数器的值为0时，就表示这个对象不可用了，也即是“死”了。</p>\n<p>引用计数算法的实现很简单，判定效率很高，很多时候都是一个不错的算法。</p>\n<a id=\"more\"></a>\n<h4 id=\"2-根搜索算法\"><a href=\"#2-根搜索算法\" class=\"headerlink\" title=\"2. 根搜索算法\"></a><strong>2. 根搜索算法</strong></h4><p>根搜索算法基本思路就是通过一系列称为 “GC Roots” 的对象作为起始点，从这些节点向下搜索，搜索走过的路径称为“引用链（Refenrence Chain）”，当一个对象到所有的GC Roots都没有引用链的时候，则证明这个对象是不可用的。则将会被判断为可回收的对象。如下图中的对象5， 6， 7，虽然它门之间有关联，但是它门与GC Roots之间没有引用链，所以在垃圾回收的时候是会被认为是可回收的。</p>\n<img class=\"../images/GC_Roots.png\">\n<p>那java中到底使用了是哪种算法呢，我们通过一段代码来验证：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReferenceCountingGC</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> _1MB = <span class=\"number\">1024</span> * <span class=\"number\">1024</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//这个成员设计目的是为了占内存，以便能在GC日志中看到清楚是否被回收过</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">byte</span>[] bigSize = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">2</span> * _1MB];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testGC</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ReferenceCountingGC objA = <span class=\"keyword\">new</span> ReferenceCountingGC();</span><br><span class=\"line\">        ReferenceCountingGC objB = <span class=\"keyword\">new</span> ReferenceCountingGC();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//让它门相互引用,满足了算法一</span></span><br><span class=\"line\">        objA.instance = objB;</span><br><span class=\"line\">        objB.instance = objA;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//置空它们，满足了算法二</span></span><br><span class=\"line\">        objA = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        objB = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//开启回收</span></span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ReferenceCountingGC.testGC();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看GC日志（eclipse中gc日志输出设置，参见：<a href=\"http://www.myexception.cn/eclipse/1268020.html）\" target=\"_blank\" rel=\"noopener\">http://www.myexception.cn/eclipse/1268020.html）</a></p>\n<img class=\"../images/gclog.png\">\n<p>可以看到两个对象4M（<code>4612K-&gt;375K</code>）左右被回收了，也就是数说从侧面证明了java不是使用引用计数算法，而是根搜索算法。这是因为引用计数算法无法解决对象之间相互循环的引用的问题。顺便提一句python是使用了计数引用算法。</p>\n<h3 id=\"二-对象的真正审判\"><a href=\"#二-对象的真正审判\" class=\"headerlink\" title=\"二. 对象的真正审判\"></a><strong>二. 对象的真正审判</strong></h3><h4 id=\"1-java中的引用\"><a href=\"#1-java中的引用\" class=\"headerlink\" title=\"1. java中的引用\"></a><strong>1. java中的引用</strong></h4><p>无论是以上两种的哪种算法，都是依靠引用来判断的。在JDK1.2之后，java对引用的概念进行了扩充，将引用分为：</p>\n<ul>\n<li>强引用：指代码中最常见的Object obj = new Object()这种引用，只要强引用存在这个对象就永远不会被回收掉。</li>\n<li>软引用：用来描述一些还有用,但是并非必须的对象。对于软引用关联着对象，在系统将要发生内存溢出之前，将这些对象列入回收的范围，进行第二次回收，但是回收后还不够内存的话，才会抛出溢出异常。JDK1.2之后，提供了SoftReference类来实现软引用。</li>\n<li>弱引用：用来描述一些非必须的对象，相对软引用的强度较弱。被弱引用关联的对像只能活到下次垃圾收集发生之前，无论当前内存是否足够。</li>\n<li>虚引用： 也称为幽灵引用，虚引用关联的对象与对象的生命周期无关，也不能通过虚引用获取对象，只是能在回收的时候接受到一个系统通知。<h4 id=\"2-存活还是死亡\"><a href=\"#2-存活还是死亡\" class=\"headerlink\" title=\"2. 存活还是死亡\"></a><strong>2. 存活还是死亡</strong></h4></li>\n</ul>\n<p>在经过了根搜索算法无法到达后，基本这个对象被定为了死刑。但是也不是绝对的。<br>垃圾收集器对所有无法达到的对象进行一次标记和筛选，筛选出需要执行<code>finalize（）</code>的对象。</p>\n<p>判断一个对象<code>无需</code>执行<code>finallize（）</code>方法的标准是：这个对象没有重写fianlize（）方法或者finalize（）方法被虚拟机调用过了。这些无需执行<code>finalize（）</code>方法的对象将会被直接回；而需要执行<code>finalize（）</code>的对象将在执行完后再判断是否要回收，也就是<code>fianlize（）</code>是对象的最后一棵救命的稻草。可以从下面的代码验证：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FinalizeEscapeGC</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> FinalizeEscapeGC SAVE_HOOK = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">isAlive</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"yes, I am still alive :)\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.finalize();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"finalize method executed...\"</span>);</span><br><span class=\"line\">        FinalizeEscapeGC.SAVE_HOOK = <span class=\"keyword\">this</span>;   <span class=\"comment\">//再finalize（）方法中拯救自己</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span>  <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException</span>&#123;</span><br><span class=\"line\">        SAVE_HOOK = <span class=\"keyword\">new</span> FinalizeEscapeGC();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//置空SAVE_HOOK,然后调用回收机制，第一次调用finalize（），发现没有被回收。</span></span><br><span class=\"line\">        SAVE_HOOK = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(SAVE_HOOK != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            SAVE_HOOK.isAlive();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"no, I am dead :( \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//第二次执行一样的代码，但是却被回收了。</span></span><br><span class=\"line\">        SAVE_HOOK = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(SAVE_HOOK != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            SAVE_HOOK.isAlive();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            System.out.print(<span class=\"string\">\"no, I am dead :( \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码的输出为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">finalize method executed...</span><br><span class=\"line\">yes, I am still alive :)</span><br><span class=\"line\">no, I am dead :(</span><br></pre></td></tr></table></figure>\n<p>可以看到第一次垃圾回收的时候执行了<code>finalize()</code>方法，而方法体中对对象进行了拯救，所以对象没有被回收，但是第二次垃圾回收到来的时候，由于<code>fianlize（）</code>已经被执行过一次了，所以不会被执行，这就是对象被回收的原因。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"一-垃回收器判断java对象死活的算法\"><a href=\"#一-垃回收器判断java对象死活的算法\" class=\"headerlink\" title=\"一.垃回收器判断java对象死活的算法\"></a><strong>一.垃回收器判断java对象死活的算法</strong></h3><p>堆中几乎存放着java 世界的所有对象，垃圾回收器在对堆回收前，第一件事情就是判断对象那些是“活”的，哪些是“死”的。那判断的算法是什么呢？</p>\n<h4 id=\"1-引用计数算法\"><a href=\"#1-引用计数算法\" class=\"headerlink\" title=\"1. 引用计数算法\"></a><strong>1. 引用计数算法</strong></h4><p>引用计数算法是对每个对象配置一个引用计数器，当一个地方引用它时，它的引用计数器就加1，当引用失效后，计数器减1.当计数器的值为0时，就表示这个对象不可用了，也即是“死”了。</p>\n<p>引用计数算法的实现很简单，判定效率很高，很多时候都是一个不错的算法。</p>","more":"<h4 id=\"2-根搜索算法\"><a href=\"#2-根搜索算法\" class=\"headerlink\" title=\"2. 根搜索算法\"></a><strong>2. 根搜索算法</strong></h4><p>根搜索算法基本思路就是通过一系列称为 “GC Roots” 的对象作为起始点，从这些节点向下搜索，搜索走过的路径称为“引用链（Refenrence Chain）”，当一个对象到所有的GC Roots都没有引用链的时候，则证明这个对象是不可用的。则将会被判断为可回收的对象。如下图中的对象5， 6， 7，虽然它门之间有关联，但是它门与GC Roots之间没有引用链，所以在垃圾回收的时候是会被认为是可回收的。</p>\n<img class=\"../images/GC_Roots.png\">\n<p>那java中到底使用了是哪种算法呢，我们通过一段代码来验证：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReferenceCountingGC</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> _1MB = <span class=\"number\">1024</span> * <span class=\"number\">1024</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//这个成员设计目的是为了占内存，以便能在GC日志中看到清楚是否被回收过</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">byte</span>[] bigSize = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">2</span> * _1MB];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testGC</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ReferenceCountingGC objA = <span class=\"keyword\">new</span> ReferenceCountingGC();</span><br><span class=\"line\">        ReferenceCountingGC objB = <span class=\"keyword\">new</span> ReferenceCountingGC();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//让它门相互引用,满足了算法一</span></span><br><span class=\"line\">        objA.instance = objB;</span><br><span class=\"line\">        objB.instance = objA;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//置空它们，满足了算法二</span></span><br><span class=\"line\">        objA = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        objB = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//开启回收</span></span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ReferenceCountingGC.testGC();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看GC日志（eclipse中gc日志输出设置，参见：<a href=\"http://www.myexception.cn/eclipse/1268020.html）\" target=\"_blank\" rel=\"noopener\">http://www.myexception.cn/eclipse/1268020.html）</a></p>\n<img class=\"../images/gclog.png\">\n<p>可以看到两个对象4M（<code>4612K-&gt;375K</code>）左右被回收了，也就是数说从侧面证明了java不是使用引用计数算法，而是根搜索算法。这是因为引用计数算法无法解决对象之间相互循环的引用的问题。顺便提一句python是使用了计数引用算法。</p>\n<h3 id=\"二-对象的真正审判\"><a href=\"#二-对象的真正审判\" class=\"headerlink\" title=\"二. 对象的真正审判\"></a><strong>二. 对象的真正审判</strong></h3><h4 id=\"1-java中的引用\"><a href=\"#1-java中的引用\" class=\"headerlink\" title=\"1. java中的引用\"></a><strong>1. java中的引用</strong></h4><p>无论是以上两种的哪种算法，都是依靠引用来判断的。在JDK1.2之后，java对引用的概念进行了扩充，将引用分为：</p>\n<ul>\n<li>强引用：指代码中最常见的Object obj = new Object()这种引用，只要强引用存在这个对象就永远不会被回收掉。</li>\n<li>软引用：用来描述一些还有用,但是并非必须的对象。对于软引用关联着对象，在系统将要发生内存溢出之前，将这些对象列入回收的范围，进行第二次回收，但是回收后还不够内存的话，才会抛出溢出异常。JDK1.2之后，提供了SoftReference类来实现软引用。</li>\n<li>弱引用：用来描述一些非必须的对象，相对软引用的强度较弱。被弱引用关联的对像只能活到下次垃圾收集发生之前，无论当前内存是否足够。</li>\n<li>虚引用： 也称为幽灵引用，虚引用关联的对象与对象的生命周期无关，也不能通过虚引用获取对象，只是能在回收的时候接受到一个系统通知。<h4 id=\"2-存活还是死亡\"><a href=\"#2-存活还是死亡\" class=\"headerlink\" title=\"2. 存活还是死亡\"></a><strong>2. 存活还是死亡</strong></h4></li>\n</ul>\n<p>在经过了根搜索算法无法到达后，基本这个对象被定为了死刑。但是也不是绝对的。<br>垃圾收集器对所有无法达到的对象进行一次标记和筛选，筛选出需要执行<code>finalize（）</code>的对象。</p>\n<p>判断一个对象<code>无需</code>执行<code>finallize（）</code>方法的标准是：这个对象没有重写fianlize（）方法或者finalize（）方法被虚拟机调用过了。这些无需执行<code>finalize（）</code>方法的对象将会被直接回；而需要执行<code>finalize（）</code>的对象将在执行完后再判断是否要回收，也就是<code>fianlize（）</code>是对象的最后一棵救命的稻草。可以从下面的代码验证：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FinalizeEscapeGC</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> FinalizeEscapeGC SAVE_HOOK = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">isAlive</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"yes, I am still alive :)\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.finalize();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"finalize method executed...\"</span>);</span><br><span class=\"line\">        FinalizeEscapeGC.SAVE_HOOK = <span class=\"keyword\">this</span>;   <span class=\"comment\">//再finalize（）方法中拯救自己</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span>  <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException</span>&#123;</span><br><span class=\"line\">        SAVE_HOOK = <span class=\"keyword\">new</span> FinalizeEscapeGC();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//置空SAVE_HOOK,然后调用回收机制，第一次调用finalize（），发现没有被回收。</span></span><br><span class=\"line\">        SAVE_HOOK = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(SAVE_HOOK != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            SAVE_HOOK.isAlive();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"no, I am dead :( \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//第二次执行一样的代码，但是却被回收了。</span></span><br><span class=\"line\">        SAVE_HOOK = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(SAVE_HOOK != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            SAVE_HOOK.isAlive();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            System.out.print(<span class=\"string\">\"no, I am dead :( \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码的输出为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">finalize method executed...</span><br><span class=\"line\">yes, I am still alive :)</span><br><span class=\"line\">no, I am dead :(</span><br></pre></td></tr></table></figure>\n<p>可以看到第一次垃圾回收的时候执行了<code>finalize()</code>方法，而方法体中对对象进行了拯救，所以对象没有被回收，但是第二次垃圾回收到来的时候，由于<code>fianlize（）</code>已经被执行过一次了，所以不会被执行，这就是对象被回收的原因。</p>"},{"title":"JVM 中对象的访问方式","date":"2013-08-20T04:57:30.000Z","_content":"在不同的的jvm中，实现对象的访问方式会有所不同，其中主流的访问方式有两种：使用句柄和直接指针。\n\n**1. 句柄方式：**\n\njvm会在堆中划分一部分内存存放句柄，称为句柄池，reference引用存储着句柄的地址，而句柄中包含了对象实例数据的指针和对象类型数据指针（指向方法区中对象类型信息）\n\n![句柄方式](http://farm3.staticflickr.com/2829/10456407563_092698dc8a.jpg)\n\n使用句柄方式的优点是，reference中存放的是句柄的地址，堆中对象移动后，句柄地址变化，而reference中的内容不变。\n\n<!--more-->\n\n**2. 直接指针方式：**\n\n在直接指针方式中，reference中直接存放着对象的地址，而对象中存放着对对象类型数据的指针。\n\n![直接指针方式](http://farm3.staticflickr.com/2886/10456406993_c33cf7b1e6.jpg)\n\n直接指针方式的优点是访问速度比句柄方式快，因为减少了一次指针的定位的开销。这在java中对象访问频繁的情况能节约很大的执行成本。Sun HotSpot 使用的是直接指针方式。\n","source":"_posts/the-way-visiting-jvm-object.md","raw":"---\ntitle: JVM 中对象的访问方式\ndate: 2013/8/20 12:57:30\ncategories:\n- Shit Done\ntags:\n- JVM \n---\n在不同的的jvm中，实现对象的访问方式会有所不同，其中主流的访问方式有两种：使用句柄和直接指针。\n\n**1. 句柄方式：**\n\njvm会在堆中划分一部分内存存放句柄，称为句柄池，reference引用存储着句柄的地址，而句柄中包含了对象实例数据的指针和对象类型数据指针（指向方法区中对象类型信息）\n\n![句柄方式](http://farm3.staticflickr.com/2829/10456407563_092698dc8a.jpg)\n\n使用句柄方式的优点是，reference中存放的是句柄的地址，堆中对象移动后，句柄地址变化，而reference中的内容不变。\n\n<!--more-->\n\n**2. 直接指针方式：**\n\n在直接指针方式中，reference中直接存放着对象的地址，而对象中存放着对对象类型数据的指针。\n\n![直接指针方式](http://farm3.staticflickr.com/2886/10456406993_c33cf7b1e6.jpg)\n\n直接指针方式的优点是访问速度比句柄方式快，因为减少了一次指针的定位的开销。这在java中对象访问频繁的情况能节约很大的执行成本。Sun HotSpot 使用的是直接指针方式。\n","slug":"the-way-visiting-jvm-object","published":1,"updated":"2018-08-05T04:23:06.313Z","_id":"cjkgbutym001due8iu0auhfnq","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在不同的的jvm中，实现对象的访问方式会有所不同，其中主流的访问方式有两种：使用句柄和直接指针。</p>\n<p><strong>1. 句柄方式：</strong></p>\n<p>jvm会在堆中划分一部分内存存放句柄，称为句柄池，reference引用存储着句柄的地址，而句柄中包含了对象实例数据的指针和对象类型数据指针（指向方法区中对象类型信息）</p>\n<p><img src=\"http://farm3.staticflickr.com/2829/10456407563_092698dc8a.jpg\" alt=\"句柄方式\"></p>\n<p>使用句柄方式的优点是，reference中存放的是句柄的地址，堆中对象移动后，句柄地址变化，而reference中的内容不变。</p>\n<a id=\"more\"></a>\n<p><strong>2. 直接指针方式：</strong></p>\n<p>在直接指针方式中，reference中直接存放着对象的地址，而对象中存放着对对象类型数据的指针。</p>\n<p><img src=\"http://farm3.staticflickr.com/2886/10456406993_c33cf7b1e6.jpg\" alt=\"直接指针方式\"></p>\n<p>直接指针方式的优点是访问速度比句柄方式快，因为减少了一次指针的定位的开销。这在java中对象访问频繁的情况能节约很大的执行成本。Sun HotSpot 使用的是直接指针方式。</p>\n","site":{"data":{}},"excerpt":"<p>在不同的的jvm中，实现对象的访问方式会有所不同，其中主流的访问方式有两种：使用句柄和直接指针。</p>\n<p><strong>1. 句柄方式：</strong></p>\n<p>jvm会在堆中划分一部分内存存放句柄，称为句柄池，reference引用存储着句柄的地址，而句柄中包含了对象实例数据的指针和对象类型数据指针（指向方法区中对象类型信息）</p>\n<p><img src=\"http://farm3.staticflickr.com/2829/10456407563_092698dc8a.jpg\" alt=\"句柄方式\"></p>\n<p>使用句柄方式的优点是，reference中存放的是句柄的地址，堆中对象移动后，句柄地址变化，而reference中的内容不变。</p>","more":"<p><strong>2. 直接指针方式：</strong></p>\n<p>在直接指针方式中，reference中直接存放着对象的地址，而对象中存放着对对象类型数据的指针。</p>\n<p><img src=\"http://farm3.staticflickr.com/2886/10456406993_c33cf7b1e6.jpg\" alt=\"直接指针方式\"></p>\n<p>直接指针方式的优点是访问速度比句柄方式快，因为减少了一次指针的定位的开销。这在java中对象访问频繁的情况能节约很大的执行成本。Sun HotSpot 使用的是直接指针方式。</p>"},{"title":"为什么套接字编程介于应用层与传输层之间","date":"2013-08-30T02:36:31.000Z","_content":"#### 1.首先来说说ISO和OSI：\n\n```\nISO：[国际标准化组织][ISO] International Organization for Standardization\n\nOSI： [开放系统互连模型][OSI] open systems Interconnection \n\n关系是：ISO提出的一个试图使各种计算机在世界范围内互连为网络的标准框架，简称OSI。OSI又俗称为七层模型。\n```\n#### 2. 网际网协议族\n\n```\n就是我们常说的TCP/IP模型，标准称为：网际网协议族，即五层模型。OSI模型中顶上三层合为一层，称为应用层，这就是我们web客户（浏览器）、Telnet客户、web服务器等其他网络应用所在的层。\n```\n#### 3. 套接字编程简介\n\n![](http://farm3.staticflickr.com/2866/11066998623_5ca1248efb.jpg)\n\n如上图，UNP给我们讲述的套接字编程接口主要是指应用层进入传输层的接口，当然在五层模型中的传输层我们在TCP和UDP之间有间隙，表明存在网络应用绕过传输层而直接使用IPv4或者IPv6.我们称为`原始套接字（raw socket）`.\n\n```\n那为什么套接字编程介于应用层与传输层之间呢？\n\n*   第一个理由是因为应用层太关注于网络应用的细节，而对通信细节了解的很少，底下四层对具体的网络应用关心不多，却处理所有的网络应用通信细节：发送数据，等待确认，给数据排序和计算校验和等。\n\n*   第二个理由是顶上三层构成了操作系统所谓的`用户进程`，而底下四层通常为操作系统内核提供，另物理层和数据链路层通常还于具体的设备有关，属于驱动范围。由此可见，应用层与传输层是构件API的自然位置。\n```\n\n<!--more-->\n#### 4. 协议数据单元（PDU）\n\nPDU（protocol data unit）:计算机网络各层对等实体间交换的单位信息。也就是每对等层交换数据单元。\n\n```\n各层的PDU如下：\n\n*   应用层： application data（应用数据）\n*   传输层： message （消息）\n    *  其中TCP的PDU又称为segment （TCP报文段）。\n*   网络层： IP datagram (IP数据报)。\n\n*   数据链路层： frame （帧）\n*   物理层：bit （比特流）\n```\n\n注：\n\n```\n1.  MSS（maximum segment size）:指应用层与传输层的接口属性，指传输层协议规定的最大分节大小。\n\n2.  MTU（maximum transmission unit）:指传输层与数据链路层的接口属性，指数据链路层协议规定的最大传输单元。\n```\n","source":"_posts/why-socket-programing-is-under-application-layer-and-up-transport-layer.md","raw":"---\ntitle: 为什么套接字编程介于应用层与传输层之间\ndate: 2013/8/30 10:36:31\ncategories:\n- Shit Done\ntags:\n- Network \n---\n#### 1.首先来说说ISO和OSI：\n\n```\nISO：[国际标准化组织][ISO] International Organization for Standardization\n\nOSI： [开放系统互连模型][OSI] open systems Interconnection \n\n关系是：ISO提出的一个试图使各种计算机在世界范围内互连为网络的标准框架，简称OSI。OSI又俗称为七层模型。\n```\n#### 2. 网际网协议族\n\n```\n就是我们常说的TCP/IP模型，标准称为：网际网协议族，即五层模型。OSI模型中顶上三层合为一层，称为应用层，这就是我们web客户（浏览器）、Telnet客户、web服务器等其他网络应用所在的层。\n```\n#### 3. 套接字编程简介\n\n![](http://farm3.staticflickr.com/2866/11066998623_5ca1248efb.jpg)\n\n如上图，UNP给我们讲述的套接字编程接口主要是指应用层进入传输层的接口，当然在五层模型中的传输层我们在TCP和UDP之间有间隙，表明存在网络应用绕过传输层而直接使用IPv4或者IPv6.我们称为`原始套接字（raw socket）`.\n\n```\n那为什么套接字编程介于应用层与传输层之间呢？\n\n*   第一个理由是因为应用层太关注于网络应用的细节，而对通信细节了解的很少，底下四层对具体的网络应用关心不多，却处理所有的网络应用通信细节：发送数据，等待确认，给数据排序和计算校验和等。\n\n*   第二个理由是顶上三层构成了操作系统所谓的`用户进程`，而底下四层通常为操作系统内核提供，另物理层和数据链路层通常还于具体的设备有关，属于驱动范围。由此可见，应用层与传输层是构件API的自然位置。\n```\n\n<!--more-->\n#### 4. 协议数据单元（PDU）\n\nPDU（protocol data unit）:计算机网络各层对等实体间交换的单位信息。也就是每对等层交换数据单元。\n\n```\n各层的PDU如下：\n\n*   应用层： application data（应用数据）\n*   传输层： message （消息）\n    *  其中TCP的PDU又称为segment （TCP报文段）。\n*   网络层： IP datagram (IP数据报)。\n\n*   数据链路层： frame （帧）\n*   物理层：bit （比特流）\n```\n\n注：\n\n```\n1.  MSS（maximum segment size）:指应用层与传输层的接口属性，指传输层协议规定的最大分节大小。\n\n2.  MTU（maximum transmission unit）:指传输层与数据链路层的接口属性，指数据链路层协议规定的最大传输单元。\n```\n","slug":"why-socket-programing-is-under-application-layer-and-up-transport-layer","published":1,"updated":"2018-08-05T04:20:29.110Z","_id":"cjkgc0cch001iue8ija2betrj","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"1-首先来说说ISO和OSI：\"><a href=\"#1-首先来说说ISO和OSI：\" class=\"headerlink\" title=\"1.首先来说说ISO和OSI：\"></a>1.首先来说说ISO和OSI：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ISO：[国际标准化组织][ISO] International Organization for Standardization</span><br><span class=\"line\"></span><br><span class=\"line\">OSI： [开放系统互连模型][OSI] open systems Interconnection </span><br><span class=\"line\"></span><br><span class=\"line\">关系是：ISO提出的一个试图使各种计算机在世界范围内互连为网络的标准框架，简称OSI。OSI又俗称为七层模型。</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-网际网协议族\"><a href=\"#2-网际网协议族\" class=\"headerlink\" title=\"2. 网际网协议族\"></a>2. 网际网协议族</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">就是我们常说的TCP/IP模型，标准称为：网际网协议族，即五层模型。OSI模型中顶上三层合为一层，称为应用层，这就是我们web客户（浏览器）、Telnet客户、web服务器等其他网络应用所在的层。</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-套接字编程简介\"><a href=\"#3-套接字编程简介\" class=\"headerlink\" title=\"3. 套接字编程简介\"></a>3. 套接字编程简介</h4><p><img src=\"http://farm3.staticflickr.com/2866/11066998623_5ca1248efb.jpg\" alt=\"\"></p>\n<p>如上图，UNP给我们讲述的套接字编程接口主要是指应用层进入传输层的接口，当然在五层模型中的传输层我们在TCP和UDP之间有间隙，表明存在网络应用绕过传输层而直接使用IPv4或者IPv6.我们称为<code>原始套接字（raw socket）</code>.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">那为什么套接字编程介于应用层与传输层之间呢？</span><br><span class=\"line\"></span><br><span class=\"line\">*   第一个理由是因为应用层太关注于网络应用的细节，而对通信细节了解的很少，底下四层对具体的网络应用关心不多，却处理所有的网络应用通信细节：发送数据，等待确认，给数据排序和计算校验和等。</span><br><span class=\"line\"></span><br><span class=\"line\">*   第二个理由是顶上三层构成了操作系统所谓的`用户进程`，而底下四层通常为操作系统内核提供，另物理层和数据链路层通常还于具体的设备有关，属于驱动范围。由此可见，应用层与传输层是构件API的自然位置。</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h4 id=\"4-协议数据单元（PDU）\"><a href=\"#4-协议数据单元（PDU）\" class=\"headerlink\" title=\"4. 协议数据单元（PDU）\"></a>4. 协议数据单元（PDU）</h4><p>PDU（protocol data unit）:计算机网络各层对等实体间交换的单位信息。也就是每对等层交换数据单元。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">各层的PDU如下：</span><br><span class=\"line\"></span><br><span class=\"line\">*   应用层： application data（应用数据）</span><br><span class=\"line\">*   传输层： message （消息）</span><br><span class=\"line\">    *  其中TCP的PDU又称为segment （TCP报文段）。</span><br><span class=\"line\">*   网络层： IP datagram (IP数据报)。</span><br><span class=\"line\"></span><br><span class=\"line\">*   数据链路层： frame （帧）</span><br><span class=\"line\">*   物理层：bit （比特流）</span><br></pre></td></tr></table></figure>\n<p>注：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.  MSS（maximum segment size）:指应用层与传输层的接口属性，指传输层协议规定的最大分节大小。</span><br><span class=\"line\"></span><br><span class=\"line\">2.  MTU（maximum transmission unit）:指传输层与数据链路层的接口属性，指数据链路层协议规定的最大传输单元。</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h4 id=\"1-首先来说说ISO和OSI：\"><a href=\"#1-首先来说说ISO和OSI：\" class=\"headerlink\" title=\"1.首先来说说ISO和OSI：\"></a>1.首先来说说ISO和OSI：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ISO：[国际标准化组织][ISO] International Organization for Standardization</span><br><span class=\"line\"></span><br><span class=\"line\">OSI： [开放系统互连模型][OSI] open systems Interconnection </span><br><span class=\"line\"></span><br><span class=\"line\">关系是：ISO提出的一个试图使各种计算机在世界范围内互连为网络的标准框架，简称OSI。OSI又俗称为七层模型。</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-网际网协议族\"><a href=\"#2-网际网协议族\" class=\"headerlink\" title=\"2. 网际网协议族\"></a>2. 网际网协议族</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">就是我们常说的TCP/IP模型，标准称为：网际网协议族，即五层模型。OSI模型中顶上三层合为一层，称为应用层，这就是我们web客户（浏览器）、Telnet客户、web服务器等其他网络应用所在的层。</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-套接字编程简介\"><a href=\"#3-套接字编程简介\" class=\"headerlink\" title=\"3. 套接字编程简介\"></a>3. 套接字编程简介</h4><p><img src=\"http://farm3.staticflickr.com/2866/11066998623_5ca1248efb.jpg\" alt=\"\"></p>\n<p>如上图，UNP给我们讲述的套接字编程接口主要是指应用层进入传输层的接口，当然在五层模型中的传输层我们在TCP和UDP之间有间隙，表明存在网络应用绕过传输层而直接使用IPv4或者IPv6.我们称为<code>原始套接字（raw socket）</code>.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">那为什么套接字编程介于应用层与传输层之间呢？</span><br><span class=\"line\"></span><br><span class=\"line\">*   第一个理由是因为应用层太关注于网络应用的细节，而对通信细节了解的很少，底下四层对具体的网络应用关心不多，却处理所有的网络应用通信细节：发送数据，等待确认，给数据排序和计算校验和等。</span><br><span class=\"line\"></span><br><span class=\"line\">*   第二个理由是顶上三层构成了操作系统所谓的`用户进程`，而底下四层通常为操作系统内核提供，另物理层和数据链路层通常还于具体的设备有关，属于驱动范围。由此可见，应用层与传输层是构件API的自然位置。</span><br></pre></td></tr></table></figure>","more":"<h4 id=\"4-协议数据单元（PDU）\"><a href=\"#4-协议数据单元（PDU）\" class=\"headerlink\" title=\"4. 协议数据单元（PDU）\"></a>4. 协议数据单元（PDU）</h4><p>PDU（protocol data unit）:计算机网络各层对等实体间交换的单位信息。也就是每对等层交换数据单元。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">各层的PDU如下：</span><br><span class=\"line\"></span><br><span class=\"line\">*   应用层： application data（应用数据）</span><br><span class=\"line\">*   传输层： message （消息）</span><br><span class=\"line\">    *  其中TCP的PDU又称为segment （TCP报文段）。</span><br><span class=\"line\">*   网络层： IP datagram (IP数据报)。</span><br><span class=\"line\"></span><br><span class=\"line\">*   数据链路层： frame （帧）</span><br><span class=\"line\">*   物理层：bit （比特流）</span><br></pre></td></tr></table></figure>\n<p>注：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.  MSS（maximum segment size）:指应用层与传输层的接口属性，指传输层协议规定的最大分节大小。</span><br><span class=\"line\"></span><br><span class=\"line\">2.  MTU（maximum transmission unit）:指传输层与数据链路层的接口属性，指数据链路层协议规定的最大传输单元。</span><br></pre></td></tr></table></figure>"},{"title":"TCP 连接的建立与关闭","date":"2013-09-10T08:27:30.000Z","_content":"\n#### 1. TCP连接的建立（三握手）\n\n![](http://farm6.staticflickr.com/5481/11084136806_81b69f1f7b.jpg)\n-  首先服务器端，调用socket， bind， listen系统调用，让服务器端处理对连接的监听状态。\n- 客户端调用socket获得套接字描述符，调用connect系统调用，主动打开连接，这时发送了一个SYN tcp分节。表示请求建立连接,这时客户端进入 SYN_SENT状态， 是主动打开连接端。\n- 服务器端接收到SYN后，发送一个SYN和对ACK的确认消息。表示同意接受连接，并且确认请求的ack。这时服务器端进入SYN_RCD状态，是被动打开连接端。\n- 客户端收到ACK后进入ESTABLISHED状态，接着发送对服务器端的SYN消息的确认。服务器接受到确认后，也进入ESTABLISHED状态。至此，tcp连接建立。\n\n连接的建立一共发送了三个tcp分节。所以称之为`三握手`。\n\n其中的MSS称为TCP分节的选项字段（客户端告诉服务器其能接受的最大的分节的大小为536字节，而服务器为1460字节），同时还有窗口的规模选项，时间戳选项等。\n#### 1.1为什么需要最后一次的确认ack分节呢？\n\n理由：\n\n```\n    tcp提供的是可靠的通信，若只要前两个分节，那么当客户端第一次调用connect申请建立连接时的tcp分节在网络中“迷路”了,那么客户端收不到服务器的确认，则会重发一个SYN分节，然后服务器收到后确认了，这时连接建立了（假设不需要最后一个确认）并且交换完数据后关闭连接，这时迷路的第一个SYN分节被服务器接受到了，这时服务器以为是一次客户端发来新建立的连接请求，回复确认，这时就建立了不必要的连接。而有最后一个确认的话，客户端接受到服务器又一次确认，客户端判断是上次迷路的SYN的确认，不回复ack，就避免了多余连接被建立。\n```\n#### 2.  TCP连接的终止\n\n![](http://farm6.staticflickr.com/5527/11084136816_a014ca4b9b.jpg)\n-   客户端调用close系统方法，发送FIN分节，此时客户端进入FIN_WAIT_1状态，是主动关闭端。表明客户端没有数据要发送给服务器了。\n-   服务器接受到FIN后返回一个ACK，并进入CLOSE_WAIT状态，是被动关闭端。\n-   客户端接受到服务器的ACK后，进入了FIN_WAIT_2状态，这个时候tcp的全双工的一半（客户端发送数据给服务器方向）关闭了。称为半关闭状态。\n-   服务器此时还是可以给客户端发送数据的，当发送完数据后，服务器觉得可以关闭连接了调用close方法，也发送一个FIN分节。服务器进入LAST_ACK状态。\n-   客户端接受到FIN后，进入TIME_WAI状态，并发送一个ACK确认。服务器收到ACK确认后，进入CLOSED状态。整个连接关闭，即全双工通信的另一半关闭。\n#### 2.1 为什么需要TIME_WAIT状态存在。\n\n理由： \n\n可靠的实现TCP全双工的关闭。\n\n```\nTIME_WAIT状态的存在使得服务器发送的FIN分节得到确认，若不存在TIME_WAIT状态，则服务器得不到FIN的确认，或者得到是RST（另一种类型的TCP，这时服务器会解释成错误）则无法正常关闭全双工另一半的连接。\n```\n\n保证老的重复的分节在网络中消逝。\n\n```\n假设在12.06.25.253 的1500端口与 206.25.103.250 的端口21之间存在过连接（先已经关闭连接了），并有tcp分节在网络中因延时等“迷路”了。当在这个连个对端再次建立连接的时候，这个分节被服务器收到了，这时tcp分节并不是这次连接的数据，但是有TIME_WAIT状态，持续的时间是MSL的两倍。就能保证遗留的tcp分节在网络中被丢弃，避免了对新的连接的干扰。\n```\n#### 3. 下图展示了完整的状态转换和TCP连接的分组的交换。\n\n![连接的状态转换图](http://www.cppblog.com/images/cppblog_com/lapcca/13342/o_tcp%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.jpg)\n![tcp连接的分节交换图](http://farm6.staticflickr.com/5493/11083740764_05de985c34.jpg)\n","source":"_posts/the-detail-of-the-tcp-connection.md","raw":"---\ntitle: TCP 连接的建立与关闭\ndate: 2013/9/10 16:27:30\ncategories:\n- Shit Done\ntags:\n- java \n- 对象的生命周期\n---\n\n#### 1. TCP连接的建立（三握手）\n\n![](http://farm6.staticflickr.com/5481/11084136806_81b69f1f7b.jpg)\n-  首先服务器端，调用socket， bind， listen系统调用，让服务器端处理对连接的监听状态。\n- 客户端调用socket获得套接字描述符，调用connect系统调用，主动打开连接，这时发送了一个SYN tcp分节。表示请求建立连接,这时客户端进入 SYN_SENT状态， 是主动打开连接端。\n- 服务器端接收到SYN后，发送一个SYN和对ACK的确认消息。表示同意接受连接，并且确认请求的ack。这时服务器端进入SYN_RCD状态，是被动打开连接端。\n- 客户端收到ACK后进入ESTABLISHED状态，接着发送对服务器端的SYN消息的确认。服务器接受到确认后，也进入ESTABLISHED状态。至此，tcp连接建立。\n\n连接的建立一共发送了三个tcp分节。所以称之为`三握手`。\n\n其中的MSS称为TCP分节的选项字段（客户端告诉服务器其能接受的最大的分节的大小为536字节，而服务器为1460字节），同时还有窗口的规模选项，时间戳选项等。\n#### 1.1为什么需要最后一次的确认ack分节呢？\n\n理由：\n\n```\n    tcp提供的是可靠的通信，若只要前两个分节，那么当客户端第一次调用connect申请建立连接时的tcp分节在网络中“迷路”了,那么客户端收不到服务器的确认，则会重发一个SYN分节，然后服务器收到后确认了，这时连接建立了（假设不需要最后一个确认）并且交换完数据后关闭连接，这时迷路的第一个SYN分节被服务器接受到了，这时服务器以为是一次客户端发来新建立的连接请求，回复确认，这时就建立了不必要的连接。而有最后一个确认的话，客户端接受到服务器又一次确认，客户端判断是上次迷路的SYN的确认，不回复ack，就避免了多余连接被建立。\n```\n#### 2.  TCP连接的终止\n\n![](http://farm6.staticflickr.com/5527/11084136816_a014ca4b9b.jpg)\n-   客户端调用close系统方法，发送FIN分节，此时客户端进入FIN_WAIT_1状态，是主动关闭端。表明客户端没有数据要发送给服务器了。\n-   服务器接受到FIN后返回一个ACK，并进入CLOSE_WAIT状态，是被动关闭端。\n-   客户端接受到服务器的ACK后，进入了FIN_WAIT_2状态，这个时候tcp的全双工的一半（客户端发送数据给服务器方向）关闭了。称为半关闭状态。\n-   服务器此时还是可以给客户端发送数据的，当发送完数据后，服务器觉得可以关闭连接了调用close方法，也发送一个FIN分节。服务器进入LAST_ACK状态。\n-   客户端接受到FIN后，进入TIME_WAI状态，并发送一个ACK确认。服务器收到ACK确认后，进入CLOSED状态。整个连接关闭，即全双工通信的另一半关闭。\n#### 2.1 为什么需要TIME_WAIT状态存在。\n\n理由： \n\n可靠的实现TCP全双工的关闭。\n\n```\nTIME_WAIT状态的存在使得服务器发送的FIN分节得到确认，若不存在TIME_WAIT状态，则服务器得不到FIN的确认，或者得到是RST（另一种类型的TCP，这时服务器会解释成错误）则无法正常关闭全双工另一半的连接。\n```\n\n保证老的重复的分节在网络中消逝。\n\n```\n假设在12.06.25.253 的1500端口与 206.25.103.250 的端口21之间存在过连接（先已经关闭连接了），并有tcp分节在网络中因延时等“迷路”了。当在这个连个对端再次建立连接的时候，这个分节被服务器收到了，这时tcp分节并不是这次连接的数据，但是有TIME_WAIT状态，持续的时间是MSL的两倍。就能保证遗留的tcp分节在网络中被丢弃，避免了对新的连接的干扰。\n```\n#### 3. 下图展示了完整的状态转换和TCP连接的分组的交换。\n\n![连接的状态转换图](http://www.cppblog.com/images/cppblog_com/lapcca/13342/o_tcp%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.jpg)\n![tcp连接的分节交换图](http://farm6.staticflickr.com/5493/11083740764_05de985c34.jpg)\n","slug":"the-detail-of-the-tcp-connection","published":1,"updated":"2018-08-05T04:20:52.778Z","_id":"cjkgc7dfp001nue8i5i1n5sre","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"1-TCP连接的建立（三握手）\"><a href=\"#1-TCP连接的建立（三握手）\" class=\"headerlink\" title=\"1. TCP连接的建立（三握手）\"></a>1. TCP连接的建立（三握手）</h4><p><img src=\"http://farm6.staticflickr.com/5481/11084136806_81b69f1f7b.jpg\" alt=\"\"></p>\n<ul>\n<li>首先服务器端，调用socket， bind， listen系统调用，让服务器端处理对连接的监听状态。</li>\n<li>客户端调用socket获得套接字描述符，调用connect系统调用，主动打开连接，这时发送了一个SYN tcp分节。表示请求建立连接,这时客户端进入 SYN_SENT状态， 是主动打开连接端。</li>\n<li>服务器端接收到SYN后，发送一个SYN和对ACK的确认消息。表示同意接受连接，并且确认请求的ack。这时服务器端进入SYN_RCD状态，是被动打开连接端。</li>\n<li>客户端收到ACK后进入ESTABLISHED状态，接着发送对服务器端的SYN消息的确认。服务器接受到确认后，也进入ESTABLISHED状态。至此，tcp连接建立。</li>\n</ul>\n<p>连接的建立一共发送了三个tcp分节。所以称之为<code>三握手</code>。</p>\n<p>其中的MSS称为TCP分节的选项字段（客户端告诉服务器其能接受的最大的分节的大小为536字节，而服务器为1460字节），同时还有窗口的规模选项，时间戳选项等。</p>\n<h4 id=\"1-1为什么需要最后一次的确认ack分节呢？\"><a href=\"#1-1为什么需要最后一次的确认ack分节呢？\" class=\"headerlink\" title=\"1.1为什么需要最后一次的确认ack分节呢？\"></a>1.1为什么需要最后一次的确认ack分节呢？</h4><p>理由：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tcp提供的是可靠的通信，若只要前两个分节，那么当客户端第一次调用connect申请建立连接时的tcp分节在网络中“迷路”了,那么客户端收不到服务器的确认，则会重发一个SYN分节，然后服务器收到后确认了，这时连接建立了（假设不需要最后一个确认）并且交换完数据后关闭连接，这时迷路的第一个SYN分节被服务器接受到了，这时服务器以为是一次客户端发来新建立的连接请求，回复确认，这时就建立了不必要的连接。而有最后一个确认的话，客户端接受到服务器又一次确认，客户端判断是上次迷路的SYN的确认，不回复ack，就避免了多余连接被建立。</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-TCP连接的终止\"><a href=\"#2-TCP连接的终止\" class=\"headerlink\" title=\"2.  TCP连接的终止\"></a>2.  TCP连接的终止</h4><p><img src=\"http://farm6.staticflickr.com/5527/11084136816_a014ca4b9b.jpg\" alt=\"\"></p>\n<ul>\n<li>客户端调用close系统方法，发送FIN分节，此时客户端进入FIN_WAIT_1状态，是主动关闭端。表明客户端没有数据要发送给服务器了。</li>\n<li>服务器接受到FIN后返回一个ACK，并进入CLOSE_WAIT状态，是被动关闭端。</li>\n<li>客户端接受到服务器的ACK后，进入了FIN_WAIT_2状态，这个时候tcp的全双工的一半（客户端发送数据给服务器方向）关闭了。称为半关闭状态。</li>\n<li>服务器此时还是可以给客户端发送数据的，当发送完数据后，服务器觉得可以关闭连接了调用close方法，也发送一个FIN分节。服务器进入LAST_ACK状态。</li>\n<li>客户端接受到FIN后，进入TIME_WAI状态，并发送一个ACK确认。服务器收到ACK确认后，进入CLOSED状态。整个连接关闭，即全双工通信的另一半关闭。<h4 id=\"2-1-为什么需要TIME-WAIT状态存在。\"><a href=\"#2-1-为什么需要TIME-WAIT状态存在。\" class=\"headerlink\" title=\"2.1 为什么需要TIME_WAIT状态存在。\"></a>2.1 为什么需要TIME_WAIT状态存在。</h4></li>\n</ul>\n<p>理由： </p>\n<p>可靠的实现TCP全双工的关闭。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TIME_WAIT状态的存在使得服务器发送的FIN分节得到确认，若不存在TIME_WAIT状态，则服务器得不到FIN的确认，或者得到是RST（另一种类型的TCP，这时服务器会解释成错误）则无法正常关闭全双工另一半的连接。</span><br></pre></td></tr></table></figure>\n<p>保证老的重复的分节在网络中消逝。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">假设在12.06.25.253 的1500端口与 206.25.103.250 的端口21之间存在过连接（先已经关闭连接了），并有tcp分节在网络中因延时等“迷路”了。当在这个连个对端再次建立连接的时候，这个分节被服务器收到了，这时tcp分节并不是这次连接的数据，但是有TIME_WAIT状态，持续的时间是MSL的两倍。就能保证遗留的tcp分节在网络中被丢弃，避免了对新的连接的干扰。</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-下图展示了完整的状态转换和TCP连接的分组的交换。\"><a href=\"#3-下图展示了完整的状态转换和TCP连接的分组的交换。\" class=\"headerlink\" title=\"3. 下图展示了完整的状态转换和TCP连接的分组的交换。\"></a>3. 下图展示了完整的状态转换和TCP连接的分组的交换。</h4><p><img src=\"http://www.cppblog.com/images/cppblog_com/lapcca/13342/o_tcp%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.jpg\" alt=\"连接的状态转换图\"><br><img src=\"http://farm6.staticflickr.com/5493/11083740764_05de985c34.jpg\" alt=\"tcp连接的分节交换图\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"1-TCP连接的建立（三握手）\"><a href=\"#1-TCP连接的建立（三握手）\" class=\"headerlink\" title=\"1. TCP连接的建立（三握手）\"></a>1. TCP连接的建立（三握手）</h4><p><img src=\"http://farm6.staticflickr.com/5481/11084136806_81b69f1f7b.jpg\" alt=\"\"></p>\n<ul>\n<li>首先服务器端，调用socket， bind， listen系统调用，让服务器端处理对连接的监听状态。</li>\n<li>客户端调用socket获得套接字描述符，调用connect系统调用，主动打开连接，这时发送了一个SYN tcp分节。表示请求建立连接,这时客户端进入 SYN_SENT状态， 是主动打开连接端。</li>\n<li>服务器端接收到SYN后，发送一个SYN和对ACK的确认消息。表示同意接受连接，并且确认请求的ack。这时服务器端进入SYN_RCD状态，是被动打开连接端。</li>\n<li>客户端收到ACK后进入ESTABLISHED状态，接着发送对服务器端的SYN消息的确认。服务器接受到确认后，也进入ESTABLISHED状态。至此，tcp连接建立。</li>\n</ul>\n<p>连接的建立一共发送了三个tcp分节。所以称之为<code>三握手</code>。</p>\n<p>其中的MSS称为TCP分节的选项字段（客户端告诉服务器其能接受的最大的分节的大小为536字节，而服务器为1460字节），同时还有窗口的规模选项，时间戳选项等。</p>\n<h4 id=\"1-1为什么需要最后一次的确认ack分节呢？\"><a href=\"#1-1为什么需要最后一次的确认ack分节呢？\" class=\"headerlink\" title=\"1.1为什么需要最后一次的确认ack分节呢？\"></a>1.1为什么需要最后一次的确认ack分节呢？</h4><p>理由：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tcp提供的是可靠的通信，若只要前两个分节，那么当客户端第一次调用connect申请建立连接时的tcp分节在网络中“迷路”了,那么客户端收不到服务器的确认，则会重发一个SYN分节，然后服务器收到后确认了，这时连接建立了（假设不需要最后一个确认）并且交换完数据后关闭连接，这时迷路的第一个SYN分节被服务器接受到了，这时服务器以为是一次客户端发来新建立的连接请求，回复确认，这时就建立了不必要的连接。而有最后一个确认的话，客户端接受到服务器又一次确认，客户端判断是上次迷路的SYN的确认，不回复ack，就避免了多余连接被建立。</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-TCP连接的终止\"><a href=\"#2-TCP连接的终止\" class=\"headerlink\" title=\"2.  TCP连接的终止\"></a>2.  TCP连接的终止</h4><p><img src=\"http://farm6.staticflickr.com/5527/11084136816_a014ca4b9b.jpg\" alt=\"\"></p>\n<ul>\n<li>客户端调用close系统方法，发送FIN分节，此时客户端进入FIN_WAIT_1状态，是主动关闭端。表明客户端没有数据要发送给服务器了。</li>\n<li>服务器接受到FIN后返回一个ACK，并进入CLOSE_WAIT状态，是被动关闭端。</li>\n<li>客户端接受到服务器的ACK后，进入了FIN_WAIT_2状态，这个时候tcp的全双工的一半（客户端发送数据给服务器方向）关闭了。称为半关闭状态。</li>\n<li>服务器此时还是可以给客户端发送数据的，当发送完数据后，服务器觉得可以关闭连接了调用close方法，也发送一个FIN分节。服务器进入LAST_ACK状态。</li>\n<li>客户端接受到FIN后，进入TIME_WAI状态，并发送一个ACK确认。服务器收到ACK确认后，进入CLOSED状态。整个连接关闭，即全双工通信的另一半关闭。<h4 id=\"2-1-为什么需要TIME-WAIT状态存在。\"><a href=\"#2-1-为什么需要TIME-WAIT状态存在。\" class=\"headerlink\" title=\"2.1 为什么需要TIME_WAIT状态存在。\"></a>2.1 为什么需要TIME_WAIT状态存在。</h4></li>\n</ul>\n<p>理由： </p>\n<p>可靠的实现TCP全双工的关闭。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TIME_WAIT状态的存在使得服务器发送的FIN分节得到确认，若不存在TIME_WAIT状态，则服务器得不到FIN的确认，或者得到是RST（另一种类型的TCP，这时服务器会解释成错误）则无法正常关闭全双工另一半的连接。</span><br></pre></td></tr></table></figure>\n<p>保证老的重复的分节在网络中消逝。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">假设在12.06.25.253 的1500端口与 206.25.103.250 的端口21之间存在过连接（先已经关闭连接了），并有tcp分节在网络中因延时等“迷路”了。当在这个连个对端再次建立连接的时候，这个分节被服务器收到了，这时tcp分节并不是这次连接的数据，但是有TIME_WAIT状态，持续的时间是MSL的两倍。就能保证遗留的tcp分节在网络中被丢弃，避免了对新的连接的干扰。</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-下图展示了完整的状态转换和TCP连接的分组的交换。\"><a href=\"#3-下图展示了完整的状态转换和TCP连接的分组的交换。\" class=\"headerlink\" title=\"3. 下图展示了完整的状态转换和TCP连接的分组的交换。\"></a>3. 下图展示了完整的状态转换和TCP连接的分组的交换。</h4><p><img src=\"http://www.cppblog.com/images/cppblog_com/lapcca/13342/o_tcp%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.jpg\" alt=\"连接的状态转换图\"><br><img src=\"http://farm6.staticflickr.com/5493/11083740764_05de985c34.jpg\" alt=\"tcp连接的分节交换图\"></p>\n"},{"title":"Javascript 中的 this 对象","date":"2014-01-12T14:03:29.000Z","_content":"\n最近看道大师的 javascript：The Good part一书中谈道在javascript中函数的调用的四种方式，今天就来说说这四种不同方式下的this变量的含义。以下代码建议在chrome下运行。\n#### 1. 函数的方法调用模式\n\n当function作为对象的属性调用时，我们称之为方法。看以下代码结果。\n\n``` js\nvar myObject = {\n    value: 0,\n    increment: function(inc){\n        // console.log(typeof inc);  //返回表示数据类型的字符串。\n        // console.log(typeof inc === 'number') //inc 如果是number类型，则输出true；\n        console.log(this);//谁调用this 指向谁。输出myObject对象\n        this.value += typeof inc === 'number' ? inc : 1;\n    }\n};\nmyObject.increment();\nconsole.log(myObject.value); //1\nmyObject.increment(2);\nconsole.log(myObject.value); //3\nmyObject.increment('0');\nconsole.log(myObject.value); //4\n```\n\n可见，在函数作为对象的属性时，被调用时this指向这个对象。\n#### 2. 函数的函数调用模式\n\n当函数并非一个对象的属性时，那它就当做一个函数来调用。\n\n``` js\nmyObject.double = function(){\n    console.log(this); //myObject\n    console.log(\"outter function's this: \" + this); //myObject\n    var helper = function(){\n        //绑定到了全局的对象window；\n        console.log(\"inner function's this: \" + this); //window\n    }\n    helper();\n};\nmyObject.double();\n```\n\n我们为myObject增加一个double方法，并且在double方法中定义了一个helper函数，并调用它。我们可以可以看到这个时候，第一个输出的this指向myObject，原理跟第一个一样。然而，helper函数里面的this却指向了window全局对象。正如道大师所说这是javascript设计中的一个错误。为了能让内嵌的函数能访问包裹它的函数的上下文，我们可以如下设计。\n\n//利用js函数闭包可以访问上一层的函数的上下文的特性。\n//把对象本身赋值给变量that。这样就实现了对外层函数的操作。\n\n``` js\nmyObject.double = function(){\n    var  that = this;\n    var helper = function(){\n        console.log(that.value);\n        that.value = that.value + 1;\n        console.log(that.value);\n    }\n    helper();\n};\nmyObject.double();\n```\n\n我们习惯上把包裹函数的this对象赋值给that，利用javascript闭包的特性，就可以使用内嵌函数访问包裹函数的上下文。这个特性经常会用到。\n#### 3. 函数的构造器调用模式\n\n如果一个函数的创建是为了让new调用，那么这个函数成为构造器，当用new调用时，会创建一个新对象，并且这个对默认链接到这个构造器的prototype属性的对象上。见如下代码：\n\n``` js\nvar Quo = function(string){\n    console.log(\"inner constructor this: \");\n    console.log(this);\n    this.status = string;\n    console.log(this);\n}\n\n//给所有从Quo构造的对象添加get_status方法。\nQuo.prototype.get_status = function(){\n    console.log(\"inner get_status this: \");\n    console.log(this);\n    return this.status;\n};\nvar myQuo = new Quo(\"confused..\");\nconsole.log(\"myQuo.get_status: \" + myQuo.get_status());\n```\n\n这个时候构造器内的this指向了新创建的对象。\n#### 4. 函数的apply调用模式\n\napply方法让我们构建一个参数数组传递给调用函数，它也允许我们选择this的值，apply方法接收两个参数，第一个是要绑定给this的值，第二个就是一个参数数组；\n\n``` js\nvar status_Object = {\n    status: 'A-OK'\n};\n\n//status_Object 并没有继承自Quo.prototype，但我们可以在status_Object\n//调用get_status方法。\nvar status = Quo.prototype.get_status.apply(status_Object);\nconsole.log(status);\n```\n\n结合第三种调用方式中的代码，可以看出，因为get_status方法的参数为空，所以我们只传入了status_Object，从输出（get_status方法内的输出）可见this指向了status_Object。但当apply()的参数为空时，默认调用全局对象。\n","source":"_posts/this-of-javascript.md","raw":"---\ntitle: Javascript 中的 this 对象\ndate: 2014/1/12 22:03:29\ncategories:\n- Shit Done\ntags:\n- JVM\n- 内存模型\n---\n\n最近看道大师的 javascript：The Good part一书中谈道在javascript中函数的调用的四种方式，今天就来说说这四种不同方式下的this变量的含义。以下代码建议在chrome下运行。\n#### 1. 函数的方法调用模式\n\n当function作为对象的属性调用时，我们称之为方法。看以下代码结果。\n\n``` js\nvar myObject = {\n    value: 0,\n    increment: function(inc){\n        // console.log(typeof inc);  //返回表示数据类型的字符串。\n        // console.log(typeof inc === 'number') //inc 如果是number类型，则输出true；\n        console.log(this);//谁调用this 指向谁。输出myObject对象\n        this.value += typeof inc === 'number' ? inc : 1;\n    }\n};\nmyObject.increment();\nconsole.log(myObject.value); //1\nmyObject.increment(2);\nconsole.log(myObject.value); //3\nmyObject.increment('0');\nconsole.log(myObject.value); //4\n```\n\n可见，在函数作为对象的属性时，被调用时this指向这个对象。\n#### 2. 函数的函数调用模式\n\n当函数并非一个对象的属性时，那它就当做一个函数来调用。\n\n``` js\nmyObject.double = function(){\n    console.log(this); //myObject\n    console.log(\"outter function's this: \" + this); //myObject\n    var helper = function(){\n        //绑定到了全局的对象window；\n        console.log(\"inner function's this: \" + this); //window\n    }\n    helper();\n};\nmyObject.double();\n```\n\n我们为myObject增加一个double方法，并且在double方法中定义了一个helper函数，并调用它。我们可以可以看到这个时候，第一个输出的this指向myObject，原理跟第一个一样。然而，helper函数里面的this却指向了window全局对象。正如道大师所说这是javascript设计中的一个错误。为了能让内嵌的函数能访问包裹它的函数的上下文，我们可以如下设计。\n\n//利用js函数闭包可以访问上一层的函数的上下文的特性。\n//把对象本身赋值给变量that。这样就实现了对外层函数的操作。\n\n``` js\nmyObject.double = function(){\n    var  that = this;\n    var helper = function(){\n        console.log(that.value);\n        that.value = that.value + 1;\n        console.log(that.value);\n    }\n    helper();\n};\nmyObject.double();\n```\n\n我们习惯上把包裹函数的this对象赋值给that，利用javascript闭包的特性，就可以使用内嵌函数访问包裹函数的上下文。这个特性经常会用到。\n#### 3. 函数的构造器调用模式\n\n如果一个函数的创建是为了让new调用，那么这个函数成为构造器，当用new调用时，会创建一个新对象，并且这个对默认链接到这个构造器的prototype属性的对象上。见如下代码：\n\n``` js\nvar Quo = function(string){\n    console.log(\"inner constructor this: \");\n    console.log(this);\n    this.status = string;\n    console.log(this);\n}\n\n//给所有从Quo构造的对象添加get_status方法。\nQuo.prototype.get_status = function(){\n    console.log(\"inner get_status this: \");\n    console.log(this);\n    return this.status;\n};\nvar myQuo = new Quo(\"confused..\");\nconsole.log(\"myQuo.get_status: \" + myQuo.get_status());\n```\n\n这个时候构造器内的this指向了新创建的对象。\n#### 4. 函数的apply调用模式\n\napply方法让我们构建一个参数数组传递给调用函数，它也允许我们选择this的值，apply方法接收两个参数，第一个是要绑定给this的值，第二个就是一个参数数组；\n\n``` js\nvar status_Object = {\n    status: 'A-OK'\n};\n\n//status_Object 并没有继承自Quo.prototype，但我们可以在status_Object\n//调用get_status方法。\nvar status = Quo.prototype.get_status.apply(status_Object);\nconsole.log(status);\n```\n\n结合第三种调用方式中的代码，可以看出，因为get_status方法的参数为空，所以我们只传入了status_Object，从输出（get_status方法内的输出）可见this指向了status_Object。但当apply()的参数为空时，默认调用全局对象。\n","slug":"this-of-javascript","published":1,"updated":"2018-08-05T04:22:39.951Z","_id":"cjkgcb2yr001rue8ie29mww1q","comments":1,"layout":"post","photos":[],"link":"","content":"<p>最近看道大师的 javascript：The Good part一书中谈道在javascript中函数的调用的四种方式，今天就来说说这四种不同方式下的this变量的含义。以下代码建议在chrome下运行。</p>\n<h4 id=\"1-函数的方法调用模式\"><a href=\"#1-函数的方法调用模式\" class=\"headerlink\" title=\"1. 函数的方法调用模式\"></a>1. 函数的方法调用模式</h4><p>当function作为对象的属性调用时，我们称之为方法。看以下代码结果。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">    value: <span class=\"number\">0</span>,</span><br><span class=\"line\">    increment: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">inc</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// console.log(typeof inc);  //返回表示数据类型的字符串。</span></span><br><span class=\"line\">        <span class=\"comment\">// console.log(typeof inc === 'number') //inc 如果是number类型，则输出true；</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);<span class=\"comment\">//谁调用this 指向谁。输出myObject对象</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value += <span class=\"keyword\">typeof</span> inc === <span class=\"string\">'number'</span> ? inc : <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myObject.increment();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myObject.value); <span class=\"comment\">//1</span></span><br><span class=\"line\">myObject.increment(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myObject.value); <span class=\"comment\">//3</span></span><br><span class=\"line\">myObject.increment(<span class=\"string\">'0'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myObject.value); <span class=\"comment\">//4</span></span><br></pre></td></tr></table></figure>\n<p>可见，在函数作为对象的属性时，被调用时this指向这个对象。</p>\n<h4 id=\"2-函数的函数调用模式\"><a href=\"#2-函数的函数调用模式\" class=\"headerlink\" title=\"2. 函数的函数调用模式\"></a>2. 函数的函数调用模式</h4><p>当函数并非一个对象的属性时，那它就当做一个函数来调用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myObject.double = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">//myObject</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"outter function's this: \"</span> + <span class=\"keyword\">this</span>); <span class=\"comment\">//myObject</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> helper = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//绑定到了全局的对象window；</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"inner function's this: \"</span> + <span class=\"keyword\">this</span>); <span class=\"comment\">//window</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    helper();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myObject.double();</span><br></pre></td></tr></table></figure>\n<p>我们为myObject增加一个double方法，并且在double方法中定义了一个helper函数，并调用它。我们可以可以看到这个时候，第一个输出的this指向myObject，原理跟第一个一样。然而，helper函数里面的this却指向了window全局对象。正如道大师所说这是javascript设计中的一个错误。为了能让内嵌的函数能访问包裹它的函数的上下文，我们可以如下设计。</p>\n<p>//利用js函数闭包可以访问上一层的函数的上下文的特性。<br>//把对象本身赋值给变量that。这样就实现了对外层函数的操作。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myObject.double = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span>  that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> helper = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(that.value);</span><br><span class=\"line\">        that.value = that.value + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(that.value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    helper();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myObject.double();</span><br></pre></td></tr></table></figure>\n<p>我们习惯上把包裹函数的this对象赋值给that，利用javascript闭包的特性，就可以使用内嵌函数访问包裹函数的上下文。这个特性经常会用到。</p>\n<h4 id=\"3-函数的构造器调用模式\"><a href=\"#3-函数的构造器调用模式\" class=\"headerlink\" title=\"3. 函数的构造器调用模式\"></a>3. 函数的构造器调用模式</h4><p>如果一个函数的创建是为了让new调用，那么这个函数成为构造器，当用new调用时，会创建一个新对象，并且这个对默认链接到这个构造器的prototype属性的对象上。见如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Quo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">string</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"inner constructor this: \"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.status = string;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//给所有从Quo构造的对象添加get_status方法。</span></span><br><span class=\"line\">Quo.prototype.get_status = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"inner get_status this: \"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.status;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> myQuo = <span class=\"keyword\">new</span> Quo(<span class=\"string\">\"confused..\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"myQuo.get_status: \"</span> + myQuo.get_status());</span><br></pre></td></tr></table></figure>\n<p>这个时候构造器内的this指向了新创建的对象。</p>\n<h4 id=\"4-函数的apply调用模式\"><a href=\"#4-函数的apply调用模式\" class=\"headerlink\" title=\"4. 函数的apply调用模式\"></a>4. 函数的apply调用模式</h4><p>apply方法让我们构建一个参数数组传递给调用函数，它也允许我们选择this的值，apply方法接收两个参数，第一个是要绑定给this的值，第二个就是一个参数数组；</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> status_Object = &#123;</span><br><span class=\"line\">    status: <span class=\"string\">'A-OK'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//status_Object 并没有继承自Quo.prototype，但我们可以在status_Object</span></span><br><span class=\"line\"><span class=\"comment\">//调用get_status方法。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> status = Quo.prototype.get_status.apply(status_Object);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(status);</span><br></pre></td></tr></table></figure>\n<p>结合第三种调用方式中的代码，可以看出，因为get_status方法的参数为空，所以我们只传入了status_Object，从输出（get_status方法内的输出）可见this指向了status_Object。但当apply()的参数为空时，默认调用全局对象。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近看道大师的 javascript：The Good part一书中谈道在javascript中函数的调用的四种方式，今天就来说说这四种不同方式下的this变量的含义。以下代码建议在chrome下运行。</p>\n<h4 id=\"1-函数的方法调用模式\"><a href=\"#1-函数的方法调用模式\" class=\"headerlink\" title=\"1. 函数的方法调用模式\"></a>1. 函数的方法调用模式</h4><p>当function作为对象的属性调用时，我们称之为方法。看以下代码结果。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">    value: <span class=\"number\">0</span>,</span><br><span class=\"line\">    increment: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">inc</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// console.log(typeof inc);  //返回表示数据类型的字符串。</span></span><br><span class=\"line\">        <span class=\"comment\">// console.log(typeof inc === 'number') //inc 如果是number类型，则输出true；</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);<span class=\"comment\">//谁调用this 指向谁。输出myObject对象</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value += <span class=\"keyword\">typeof</span> inc === <span class=\"string\">'number'</span> ? inc : <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myObject.increment();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myObject.value); <span class=\"comment\">//1</span></span><br><span class=\"line\">myObject.increment(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myObject.value); <span class=\"comment\">//3</span></span><br><span class=\"line\">myObject.increment(<span class=\"string\">'0'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myObject.value); <span class=\"comment\">//4</span></span><br></pre></td></tr></table></figure>\n<p>可见，在函数作为对象的属性时，被调用时this指向这个对象。</p>\n<h4 id=\"2-函数的函数调用模式\"><a href=\"#2-函数的函数调用模式\" class=\"headerlink\" title=\"2. 函数的函数调用模式\"></a>2. 函数的函数调用模式</h4><p>当函数并非一个对象的属性时，那它就当做一个函数来调用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myObject.double = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">//myObject</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"outter function's this: \"</span> + <span class=\"keyword\">this</span>); <span class=\"comment\">//myObject</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> helper = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//绑定到了全局的对象window；</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"inner function's this: \"</span> + <span class=\"keyword\">this</span>); <span class=\"comment\">//window</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    helper();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myObject.double();</span><br></pre></td></tr></table></figure>\n<p>我们为myObject增加一个double方法，并且在double方法中定义了一个helper函数，并调用它。我们可以可以看到这个时候，第一个输出的this指向myObject，原理跟第一个一样。然而，helper函数里面的this却指向了window全局对象。正如道大师所说这是javascript设计中的一个错误。为了能让内嵌的函数能访问包裹它的函数的上下文，我们可以如下设计。</p>\n<p>//利用js函数闭包可以访问上一层的函数的上下文的特性。<br>//把对象本身赋值给变量that。这样就实现了对外层函数的操作。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myObject.double = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span>  that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> helper = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(that.value);</span><br><span class=\"line\">        that.value = that.value + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(that.value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    helper();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myObject.double();</span><br></pre></td></tr></table></figure>\n<p>我们习惯上把包裹函数的this对象赋值给that，利用javascript闭包的特性，就可以使用内嵌函数访问包裹函数的上下文。这个特性经常会用到。</p>\n<h4 id=\"3-函数的构造器调用模式\"><a href=\"#3-函数的构造器调用模式\" class=\"headerlink\" title=\"3. 函数的构造器调用模式\"></a>3. 函数的构造器调用模式</h4><p>如果一个函数的创建是为了让new调用，那么这个函数成为构造器，当用new调用时，会创建一个新对象，并且这个对默认链接到这个构造器的prototype属性的对象上。见如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Quo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">string</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"inner constructor this: \"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.status = string;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//给所有从Quo构造的对象添加get_status方法。</span></span><br><span class=\"line\">Quo.prototype.get_status = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"inner get_status this: \"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.status;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> myQuo = <span class=\"keyword\">new</span> Quo(<span class=\"string\">\"confused..\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"myQuo.get_status: \"</span> + myQuo.get_status());</span><br></pre></td></tr></table></figure>\n<p>这个时候构造器内的this指向了新创建的对象。</p>\n<h4 id=\"4-函数的apply调用模式\"><a href=\"#4-函数的apply调用模式\" class=\"headerlink\" title=\"4. 函数的apply调用模式\"></a>4. 函数的apply调用模式</h4><p>apply方法让我们构建一个参数数组传递给调用函数，它也允许我们选择this的值，apply方法接收两个参数，第一个是要绑定给this的值，第二个就是一个参数数组；</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> status_Object = &#123;</span><br><span class=\"line\">    status: <span class=\"string\">'A-OK'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//status_Object 并没有继承自Quo.prototype，但我们可以在status_Object</span></span><br><span class=\"line\"><span class=\"comment\">//调用get_status方法。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> status = Quo.prototype.get_status.apply(status_Object);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(status);</span><br></pre></td></tr></table></figure>\n<p>结合第三种调用方式中的代码，可以看出，因为get_status方法的参数为空，所以我们只传入了status_Object，从输出（get_status方法内的输出）可见this指向了status_Object。但当apply()的参数为空时，默认调用全局对象。</p>\n"},{"title":"Javascript 对象简介","date":"2014-01-12T14:03:29.000Z","_content":"#### javascript对象的属性检索\n\n今天提提javascript中对象值得一提的东西。\n##### 1. 如果访问一个对象的属性不存在，那么返回undefined。\n\n``` javascript\n// if a property is not exsist ,then return undefine\nvar stooge = {\n    firstName: \"Jerome\",\n    'last_name': \"Howard\" \n};\n\nconsole.log(stooge.firstName);  //Jerome\nconsole.log(stooge.nikeName); // undefine\n```\n##### 2. 我们可以给用 \"||\" 运算符给对象的属性赋默认值。\n\n``` javascript\n//use '||' operator to set varliable default value;\nvar nikeName1  = stooge.nikeName || \"none\";\nif(nikeName1){\n    console.log(\"nikeName1 is: \" + true); //nikeName1 is true\n}\nconsole.log(nikeName1);  //none\n```\n\n<!--more-->\n##### 3. 如果我们访问一个对象的不存在的属性的属性，那么将会跑TypeError错误。\n\n``` javascript\n console.log(stooge.nikeName.length); //TypeError\n```\n\n为了避免这种情况的发生，我们可以使用\"&&\"运算符.\n\n``` javascript\n//to prevent this case, we can use '&&' operator.\nvar nikeNam2 = (stooge.nikeName && stooge.nikeName.length)\nconsole.log(nikeNam2);\nif(nikeNam2){\n    console.log(\"nikeNam2 is: \" + true);\n}else{\n    console.log(\"nikeNam2 is: \" + false);\n}\n```\n##### 4. 我们都知道javascrip是基于原型继承实现的面向对象，与java基于类的继承不同的一种面向对象实现方式。javascript中每个新创建的对象都是继承了另一个对象的属性。为了让这种关系明显的显示出来我们可以定义如下的方法。\n\n``` javascript\n//Prototype 原型\nconsole.log(Object.beget); //undefine\nif (typeof Object.beget !== 'function') {\n    Object.create = function(o){\n        var F = new Function();\n        F.prototype = o;\n        return new F();\n    };\n}\nvar another_stooge = Object.create(stooge); //another_stooge 继承于stooge。\nconsole.log(\"another_stooge: \" + another_stooge.firstName); //Jerome（继承来的属性）\nconsole.log(\"another_stooge: \" + another_stooge.fun()); //fun (继承来的方法)\n```\n\n关于javascript的原型继承，属于javascript中很大的一部分内容，我们后面还会讲到。\n#### javascript对象属性的遍历\n##### 5. 既然javascript中的对象继承了另一个对象的属性和方法，那么我们在访问这个对象的时候，通常我们会有这样的需求，就是想访问这个对象本身扩展的所有的属性。解决方法如下。\n\n``` javascript\n//我们便于测试先给another_stooge添加自己的属性和方法。\nanother_stooge.nikeName = \"Bob\"; \nanother_stooge.fun2 = function(){\n    console.log(\"another_stooge's function....\");\n}\n\n//过滤继承而来的属性和方法\nfor(name in another_stooge){\n    if(another_stooge.hasOwnProperty(name)){\n        console.log(name);  //nikeName fun2\n    }\n}\n```\n##### 6.如果我们有让对象的属性按我们想要的顺序输出，那么我们可以这样做。\n\n``` javascript\n//定义一个循环变量\nvar i;\n//定义顺序数组\nvar properties = [\n    'nikeName',\n    'firstName',\n    'last_name',\n    'fun',\n    'fun2'\n];\n//循环按顺序输出属性。\nfor(i = 0; i < properties.length; i++){\n    console.log(properties[i] + \" : \"+ another_stooge[properties[i]]);\n}\n```\n#### javascript对象属性的删除\n##### 6.当对象的属性与继承而来的属性同名时，会覆盖继承而来的属性值。但删除操作对于对象自己的属性是有作用的对继承而来属性是没有作用的。\n\n``` javascript\n//delete\nconsole.log(another_stooge.firstName) // Jerome\nanother_stooge.firstName = \"Micheal\";//覆盖继承而来的属性。\nconsole.log(another_stooge.firstName) //Micheal\n\ndelete another_stooge.firstName;   // true\nconsole.log(another_stooge.firstName) // Jerome //删除后，又访问了继承而来的值，\n\ndelete another_stooge.firstName; //true; 但是没有真实的删除。\nconsole.log(another_stooge.firstName) // Jerome\n```\n\n这是因为javascript基于原型的设计，如果可以删除继承而来的属性，那么将会影响所有继承于这个对象的其他对象，这样整个javascript的对象系统就乱了。\n\nBTW, 祝大伙平安夜快乐，圣诞快乐 ：)\n","source":"_posts/the-object-of-javascript.md","raw":"---\ntitle: Javascript 对象简介\ndate: 2014/1/12 22:03:29\ncategories:\n- Shit Done\ntags:\n- Javascript\n---\n#### javascript对象的属性检索\n\n今天提提javascript中对象值得一提的东西。\n##### 1. 如果访问一个对象的属性不存在，那么返回undefined。\n\n``` javascript\n// if a property is not exsist ,then return undefine\nvar stooge = {\n    firstName: \"Jerome\",\n    'last_name': \"Howard\" \n};\n\nconsole.log(stooge.firstName);  //Jerome\nconsole.log(stooge.nikeName); // undefine\n```\n##### 2. 我们可以给用 \"||\" 运算符给对象的属性赋默认值。\n\n``` javascript\n//use '||' operator to set varliable default value;\nvar nikeName1  = stooge.nikeName || \"none\";\nif(nikeName1){\n    console.log(\"nikeName1 is: \" + true); //nikeName1 is true\n}\nconsole.log(nikeName1);  //none\n```\n\n<!--more-->\n##### 3. 如果我们访问一个对象的不存在的属性的属性，那么将会跑TypeError错误。\n\n``` javascript\n console.log(stooge.nikeName.length); //TypeError\n```\n\n为了避免这种情况的发生，我们可以使用\"&&\"运算符.\n\n``` javascript\n//to prevent this case, we can use '&&' operator.\nvar nikeNam2 = (stooge.nikeName && stooge.nikeName.length)\nconsole.log(nikeNam2);\nif(nikeNam2){\n    console.log(\"nikeNam2 is: \" + true);\n}else{\n    console.log(\"nikeNam2 is: \" + false);\n}\n```\n##### 4. 我们都知道javascrip是基于原型继承实现的面向对象，与java基于类的继承不同的一种面向对象实现方式。javascript中每个新创建的对象都是继承了另一个对象的属性。为了让这种关系明显的显示出来我们可以定义如下的方法。\n\n``` javascript\n//Prototype 原型\nconsole.log(Object.beget); //undefine\nif (typeof Object.beget !== 'function') {\n    Object.create = function(o){\n        var F = new Function();\n        F.prototype = o;\n        return new F();\n    };\n}\nvar another_stooge = Object.create(stooge); //another_stooge 继承于stooge。\nconsole.log(\"another_stooge: \" + another_stooge.firstName); //Jerome（继承来的属性）\nconsole.log(\"another_stooge: \" + another_stooge.fun()); //fun (继承来的方法)\n```\n\n关于javascript的原型继承，属于javascript中很大的一部分内容，我们后面还会讲到。\n#### javascript对象属性的遍历\n##### 5. 既然javascript中的对象继承了另一个对象的属性和方法，那么我们在访问这个对象的时候，通常我们会有这样的需求，就是想访问这个对象本身扩展的所有的属性。解决方法如下。\n\n``` javascript\n//我们便于测试先给another_stooge添加自己的属性和方法。\nanother_stooge.nikeName = \"Bob\"; \nanother_stooge.fun2 = function(){\n    console.log(\"another_stooge's function....\");\n}\n\n//过滤继承而来的属性和方法\nfor(name in another_stooge){\n    if(another_stooge.hasOwnProperty(name)){\n        console.log(name);  //nikeName fun2\n    }\n}\n```\n##### 6.如果我们有让对象的属性按我们想要的顺序输出，那么我们可以这样做。\n\n``` javascript\n//定义一个循环变量\nvar i;\n//定义顺序数组\nvar properties = [\n    'nikeName',\n    'firstName',\n    'last_name',\n    'fun',\n    'fun2'\n];\n//循环按顺序输出属性。\nfor(i = 0; i < properties.length; i++){\n    console.log(properties[i] + \" : \"+ another_stooge[properties[i]]);\n}\n```\n#### javascript对象属性的删除\n##### 6.当对象的属性与继承而来的属性同名时，会覆盖继承而来的属性值。但删除操作对于对象自己的属性是有作用的对继承而来属性是没有作用的。\n\n``` javascript\n//delete\nconsole.log(another_stooge.firstName) // Jerome\nanother_stooge.firstName = \"Micheal\";//覆盖继承而来的属性。\nconsole.log(another_stooge.firstName) //Micheal\n\ndelete another_stooge.firstName;   // true\nconsole.log(another_stooge.firstName) // Jerome //删除后，又访问了继承而来的值，\n\ndelete another_stooge.firstName; //true; 但是没有真实的删除。\nconsole.log(another_stooge.firstName) // Jerome\n```\n\n这是因为javascript基于原型的设计，如果可以删除继承而来的属性，那么将会影响所有继承于这个对象的其他对象，这样整个javascript的对象系统就乱了。\n\nBTW, 祝大伙平安夜快乐，圣诞快乐 ：)\n","slug":"the-object-of-javascript","published":1,"updated":"2018-08-05T04:24:47.003Z","_id":"cjkgcdvlo001vue8icfj6kfpn","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"javascript对象的属性检索\"><a href=\"#javascript对象的属性检索\" class=\"headerlink\" title=\"javascript对象的属性检索\"></a>javascript对象的属性检索</h4><p>今天提提javascript中对象值得一提的东西。</p>\n<h5 id=\"1-如果访问一个对象的属性不存在，那么返回undefined。\"><a href=\"#1-如果访问一个对象的属性不存在，那么返回undefined。\" class=\"headerlink\" title=\"1. 如果访问一个对象的属性不存在，那么返回undefined。\"></a>1. 如果访问一个对象的属性不存在，那么返回undefined。</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// if a property is not exsist ,then return undefine</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> stooge = &#123;</span><br><span class=\"line\">    firstName: <span class=\"string\">\"Jerome\"</span>,</span><br><span class=\"line\">    <span class=\"string\">'last_name'</span>: <span class=\"string\">\"Howard\"</span> </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stooge.firstName);  <span class=\"comment\">//Jerome</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stooge.nikeName); <span class=\"comment\">// undefine</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"2-我们可以给用-“-”-运算符给对象的属性赋默认值。\"><a href=\"#2-我们可以给用-“-”-运算符给对象的属性赋默认值。\" class=\"headerlink\" title=\"2. 我们可以给用 “||” 运算符给对象的属性赋默认值。\"></a>2. 我们可以给用 “||” 运算符给对象的属性赋默认值。</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//use '||' operator to set varliable default value;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> nikeName1  = stooge.nikeName || <span class=\"string\">\"none\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(nikeName1)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"nikeName1 is: \"</span> + <span class=\"literal\">true</span>); <span class=\"comment\">//nikeName1 is true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(nikeName1);  <span class=\"comment\">//none</span></span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h5 id=\"3-如果我们访问一个对象的不存在的属性的属性，那么将会跑TypeError错误。\"><a href=\"#3-如果我们访问一个对象的不存在的属性的属性，那么将会跑TypeError错误。\" class=\"headerlink\" title=\"3. 如果我们访问一个对象的不存在的属性的属性，那么将会跑TypeError错误。\"></a>3. 如果我们访问一个对象的不存在的属性的属性，那么将会跑TypeError错误。</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(stooge.nikeName.length); <span class=\"comment\">//TypeError</span></span><br></pre></td></tr></table></figure>\n<p>为了避免这种情况的发生，我们可以使用”&amp;&amp;”运算符.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//to prevent this case, we can use '&amp;&amp;' operator.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> nikeNam2 = (stooge.nikeName &amp;&amp; stooge.nikeName.length)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(nikeNam2);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(nikeNam2)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"nikeNam2 is: \"</span> + <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"nikeNam2 is: \"</span> + <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"4-我们都知道javascrip是基于原型继承实现的面向对象，与java基于类的继承不同的一种面向对象实现方式。javascript中每个新创建的对象都是继承了另一个对象的属性。为了让这种关系明显的显示出来我们可以定义如下的方法。\"><a href=\"#4-我们都知道javascrip是基于原型继承实现的面向对象，与java基于类的继承不同的一种面向对象实现方式。javascript中每个新创建的对象都是继承了另一个对象的属性。为了让这种关系明显的显示出来我们可以定义如下的方法。\" class=\"headerlink\" title=\"4. 我们都知道javascrip是基于原型继承实现的面向对象，与java基于类的继承不同的一种面向对象实现方式。javascript中每个新创建的对象都是继承了另一个对象的属性。为了让这种关系明显的显示出来我们可以定义如下的方法。\"></a>4. 我们都知道javascrip是基于原型继承实现的面向对象，与java基于类的继承不同的一种面向对象实现方式。javascript中每个新创建的对象都是继承了另一个对象的属性。为了让这种关系明显的显示出来我们可以定义如下的方法。</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Prototype 原型</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.beget); <span class=\"comment\">//undefine</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">Object</span>.beget !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.create = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">o</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> F = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>();</span><br><span class=\"line\">        F.prototype = o;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> another_stooge = <span class=\"built_in\">Object</span>.create(stooge); <span class=\"comment\">//another_stooge 继承于stooge。</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"another_stooge: \"</span> + another_stooge.firstName); <span class=\"comment\">//Jerome（继承来的属性）</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"another_stooge: \"</span> + another_stooge.fun()); <span class=\"comment\">//fun (继承来的方法)</span></span><br></pre></td></tr></table></figure>\n<p>关于javascript的原型继承，属于javascript中很大的一部分内容，我们后面还会讲到。</p>\n<h4 id=\"javascript对象属性的遍历\"><a href=\"#javascript对象属性的遍历\" class=\"headerlink\" title=\"javascript对象属性的遍历\"></a>javascript对象属性的遍历</h4><h5 id=\"5-既然javascript中的对象继承了另一个对象的属性和方法，那么我们在访问这个对象的时候，通常我们会有这样的需求，就是想访问这个对象本身扩展的所有的属性。解决方法如下。\"><a href=\"#5-既然javascript中的对象继承了另一个对象的属性和方法，那么我们在访问这个对象的时候，通常我们会有这样的需求，就是想访问这个对象本身扩展的所有的属性。解决方法如下。\" class=\"headerlink\" title=\"5. 既然javascript中的对象继承了另一个对象的属性和方法，那么我们在访问这个对象的时候，通常我们会有这样的需求，就是想访问这个对象本身扩展的所有的属性。解决方法如下。\"></a>5. 既然javascript中的对象继承了另一个对象的属性和方法，那么我们在访问这个对象的时候，通常我们会有这样的需求，就是想访问这个对象本身扩展的所有的属性。解决方法如下。</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//我们便于测试先给another_stooge添加自己的属性和方法。</span></span><br><span class=\"line\">another_stooge.nikeName = <span class=\"string\">\"Bob\"</span>; </span><br><span class=\"line\">another_stooge.fun2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"another_stooge's function....\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//过滤继承而来的属性和方法</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(name <span class=\"keyword\">in</span> another_stooge)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(another_stooge.hasOwnProperty(name))&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(name);  <span class=\"comment\">//nikeName fun2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"6-如果我们有让对象的属性按我们想要的顺序输出，那么我们可以这样做。\"><a href=\"#6-如果我们有让对象的属性按我们想要的顺序输出，那么我们可以这样做。\" class=\"headerlink\" title=\"6.如果我们有让对象的属性按我们想要的顺序输出，那么我们可以这样做。\"></a>6.如果我们有让对象的属性按我们想要的顺序输出，那么我们可以这样做。</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义一个循环变量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> i;</span><br><span class=\"line\"><span class=\"comment\">//定义顺序数组</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> properties = [</span><br><span class=\"line\">    <span class=\"string\">'nikeName'</span>,</span><br><span class=\"line\">    <span class=\"string\">'firstName'</span>,</span><br><span class=\"line\">    <span class=\"string\">'last_name'</span>,</span><br><span class=\"line\">    <span class=\"string\">'fun'</span>,</span><br><span class=\"line\">    <span class=\"string\">'fun2'</span></span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"comment\">//循环按顺序输出属性。</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; properties.length; i++)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(properties[i] + <span class=\"string\">\" : \"</span>+ another_stooge[properties[i]]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"javascript对象属性的删除\"><a href=\"#javascript对象属性的删除\" class=\"headerlink\" title=\"javascript对象属性的删除\"></a>javascript对象属性的删除</h4><h5 id=\"6-当对象的属性与继承而来的属性同名时，会覆盖继承而来的属性值。但删除操作对于对象自己的属性是有作用的对继承而来属性是没有作用的。\"><a href=\"#6-当对象的属性与继承而来的属性同名时，会覆盖继承而来的属性值。但删除操作对于对象自己的属性是有作用的对继承而来属性是没有作用的。\" class=\"headerlink\" title=\"6.当对象的属性与继承而来的属性同名时，会覆盖继承而来的属性值。但删除操作对于对象自己的属性是有作用的对继承而来属性是没有作用的。\"></a>6.当对象的属性与继承而来的属性同名时，会覆盖继承而来的属性值。但删除操作对于对象自己的属性是有作用的对继承而来属性是没有作用的。</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//delete</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(another_stooge.firstName) <span class=\"comment\">// Jerome</span></span><br><span class=\"line\">another_stooge.firstName = <span class=\"string\">\"Micheal\"</span>;<span class=\"comment\">//覆盖继承而来的属性。</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(another_stooge.firstName) <span class=\"comment\">//Micheal</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">delete</span> another_stooge.firstName;   <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(another_stooge.firstName) <span class=\"comment\">// Jerome //删除后，又访问了继承而来的值，</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">delete</span> another_stooge.firstName; <span class=\"comment\">//true; 但是没有真实的删除。</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(another_stooge.firstName) <span class=\"comment\">// Jerome</span></span><br></pre></td></tr></table></figure>\n<p>这是因为javascript基于原型的设计，如果可以删除继承而来的属性，那么将会影响所有继承于这个对象的其他对象，这样整个javascript的对象系统就乱了。</p>\n<p>BTW, 祝大伙平安夜快乐，圣诞快乐 ：)</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"javascript对象的属性检索\"><a href=\"#javascript对象的属性检索\" class=\"headerlink\" title=\"javascript对象的属性检索\"></a>javascript对象的属性检索</h4><p>今天提提javascript中对象值得一提的东西。</p>\n<h5 id=\"1-如果访问一个对象的属性不存在，那么返回undefined。\"><a href=\"#1-如果访问一个对象的属性不存在，那么返回undefined。\" class=\"headerlink\" title=\"1. 如果访问一个对象的属性不存在，那么返回undefined。\"></a>1. 如果访问一个对象的属性不存在，那么返回undefined。</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// if a property is not exsist ,then return undefine</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> stooge = &#123;</span><br><span class=\"line\">    firstName: <span class=\"string\">\"Jerome\"</span>,</span><br><span class=\"line\">    <span class=\"string\">'last_name'</span>: <span class=\"string\">\"Howard\"</span> </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stooge.firstName);  <span class=\"comment\">//Jerome</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stooge.nikeName); <span class=\"comment\">// undefine</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"2-我们可以给用-“-”-运算符给对象的属性赋默认值。\"><a href=\"#2-我们可以给用-“-”-运算符给对象的属性赋默认值。\" class=\"headerlink\" title=\"2. 我们可以给用 “||” 运算符给对象的属性赋默认值。\"></a>2. 我们可以给用 “||” 运算符给对象的属性赋默认值。</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//use '||' operator to set varliable default value;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> nikeName1  = stooge.nikeName || <span class=\"string\">\"none\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(nikeName1)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"nikeName1 is: \"</span> + <span class=\"literal\">true</span>); <span class=\"comment\">//nikeName1 is true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(nikeName1);  <span class=\"comment\">//none</span></span><br></pre></td></tr></table></figure>","more":"<h5 id=\"3-如果我们访问一个对象的不存在的属性的属性，那么将会跑TypeError错误。\"><a href=\"#3-如果我们访问一个对象的不存在的属性的属性，那么将会跑TypeError错误。\" class=\"headerlink\" title=\"3. 如果我们访问一个对象的不存在的属性的属性，那么将会跑TypeError错误。\"></a>3. 如果我们访问一个对象的不存在的属性的属性，那么将会跑TypeError错误。</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(stooge.nikeName.length); <span class=\"comment\">//TypeError</span></span><br></pre></td></tr></table></figure>\n<p>为了避免这种情况的发生，我们可以使用”&amp;&amp;”运算符.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//to prevent this case, we can use '&amp;&amp;' operator.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> nikeNam2 = (stooge.nikeName &amp;&amp; stooge.nikeName.length)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(nikeNam2);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(nikeNam2)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"nikeNam2 is: \"</span> + <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"nikeNam2 is: \"</span> + <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"4-我们都知道javascrip是基于原型继承实现的面向对象，与java基于类的继承不同的一种面向对象实现方式。javascript中每个新创建的对象都是继承了另一个对象的属性。为了让这种关系明显的显示出来我们可以定义如下的方法。\"><a href=\"#4-我们都知道javascrip是基于原型继承实现的面向对象，与java基于类的继承不同的一种面向对象实现方式。javascript中每个新创建的对象都是继承了另一个对象的属性。为了让这种关系明显的显示出来我们可以定义如下的方法。\" class=\"headerlink\" title=\"4. 我们都知道javascrip是基于原型继承实现的面向对象，与java基于类的继承不同的一种面向对象实现方式。javascript中每个新创建的对象都是继承了另一个对象的属性。为了让这种关系明显的显示出来我们可以定义如下的方法。\"></a>4. 我们都知道javascrip是基于原型继承实现的面向对象，与java基于类的继承不同的一种面向对象实现方式。javascript中每个新创建的对象都是继承了另一个对象的属性。为了让这种关系明显的显示出来我们可以定义如下的方法。</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Prototype 原型</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.beget); <span class=\"comment\">//undefine</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">Object</span>.beget !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.create = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">o</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> F = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>();</span><br><span class=\"line\">        F.prototype = o;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> another_stooge = <span class=\"built_in\">Object</span>.create(stooge); <span class=\"comment\">//another_stooge 继承于stooge。</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"another_stooge: \"</span> + another_stooge.firstName); <span class=\"comment\">//Jerome（继承来的属性）</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"another_stooge: \"</span> + another_stooge.fun()); <span class=\"comment\">//fun (继承来的方法)</span></span><br></pre></td></tr></table></figure>\n<p>关于javascript的原型继承，属于javascript中很大的一部分内容，我们后面还会讲到。</p>\n<h4 id=\"javascript对象属性的遍历\"><a href=\"#javascript对象属性的遍历\" class=\"headerlink\" title=\"javascript对象属性的遍历\"></a>javascript对象属性的遍历</h4><h5 id=\"5-既然javascript中的对象继承了另一个对象的属性和方法，那么我们在访问这个对象的时候，通常我们会有这样的需求，就是想访问这个对象本身扩展的所有的属性。解决方法如下。\"><a href=\"#5-既然javascript中的对象继承了另一个对象的属性和方法，那么我们在访问这个对象的时候，通常我们会有这样的需求，就是想访问这个对象本身扩展的所有的属性。解决方法如下。\" class=\"headerlink\" title=\"5. 既然javascript中的对象继承了另一个对象的属性和方法，那么我们在访问这个对象的时候，通常我们会有这样的需求，就是想访问这个对象本身扩展的所有的属性。解决方法如下。\"></a>5. 既然javascript中的对象继承了另一个对象的属性和方法，那么我们在访问这个对象的时候，通常我们会有这样的需求，就是想访问这个对象本身扩展的所有的属性。解决方法如下。</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//我们便于测试先给another_stooge添加自己的属性和方法。</span></span><br><span class=\"line\">another_stooge.nikeName = <span class=\"string\">\"Bob\"</span>; </span><br><span class=\"line\">another_stooge.fun2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"another_stooge's function....\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//过滤继承而来的属性和方法</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(name <span class=\"keyword\">in</span> another_stooge)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(another_stooge.hasOwnProperty(name))&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(name);  <span class=\"comment\">//nikeName fun2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"6-如果我们有让对象的属性按我们想要的顺序输出，那么我们可以这样做。\"><a href=\"#6-如果我们有让对象的属性按我们想要的顺序输出，那么我们可以这样做。\" class=\"headerlink\" title=\"6.如果我们有让对象的属性按我们想要的顺序输出，那么我们可以这样做。\"></a>6.如果我们有让对象的属性按我们想要的顺序输出，那么我们可以这样做。</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义一个循环变量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> i;</span><br><span class=\"line\"><span class=\"comment\">//定义顺序数组</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> properties = [</span><br><span class=\"line\">    <span class=\"string\">'nikeName'</span>,</span><br><span class=\"line\">    <span class=\"string\">'firstName'</span>,</span><br><span class=\"line\">    <span class=\"string\">'last_name'</span>,</span><br><span class=\"line\">    <span class=\"string\">'fun'</span>,</span><br><span class=\"line\">    <span class=\"string\">'fun2'</span></span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"comment\">//循环按顺序输出属性。</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; properties.length; i++)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(properties[i] + <span class=\"string\">\" : \"</span>+ another_stooge[properties[i]]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"javascript对象属性的删除\"><a href=\"#javascript对象属性的删除\" class=\"headerlink\" title=\"javascript对象属性的删除\"></a>javascript对象属性的删除</h4><h5 id=\"6-当对象的属性与继承而来的属性同名时，会覆盖继承而来的属性值。但删除操作对于对象自己的属性是有作用的对继承而来属性是没有作用的。\"><a href=\"#6-当对象的属性与继承而来的属性同名时，会覆盖继承而来的属性值。但删除操作对于对象自己的属性是有作用的对继承而来属性是没有作用的。\" class=\"headerlink\" title=\"6.当对象的属性与继承而来的属性同名时，会覆盖继承而来的属性值。但删除操作对于对象自己的属性是有作用的对继承而来属性是没有作用的。\"></a>6.当对象的属性与继承而来的属性同名时，会覆盖继承而来的属性值。但删除操作对于对象自己的属性是有作用的对继承而来属性是没有作用的。</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//delete</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(another_stooge.firstName) <span class=\"comment\">// Jerome</span></span><br><span class=\"line\">another_stooge.firstName = <span class=\"string\">\"Micheal\"</span>;<span class=\"comment\">//覆盖继承而来的属性。</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(another_stooge.firstName) <span class=\"comment\">//Micheal</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">delete</span> another_stooge.firstName;   <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(another_stooge.firstName) <span class=\"comment\">// Jerome //删除后，又访问了继承而来的值，</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">delete</span> another_stooge.firstName; <span class=\"comment\">//true; 但是没有真实的删除。</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(another_stooge.firstName) <span class=\"comment\">// Jerome</span></span><br></pre></td></tr></table></figure>\n<p>这是因为javascript基于原型的设计，如果可以删除继承而来的属性，那么将会影响所有继承于这个对象的其他对象，这样整个javascript的对象系统就乱了。</p>\n<p>BTW, 祝大伙平安夜快乐，圣诞快乐 ：)</p>"},{"title":"Javascript 数组诡异的 length 属性","date":"2014-04-28T12:03:29.000Z","_content":"\n#### 一、 javascript数组简介\n-   javascript中数组其实本质是一个对象,只是javascript作者想用一个对象来模拟数组这种数据结构的特性。我们来看下面这段代码：\n\n``` javascript\nvar empty = [];\nvar numbers = ['zero', 'one', 'two', 'three', 'four'];\nvar numbers_object = {\n    0: 'zero',\n    1: 'one',\n    2: 'two',\n    3: 'three',\n    4: 'four'\n}\nconsole.log(empty[0]) //undefine  访问不存在的元素返回undefine\nconsole.log(numbers[1]) //one\n```\n\n其实numbers与numbers_object本质是一样都是对象，但是为了让numbers比一般的对象更具数组特性，让所有想具有数组特性的对象，如：numbers，继承自Array.prototype，而numbers_object继承自Object.prototype,这样numbers具有了大量了一般对象没有的有用的方法和我们下面将要讨论的length属性。\n\n<!--more-->\n-  javascript数组对象的可以是混合类型的\n\n``` javascript\nvar misc=[\n    'string', 98.6, true, false, null, undefine, ['nested', 'array'],\n    {name: 'Bob'}, NaN\n]\n```\n#### 二、javascript诡异的length属性\n\n先来看一段代码，可以对照后面的注释答案，看看与你想的是否一样。\n\n``` javascript\nvar myArray = [];\nconsole.log(myArray.length); // 0\n\n//有一个元素，但是length却为0。\nmyArray[4294967300] = 'big number';\nconsole.log(myArray.length); // 0 \n\nmyArray[0] = 'zero';\nmyArray[1] = 'one';\nconsole.log(myArray.length); // 2\n\n//默认转化为数字2\nmyArray['2'] = 'two' ;\nconsole.log(myArray.length); // 3\n\n\n//一般的字符串属性不影响length值。\nmyArray['prop1'] = 'prop1';\nconsole.log(myArray.length); //3\n\n//直接设置一个100，数组对象的元素个数为4个，但是length却是101\nmyArray[100] = '100';\nconsole.log(myArray.length); // 101\n\n//同理\nmyArray['200'] = '200';\nconsole.log(myArray.length); // 201\n\nmyArray[4294967294] = 'big number';\nconsole.log(myArray.length); // 4294967295\n\n//length的最大值为：4294967295\nmyArray[4294967300] = 'another big number';\nconsole.log(myArray.length); // 4294967295\n\n\nmyArray.length = 0;\nconsole.log(myArray);     //[];  //数组被清空。\n\n//不影响非数字属性。\nconsole.log(myArray['prop1']) ;   //prop1\n```\n\n估计这会让你大跌眼镜，这个length好诡异把。\n好了我们来总结下。\n#### 三、javascript数组length总结\n\n产生上面的困惑与[]运算符的二义性和length的特性有关。\n##### 1. [] 运算符的二义性：同时为数组下标运算符和对象属性存取符。\n-  []运算符后面接的元算元可以是变量，直接量，表达式。而'.'运算符右边的运算元必须是标识符,所以\"abc.def\" , '1' , '.'这些属性名只能使用[]运算符访问。所以可以理解为[]功能比'.'运算符更强大，而'.'运算符比[]运算符的可读性高。\n-  []运算符会把它包含的表达式转换成一个字符串，如果该表达式有tostring方法就使用该方法转换。并且这个字符串会被用于做属性名，当但是当对象同时也是数组，且这个字符串能被转换为下标数字时，如：myArray['2'] ,这个属性的存在却影响了数组的length的值。而myArray['prop']却不会影响length值。\n##### 2. length的特性\n-   如果这个[]运算符中的字符串看起来像大于等于当前的length并且小于429496709正整数，那么length就被重新赋值为新的下标加1. 根据ECMAScript262标准，数下标必须大于等于0 小于2 e32 - 1。\n-   你可以直接给length指定一个值，如果length值大于当前的数组对象内元素个数，数组对象不会得到更多的空间，但是把length设置为小于当前数组对象内元素个数那么大于length的属性将会直接删除，可见length是很诡异，可以说这是javascript的一个失败的设计，应当慎用。但不会影响到对象的非数字属性。如： myArray['prop'];\n\n对照总结再把上面的代码对照一遍，你就明白了为什么会是这个结果了。\n#### 四、javascript数组元素的删除\n\n我们怎么正确的删除一个数组的元素呢？\n1. 错误的删除方式：\n\n``` javascript\n//先声明一个数组\nvar myArray2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n//尝试删除元素\ndelete  myArray2[2]; \nconsole.log(myArray2); //[1, 2, undefined × 1, 4, 5, 6, 7, 8, 9, 10] \nconsole.log(myArray2.length);  //10\n```\n\n可见使用delete删除一个元素 虽然删除了但是还占着一个坑，后面的元素索引没有减一。长度还是10\n究其原因是delete把myArray2当作对象，删除了其一个属性而已。\n1. 正确了删除方式：\n\n``` javascript\n//从第下标为2的元素开始删除，删除一个元素。\nmyArray2.splice(2, 1);  \nconsole.log(myArray2);  //[1, 2, 4, 5, 6, 7, 8, 9, 10]\nconsole.log(myArray2.length);  //9  \n```\n\n调用splice方法，最后长度为9。达到了删除数组元素的目的。\n","source":"_posts/length-of-javascript-array.md","raw":"---\ntitle: Javascript 数组诡异的 length 属性\ndate: 2014/4/28 20:03:29\ncategories:\n- Shit Done\ntags:\n- Javascript\n---\n\n#### 一、 javascript数组简介\n-   javascript中数组其实本质是一个对象,只是javascript作者想用一个对象来模拟数组这种数据结构的特性。我们来看下面这段代码：\n\n``` javascript\nvar empty = [];\nvar numbers = ['zero', 'one', 'two', 'three', 'four'];\nvar numbers_object = {\n    0: 'zero',\n    1: 'one',\n    2: 'two',\n    3: 'three',\n    4: 'four'\n}\nconsole.log(empty[0]) //undefine  访问不存在的元素返回undefine\nconsole.log(numbers[1]) //one\n```\n\n其实numbers与numbers_object本质是一样都是对象，但是为了让numbers比一般的对象更具数组特性，让所有想具有数组特性的对象，如：numbers，继承自Array.prototype，而numbers_object继承自Object.prototype,这样numbers具有了大量了一般对象没有的有用的方法和我们下面将要讨论的length属性。\n\n<!--more-->\n-  javascript数组对象的可以是混合类型的\n\n``` javascript\nvar misc=[\n    'string', 98.6, true, false, null, undefine, ['nested', 'array'],\n    {name: 'Bob'}, NaN\n]\n```\n#### 二、javascript诡异的length属性\n\n先来看一段代码，可以对照后面的注释答案，看看与你想的是否一样。\n\n``` javascript\nvar myArray = [];\nconsole.log(myArray.length); // 0\n\n//有一个元素，但是length却为0。\nmyArray[4294967300] = 'big number';\nconsole.log(myArray.length); // 0 \n\nmyArray[0] = 'zero';\nmyArray[1] = 'one';\nconsole.log(myArray.length); // 2\n\n//默认转化为数字2\nmyArray['2'] = 'two' ;\nconsole.log(myArray.length); // 3\n\n\n//一般的字符串属性不影响length值。\nmyArray['prop1'] = 'prop1';\nconsole.log(myArray.length); //3\n\n//直接设置一个100，数组对象的元素个数为4个，但是length却是101\nmyArray[100] = '100';\nconsole.log(myArray.length); // 101\n\n//同理\nmyArray['200'] = '200';\nconsole.log(myArray.length); // 201\n\nmyArray[4294967294] = 'big number';\nconsole.log(myArray.length); // 4294967295\n\n//length的最大值为：4294967295\nmyArray[4294967300] = 'another big number';\nconsole.log(myArray.length); // 4294967295\n\n\nmyArray.length = 0;\nconsole.log(myArray);     //[];  //数组被清空。\n\n//不影响非数字属性。\nconsole.log(myArray['prop1']) ;   //prop1\n```\n\n估计这会让你大跌眼镜，这个length好诡异把。\n好了我们来总结下。\n#### 三、javascript数组length总结\n\n产生上面的困惑与[]运算符的二义性和length的特性有关。\n##### 1. [] 运算符的二义性：同时为数组下标运算符和对象属性存取符。\n-  []运算符后面接的元算元可以是变量，直接量，表达式。而'.'运算符右边的运算元必须是标识符,所以\"abc.def\" , '1' , '.'这些属性名只能使用[]运算符访问。所以可以理解为[]功能比'.'运算符更强大，而'.'运算符比[]运算符的可读性高。\n-  []运算符会把它包含的表达式转换成一个字符串，如果该表达式有tostring方法就使用该方法转换。并且这个字符串会被用于做属性名，当但是当对象同时也是数组，且这个字符串能被转换为下标数字时，如：myArray['2'] ,这个属性的存在却影响了数组的length的值。而myArray['prop']却不会影响length值。\n##### 2. length的特性\n-   如果这个[]运算符中的字符串看起来像大于等于当前的length并且小于429496709正整数，那么length就被重新赋值为新的下标加1. 根据ECMAScript262标准，数下标必须大于等于0 小于2 e32 - 1。\n-   你可以直接给length指定一个值，如果length值大于当前的数组对象内元素个数，数组对象不会得到更多的空间，但是把length设置为小于当前数组对象内元素个数那么大于length的属性将会直接删除，可见length是很诡异，可以说这是javascript的一个失败的设计，应当慎用。但不会影响到对象的非数字属性。如： myArray['prop'];\n\n对照总结再把上面的代码对照一遍，你就明白了为什么会是这个结果了。\n#### 四、javascript数组元素的删除\n\n我们怎么正确的删除一个数组的元素呢？\n1. 错误的删除方式：\n\n``` javascript\n//先声明一个数组\nvar myArray2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n//尝试删除元素\ndelete  myArray2[2]; \nconsole.log(myArray2); //[1, 2, undefined × 1, 4, 5, 6, 7, 8, 9, 10] \nconsole.log(myArray2.length);  //10\n```\n\n可见使用delete删除一个元素 虽然删除了但是还占着一个坑，后面的元素索引没有减一。长度还是10\n究其原因是delete把myArray2当作对象，删除了其一个属性而已。\n1. 正确了删除方式：\n\n``` javascript\n//从第下标为2的元素开始删除，删除一个元素。\nmyArray2.splice(2, 1);  \nconsole.log(myArray2);  //[1, 2, 4, 5, 6, 7, 8, 9, 10]\nconsole.log(myArray2.length);  //9  \n```\n\n调用splice方法，最后长度为9。达到了删除数组元素的目的。\n","slug":"length-of-javascript-array","published":1,"updated":"2018-08-05T04:27:09.565Z","_id":"cjkgch03o0021ue8i9q6gyosc","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"一、-javascript数组简介\"><a href=\"#一、-javascript数组简介\" class=\"headerlink\" title=\"一、 javascript数组简介\"></a>一、 javascript数组简介</h4><ul>\n<li>javascript中数组其实本质是一个对象,只是javascript作者想用一个对象来模拟数组这种数据结构的特性。我们来看下面这段代码：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> empty = [];</span><br><span class=\"line\"><span class=\"keyword\">var</span> numbers = [<span class=\"string\">'zero'</span>, <span class=\"string\">'one'</span>, <span class=\"string\">'two'</span>, <span class=\"string\">'three'</span>, <span class=\"string\">'four'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> numbers_object = &#123;</span><br><span class=\"line\">    <span class=\"number\">0</span>: <span class=\"string\">'zero'</span>,</span><br><span class=\"line\">    <span class=\"number\">1</span>: <span class=\"string\">'one'</span>,</span><br><span class=\"line\">    <span class=\"number\">2</span>: <span class=\"string\">'two'</span>,</span><br><span class=\"line\">    <span class=\"number\">3</span>: <span class=\"string\">'three'</span>,</span><br><span class=\"line\">    <span class=\"number\">4</span>: <span class=\"string\">'four'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(empty[<span class=\"number\">0</span>]) <span class=\"comment\">//undefine  访问不存在的元素返回undefine</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(numbers[<span class=\"number\">1</span>]) <span class=\"comment\">//one</span></span><br></pre></td></tr></table></figure>\n<p>其实numbers与numbers_object本质是一样都是对象，但是为了让numbers比一般的对象更具数组特性，让所有想具有数组特性的对象，如：numbers，继承自Array.prototype，而numbers_object继承自Object.prototype,这样numbers具有了大量了一般对象没有的有用的方法和我们下面将要讨论的length属性。</p>\n<a id=\"more\"></a>\n<ul>\n<li>javascript数组对象的可以是混合类型的</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> misc=[</span><br><span class=\"line\">    <span class=\"string\">'string'</span>, <span class=\"number\">98.6</span>, <span class=\"literal\">true</span>, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>, undefine, [<span class=\"string\">'nested'</span>, <span class=\"string\">'array'</span>],</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">'Bob'</span>&#125;, <span class=\"literal\">NaN</span></span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h4 id=\"二、javascript诡异的length属性\"><a href=\"#二、javascript诡异的length属性\" class=\"headerlink\" title=\"二、javascript诡异的length属性\"></a>二、javascript诡异的length属性</h4><p>先来看一段代码，可以对照后面的注释答案，看看与你想的是否一样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myArray = [];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray.length); <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//有一个元素，但是length却为0。</span></span><br><span class=\"line\">myArray[<span class=\"number\">4294967300</span>] = <span class=\"string\">'big number'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray.length); <span class=\"comment\">// 0 </span></span><br><span class=\"line\"></span><br><span class=\"line\">myArray[<span class=\"number\">0</span>] = <span class=\"string\">'zero'</span>;</span><br><span class=\"line\">myArray[<span class=\"number\">1</span>] = <span class=\"string\">'one'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray.length); <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//默认转化为数字2</span></span><br><span class=\"line\">myArray[<span class=\"string\">'2'</span>] = <span class=\"string\">'two'</span> ;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray.length); <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//一般的字符串属性不影响length值。</span></span><br><span class=\"line\">myArray[<span class=\"string\">'prop1'</span>] = <span class=\"string\">'prop1'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray.length); <span class=\"comment\">//3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//直接设置一个100，数组对象的元素个数为4个，但是length却是101</span></span><br><span class=\"line\">myArray[<span class=\"number\">100</span>] = <span class=\"string\">'100'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray.length); <span class=\"comment\">// 101</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//同理</span></span><br><span class=\"line\">myArray[<span class=\"string\">'200'</span>] = <span class=\"string\">'200'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray.length); <span class=\"comment\">// 201</span></span><br><span class=\"line\"></span><br><span class=\"line\">myArray[<span class=\"number\">4294967294</span>] = <span class=\"string\">'big number'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray.length); <span class=\"comment\">// 4294967295</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//length的最大值为：4294967295</span></span><br><span class=\"line\">myArray[<span class=\"number\">4294967300</span>] = <span class=\"string\">'another big number'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray.length); <span class=\"comment\">// 4294967295</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">myArray.length = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray);     <span class=\"comment\">//[];  //数组被清空。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//不影响非数字属性。</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray[<span class=\"string\">'prop1'</span>]) ;   <span class=\"comment\">//prop1</span></span><br></pre></td></tr></table></figure>\n<p>估计这会让你大跌眼镜，这个length好诡异把。<br>好了我们来总结下。</p>\n<h4 id=\"三、javascript数组length总结\"><a href=\"#三、javascript数组length总结\" class=\"headerlink\" title=\"三、javascript数组length总结\"></a>三、javascript数组length总结</h4><p>产生上面的困惑与[]运算符的二义性和length的特性有关。</p>\n<h5 id=\"1-运算符的二义性：同时为数组下标运算符和对象属性存取符。\"><a href=\"#1-运算符的二义性：同时为数组下标运算符和对象属性存取符。\" class=\"headerlink\" title=\"1. [] 运算符的二义性：同时为数组下标运算符和对象属性存取符。\"></a>1. [] 运算符的二义性：同时为数组下标运算符和对象属性存取符。</h5><ul>\n<li>[]运算符后面接的元算元可以是变量，直接量，表达式。而’.’运算符右边的运算元必须是标识符,所以”abc.def” , ‘1’ , ‘.’这些属性名只能使用[]运算符访问。所以可以理解为[]功能比’.’运算符更强大，而’.’运算符比[]运算符的可读性高。</li>\n<li>[]运算符会把它包含的表达式转换成一个字符串，如果该表达式有tostring方法就使用该方法转换。并且这个字符串会被用于做属性名，当但是当对象同时也是数组，且这个字符串能被转换为下标数字时，如：myArray[‘2’] ,这个属性的存在却影响了数组的length的值。而myArray[‘prop’]却不会影响length值。<h5 id=\"2-length的特性\"><a href=\"#2-length的特性\" class=\"headerlink\" title=\"2. length的特性\"></a>2. length的特性</h5></li>\n<li>如果这个[]运算符中的字符串看起来像大于等于当前的length并且小于429496709正整数，那么length就被重新赋值为新的下标加1. 根据ECMAScript262标准，数下标必须大于等于0 小于2 e32 - 1。</li>\n<li>你可以直接给length指定一个值，如果length值大于当前的数组对象内元素个数，数组对象不会得到更多的空间，但是把length设置为小于当前数组对象内元素个数那么大于length的属性将会直接删除，可见length是很诡异，可以说这是javascript的一个失败的设计，应当慎用。但不会影响到对象的非数字属性。如： myArray[‘prop’];</li>\n</ul>\n<p>对照总结再把上面的代码对照一遍，你就明白了为什么会是这个结果了。</p>\n<h4 id=\"四、javascript数组元素的删除\"><a href=\"#四、javascript数组元素的删除\" class=\"headerlink\" title=\"四、javascript数组元素的删除\"></a>四、javascript数组元素的删除</h4><p>我们怎么正确的删除一个数组的元素呢？</p>\n<ol>\n<li>错误的删除方式：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//先声明一个数组</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myArray2 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"comment\">//尝试删除元素</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span>  myArray2[<span class=\"number\">2</span>]; </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray2); <span class=\"comment\">//[1, 2, undefined × 1, 4, 5, 6, 7, 8, 9, 10] </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray2.length);  <span class=\"comment\">//10</span></span><br></pre></td></tr></table></figure>\n<p>可见使用delete删除一个元素 虽然删除了但是还占着一个坑，后面的元素索引没有减一。长度还是10<br>究其原因是delete把myArray2当作对象，删除了其一个属性而已。</p>\n<ol>\n<li>正确了删除方式：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//从第下标为2的元素开始删除，删除一个元素。</span></span><br><span class=\"line\">myArray2.splice(<span class=\"number\">2</span>, <span class=\"number\">1</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray2);  <span class=\"comment\">//[1, 2, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray2.length);  <span class=\"comment\">//9</span></span><br></pre></td></tr></table></figure>\n<p>调用splice方法，最后长度为9。达到了删除数组元素的目的。</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"一、-javascript数组简介\"><a href=\"#一、-javascript数组简介\" class=\"headerlink\" title=\"一、 javascript数组简介\"></a>一、 javascript数组简介</h4><ul>\n<li>javascript中数组其实本质是一个对象,只是javascript作者想用一个对象来模拟数组这种数据结构的特性。我们来看下面这段代码：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> empty = [];</span><br><span class=\"line\"><span class=\"keyword\">var</span> numbers = [<span class=\"string\">'zero'</span>, <span class=\"string\">'one'</span>, <span class=\"string\">'two'</span>, <span class=\"string\">'three'</span>, <span class=\"string\">'four'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> numbers_object = &#123;</span><br><span class=\"line\">    <span class=\"number\">0</span>: <span class=\"string\">'zero'</span>,</span><br><span class=\"line\">    <span class=\"number\">1</span>: <span class=\"string\">'one'</span>,</span><br><span class=\"line\">    <span class=\"number\">2</span>: <span class=\"string\">'two'</span>,</span><br><span class=\"line\">    <span class=\"number\">3</span>: <span class=\"string\">'three'</span>,</span><br><span class=\"line\">    <span class=\"number\">4</span>: <span class=\"string\">'four'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(empty[<span class=\"number\">0</span>]) <span class=\"comment\">//undefine  访问不存在的元素返回undefine</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(numbers[<span class=\"number\">1</span>]) <span class=\"comment\">//one</span></span><br></pre></td></tr></table></figure>\n<p>其实numbers与numbers_object本质是一样都是对象，但是为了让numbers比一般的对象更具数组特性，让所有想具有数组特性的对象，如：numbers，继承自Array.prototype，而numbers_object继承自Object.prototype,这样numbers具有了大量了一般对象没有的有用的方法和我们下面将要讨论的length属性。</p>","more":"<ul>\n<li>javascript数组对象的可以是混合类型的</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> misc=[</span><br><span class=\"line\">    <span class=\"string\">'string'</span>, <span class=\"number\">98.6</span>, <span class=\"literal\">true</span>, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>, undefine, [<span class=\"string\">'nested'</span>, <span class=\"string\">'array'</span>],</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">'Bob'</span>&#125;, <span class=\"literal\">NaN</span></span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h4 id=\"二、javascript诡异的length属性\"><a href=\"#二、javascript诡异的length属性\" class=\"headerlink\" title=\"二、javascript诡异的length属性\"></a>二、javascript诡异的length属性</h4><p>先来看一段代码，可以对照后面的注释答案，看看与你想的是否一样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myArray = [];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray.length); <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//有一个元素，但是length却为0。</span></span><br><span class=\"line\">myArray[<span class=\"number\">4294967300</span>] = <span class=\"string\">'big number'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray.length); <span class=\"comment\">// 0 </span></span><br><span class=\"line\"></span><br><span class=\"line\">myArray[<span class=\"number\">0</span>] = <span class=\"string\">'zero'</span>;</span><br><span class=\"line\">myArray[<span class=\"number\">1</span>] = <span class=\"string\">'one'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray.length); <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//默认转化为数字2</span></span><br><span class=\"line\">myArray[<span class=\"string\">'2'</span>] = <span class=\"string\">'two'</span> ;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray.length); <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//一般的字符串属性不影响length值。</span></span><br><span class=\"line\">myArray[<span class=\"string\">'prop1'</span>] = <span class=\"string\">'prop1'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray.length); <span class=\"comment\">//3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//直接设置一个100，数组对象的元素个数为4个，但是length却是101</span></span><br><span class=\"line\">myArray[<span class=\"number\">100</span>] = <span class=\"string\">'100'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray.length); <span class=\"comment\">// 101</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//同理</span></span><br><span class=\"line\">myArray[<span class=\"string\">'200'</span>] = <span class=\"string\">'200'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray.length); <span class=\"comment\">// 201</span></span><br><span class=\"line\"></span><br><span class=\"line\">myArray[<span class=\"number\">4294967294</span>] = <span class=\"string\">'big number'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray.length); <span class=\"comment\">// 4294967295</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//length的最大值为：4294967295</span></span><br><span class=\"line\">myArray[<span class=\"number\">4294967300</span>] = <span class=\"string\">'another big number'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray.length); <span class=\"comment\">// 4294967295</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">myArray.length = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray);     <span class=\"comment\">//[];  //数组被清空。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//不影响非数字属性。</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray[<span class=\"string\">'prop1'</span>]) ;   <span class=\"comment\">//prop1</span></span><br></pre></td></tr></table></figure>\n<p>估计这会让你大跌眼镜，这个length好诡异把。<br>好了我们来总结下。</p>\n<h4 id=\"三、javascript数组length总结\"><a href=\"#三、javascript数组length总结\" class=\"headerlink\" title=\"三、javascript数组length总结\"></a>三、javascript数组length总结</h4><p>产生上面的困惑与[]运算符的二义性和length的特性有关。</p>\n<h5 id=\"1-运算符的二义性：同时为数组下标运算符和对象属性存取符。\"><a href=\"#1-运算符的二义性：同时为数组下标运算符和对象属性存取符。\" class=\"headerlink\" title=\"1. [] 运算符的二义性：同时为数组下标运算符和对象属性存取符。\"></a>1. [] 运算符的二义性：同时为数组下标运算符和对象属性存取符。</h5><ul>\n<li>[]运算符后面接的元算元可以是变量，直接量，表达式。而’.’运算符右边的运算元必须是标识符,所以”abc.def” , ‘1’ , ‘.’这些属性名只能使用[]运算符访问。所以可以理解为[]功能比’.’运算符更强大，而’.’运算符比[]运算符的可读性高。</li>\n<li>[]运算符会把它包含的表达式转换成一个字符串，如果该表达式有tostring方法就使用该方法转换。并且这个字符串会被用于做属性名，当但是当对象同时也是数组，且这个字符串能被转换为下标数字时，如：myArray[‘2’] ,这个属性的存在却影响了数组的length的值。而myArray[‘prop’]却不会影响length值。<h5 id=\"2-length的特性\"><a href=\"#2-length的特性\" class=\"headerlink\" title=\"2. length的特性\"></a>2. length的特性</h5></li>\n<li>如果这个[]运算符中的字符串看起来像大于等于当前的length并且小于429496709正整数，那么length就被重新赋值为新的下标加1. 根据ECMAScript262标准，数下标必须大于等于0 小于2 e32 - 1。</li>\n<li>你可以直接给length指定一个值，如果length值大于当前的数组对象内元素个数，数组对象不会得到更多的空间，但是把length设置为小于当前数组对象内元素个数那么大于length的属性将会直接删除，可见length是很诡异，可以说这是javascript的一个失败的设计，应当慎用。但不会影响到对象的非数字属性。如： myArray[‘prop’];</li>\n</ul>\n<p>对照总结再把上面的代码对照一遍，你就明白了为什么会是这个结果了。</p>\n<h4 id=\"四、javascript数组元素的删除\"><a href=\"#四、javascript数组元素的删除\" class=\"headerlink\" title=\"四、javascript数组元素的删除\"></a>四、javascript数组元素的删除</h4><p>我们怎么正确的删除一个数组的元素呢？</p>\n<ol>\n<li>错误的删除方式：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//先声明一个数组</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myArray2 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"comment\">//尝试删除元素</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span>  myArray2[<span class=\"number\">2</span>]; </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray2); <span class=\"comment\">//[1, 2, undefined × 1, 4, 5, 6, 7, 8, 9, 10] </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray2.length);  <span class=\"comment\">//10</span></span><br></pre></td></tr></table></figure>\n<p>可见使用delete删除一个元素 虽然删除了但是还占着一个坑，后面的元素索引没有减一。长度还是10<br>究其原因是delete把myArray2当作对象，删除了其一个属性而已。</p>\n<ol>\n<li>正确了删除方式：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//从第下标为2的元素开始删除，删除一个元素。</span></span><br><span class=\"line\">myArray2.splice(<span class=\"number\">2</span>, <span class=\"number\">1</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray2);  <span class=\"comment\">//[1, 2, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray2.length);  <span class=\"comment\">//9</span></span><br></pre></td></tr></table></figure>\n<p>调用splice方法，最后长度为9。达到了删除数组元素的目的。</p>"},{"title":"HTML 的 DOCTYPE 标签的作用","date":"2014-06-13T11:37:30.000Z","_content":"\n\n在写html页面的时候我们一般都会在首行添加`〈!DOCTYPE〉`的标签，有些编辑器会自动帮我们添加，今天讲讲这个`〈!DOCTYPE〉`标签的作用。\n##### 一、HTML与XHTML\n\n在`W3C`组织还么颁发html标准之前，开发网页的时候大家都没有加这个标签，那个时候.html页面的开发也比较混乱，直到1999年的时候，HTML 4.01成为了推荐标准，那时候起大多数人都使用这个版本。又大概在2000年的时候，W3C组织又颁发了基于HTML4.01的XML版本，并命名为XHTML1.0。\n\n两者其实主要的差别是XHTML遵循了XML的编码标准，这意味着XHTML文档中增加了标签的属性必须包含在`\"\"`中，所有的标签必须闭合等比较严格的规定。这个也是有经验的开发人员经常提醒新手写.html页面的要注意的地方。好了，问题来了：\n- 前面我们提到在还没使用HTML 4.01作为推荐标准时，html文档是没有`〈!DOCTYPE〉`标签的，那么浏览器在面对一个.html文档时，如果有这个标签会怎么解析，没有这个文档会怎样解释。\n- 标准推出后有了两种版本（标准）来写.html文档，那么浏览器在解析html文档的时候应该使用哪种标准呢？\n\n这个时候`〈!DOCTYPE〉`标签就派上用场了。\n\n<!--more-->\n##### 二、`〈!DOCTYPE〉`约定浏览器使用什么版本的html\n\n   `<!DOCTYPE>` 声明html文档引用哪个[DTD](http://www.w3school.com.cn/dtd/)， 和哪个html版本来解析html文档。学过xml的应该对这个比较了解了.而目前的`<!DOCTYPE>`也存在着三种风格： Strict (严格)、 Transitional（过渡）、 Frameset（框架集）。\n\n  这三种风格下有这不同的要求和规定，下面看下HTML 4.01版本的声明：\n- HTML 4.01 Strict：\n\n``` html\n  <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n```\n\n   该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。这个声明在我们开发中比较少用，因为它比较严格控制了html页面上不应该出现样式控制的属性。\n- HTML 4.01 Transitional：\n\n``` html\n   <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \n\"http://www.w3.org/TR/html4/loose.dtd\">\n```\n\n该 DTD 包含所有 HTML元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。这个是目前比较常用的声明。\n- HTML 4.01 Frameset：\n\n``` html\n   <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Frameset//EN\" \n\"http://www.w3.org/TR/html4/frameset.dtd\">\n```\n\n该 DTD 等同于 HTML 4.01 Transitional，但允许框架集内容。\n\n同理，XHTML 1.0也有类似的三种风格的`<!DOCTYPE>`声明。具体的含义参见[W3C关于此标签](http://www.w3school.com.cn/tags/tag_doctype.asp) 的说明。\n\n   这个是第二个问题的答案。\n##### 三、`<!DOCTYPE>`约定浏览器使用哪种模式渲染页面\n\n  第二点是说怎么解析html文档，这个是说渲染页面，对的，渲染不仅仅是dom节点还包括css样式和javascript事件等等。\n\n  在标准未出来前html文档中没有使用`<!DOCTYPE>`标签，所以在现在有了标准后我们强烈建议要添加这个标签，不然开发的页面就跟十几年前一样了，那么浏览器为了兼容旧时代的网页而开启混杂模式。现代浏览器一般在有两种方式渲染页面。一种是混杂模式（主要是使用了上一代的盒模型，为了兼容旧时代的网页），一种是标准模式（目前主流的）。有关浏览器渲染模式可以查看[这里](https://hsivonen.fi/doctype/)。当你写的html页面因为没有声明`<!DOCTYPE>`标签，就会被混杂模式渲染，那么你css样式和javascript代码的执行都有可能会收到影响，这个问题就大了。\n\n现在直到了把，`<!DOCTYPE>`会告知浏览器应使用什么模式渲染页面。\n\n但是，我们到目前主流的网站，如： 豆瓣，新浪， 淘宝等看看页面发现他们的`<!DOCTYPE>`标签居然是这样声明的：\n\n``` html\n<!DOCTYPE html>\n```\n\n没有html版本也没有dtd链接等，这样也能正常运行？答案是：这个是第五代html版本的`<!DOCTYPE>`声明方式，也就是HTML 5的声明方式。够简洁把，而且还能够向后兼容。这也是一种很好方式，因为现在主流的浏览器都已经支持HTML 5了。\n##### 四：总结\n\n`<!DOCTYPE>`作用主要有两个：\n-  约定浏览器使用什么版本的html解析页面。\n- `约定浏览器使用哪种模式渲染页面。\n\n这是一个很重要的标签。\n","source":"_posts/doctype-of-html.md","raw":"---\ntitle: HTML 的 DOCTYPE 标签的作用\ndate: 2014/6/13 19:37:30\ncategories:\n- Shit Done\ntags:\n- HTML \n- DOCTYPE\n---\n\n\n在写html页面的时候我们一般都会在首行添加`〈!DOCTYPE〉`的标签，有些编辑器会自动帮我们添加，今天讲讲这个`〈!DOCTYPE〉`标签的作用。\n##### 一、HTML与XHTML\n\n在`W3C`组织还么颁发html标准之前，开发网页的时候大家都没有加这个标签，那个时候.html页面的开发也比较混乱，直到1999年的时候，HTML 4.01成为了推荐标准，那时候起大多数人都使用这个版本。又大概在2000年的时候，W3C组织又颁发了基于HTML4.01的XML版本，并命名为XHTML1.0。\n\n两者其实主要的差别是XHTML遵循了XML的编码标准，这意味着XHTML文档中增加了标签的属性必须包含在`\"\"`中，所有的标签必须闭合等比较严格的规定。这个也是有经验的开发人员经常提醒新手写.html页面的要注意的地方。好了，问题来了：\n- 前面我们提到在还没使用HTML 4.01作为推荐标准时，html文档是没有`〈!DOCTYPE〉`标签的，那么浏览器在面对一个.html文档时，如果有这个标签会怎么解析，没有这个文档会怎样解释。\n- 标准推出后有了两种版本（标准）来写.html文档，那么浏览器在解析html文档的时候应该使用哪种标准呢？\n\n这个时候`〈!DOCTYPE〉`标签就派上用场了。\n\n<!--more-->\n##### 二、`〈!DOCTYPE〉`约定浏览器使用什么版本的html\n\n   `<!DOCTYPE>` 声明html文档引用哪个[DTD](http://www.w3school.com.cn/dtd/)， 和哪个html版本来解析html文档。学过xml的应该对这个比较了解了.而目前的`<!DOCTYPE>`也存在着三种风格： Strict (严格)、 Transitional（过渡）、 Frameset（框架集）。\n\n  这三种风格下有这不同的要求和规定，下面看下HTML 4.01版本的声明：\n- HTML 4.01 Strict：\n\n``` html\n  <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n```\n\n   该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。这个声明在我们开发中比较少用，因为它比较严格控制了html页面上不应该出现样式控制的属性。\n- HTML 4.01 Transitional：\n\n``` html\n   <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \n\"http://www.w3.org/TR/html4/loose.dtd\">\n```\n\n该 DTD 包含所有 HTML元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。这个是目前比较常用的声明。\n- HTML 4.01 Frameset：\n\n``` html\n   <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Frameset//EN\" \n\"http://www.w3.org/TR/html4/frameset.dtd\">\n```\n\n该 DTD 等同于 HTML 4.01 Transitional，但允许框架集内容。\n\n同理，XHTML 1.0也有类似的三种风格的`<!DOCTYPE>`声明。具体的含义参见[W3C关于此标签](http://www.w3school.com.cn/tags/tag_doctype.asp) 的说明。\n\n   这个是第二个问题的答案。\n##### 三、`<!DOCTYPE>`约定浏览器使用哪种模式渲染页面\n\n  第二点是说怎么解析html文档，这个是说渲染页面，对的，渲染不仅仅是dom节点还包括css样式和javascript事件等等。\n\n  在标准未出来前html文档中没有使用`<!DOCTYPE>`标签，所以在现在有了标准后我们强烈建议要添加这个标签，不然开发的页面就跟十几年前一样了，那么浏览器为了兼容旧时代的网页而开启混杂模式。现代浏览器一般在有两种方式渲染页面。一种是混杂模式（主要是使用了上一代的盒模型，为了兼容旧时代的网页），一种是标准模式（目前主流的）。有关浏览器渲染模式可以查看[这里](https://hsivonen.fi/doctype/)。当你写的html页面因为没有声明`<!DOCTYPE>`标签，就会被混杂模式渲染，那么你css样式和javascript代码的执行都有可能会收到影响，这个问题就大了。\n\n现在直到了把，`<!DOCTYPE>`会告知浏览器应使用什么模式渲染页面。\n\n但是，我们到目前主流的网站，如： 豆瓣，新浪， 淘宝等看看页面发现他们的`<!DOCTYPE>`标签居然是这样声明的：\n\n``` html\n<!DOCTYPE html>\n```\n\n没有html版本也没有dtd链接等，这样也能正常运行？答案是：这个是第五代html版本的`<!DOCTYPE>`声明方式，也就是HTML 5的声明方式。够简洁把，而且还能够向后兼容。这也是一种很好方式，因为现在主流的浏览器都已经支持HTML 5了。\n##### 四：总结\n\n`<!DOCTYPE>`作用主要有两个：\n-  约定浏览器使用什么版本的html解析页面。\n- `约定浏览器使用哪种模式渲染页面。\n\n这是一个很重要的标签。\n","slug":"doctype-of-html","published":1,"updated":"2018-08-05T04:28:53.558Z","_id":"cjkgciq030024ue8itd3y3xzu","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在写html页面的时候我们一般都会在首行添加<code>〈!DOCTYPE〉</code>的标签，有些编辑器会自动帮我们添加，今天讲讲这个<code>〈!DOCTYPE〉</code>标签的作用。</p>\n<h5 id=\"一、HTML与XHTML\"><a href=\"#一、HTML与XHTML\" class=\"headerlink\" title=\"一、HTML与XHTML\"></a>一、HTML与XHTML</h5><p>在<code>W3C</code>组织还么颁发html标准之前，开发网页的时候大家都没有加这个标签，那个时候.html页面的开发也比较混乱，直到1999年的时候，HTML 4.01成为了推荐标准，那时候起大多数人都使用这个版本。又大概在2000年的时候，W3C组织又颁发了基于HTML4.01的XML版本，并命名为XHTML1.0。</p>\n<p>两者其实主要的差别是XHTML遵循了XML的编码标准，这意味着XHTML文档中增加了标签的属性必须包含在<code>&quot;&quot;</code>中，所有的标签必须闭合等比较严格的规定。这个也是有经验的开发人员经常提醒新手写.html页面的要注意的地方。好了，问题来了：</p>\n<ul>\n<li>前面我们提到在还没使用HTML 4.01作为推荐标准时，html文档是没有<code>〈!DOCTYPE〉</code>标签的，那么浏览器在面对一个.html文档时，如果有这个标签会怎么解析，没有这个文档会怎样解释。</li>\n<li>标准推出后有了两种版本（标准）来写.html文档，那么浏览器在解析html文档的时候应该使用哪种标准呢？</li>\n</ul>\n<p>这个时候<code>〈!DOCTYPE〉</code>标签就派上用场了。</p>\n<a id=\"more\"></a>\n<h5 id=\"二、〈-DOCTYPE〉约定浏览器使用什么版本的html\"><a href=\"#二、〈-DOCTYPE〉约定浏览器使用什么版本的html\" class=\"headerlink\" title=\"二、〈!DOCTYPE〉约定浏览器使用什么版本的html\"></a>二、<code>〈!DOCTYPE〉</code>约定浏览器使用什么版本的html</h5><p>   <code>&lt;!DOCTYPE&gt;</code> 声明html文档引用哪个<a href=\"http://www.w3school.com.cn/dtd/\" target=\"_blank\" rel=\"noopener\">DTD</a>， 和哪个html版本来解析html文档。学过xml的应该对这个比较了解了.而目前的<code>&lt;!DOCTYPE&gt;</code>也存在着三种风格： Strict (严格)、 Transitional（过渡）、 Frameset（框架集）。</p>\n<p>  这三种风格下有这不同的要求和规定，下面看下HTML 4.01版本的声明：</p>\n<ul>\n<li>HTML 4.01 Strict：</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\"&gt;</span></span><br></pre></td></tr></table></figure>\n<p>   该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。这个声明在我们开发中比较少用，因为它比较严格控制了html页面上不应该出现样式控制的属性。</p>\n<ul>\n<li>HTML 4.01 Transitional：</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"meta\">&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" </span></span><br><span class=\"line\"><span class=\"meta\">\"http://www.w3.org/TR/html4/loose.dtd\"&gt;</span></span><br></pre></td></tr></table></figure>\n<p>该 DTD 包含所有 HTML元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。这个是目前比较常用的声明。</p>\n<ul>\n<li>HTML 4.01 Frameset：</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"meta\">&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Frameset//EN\" </span></span><br><span class=\"line\"><span class=\"meta\">\"http://www.w3.org/TR/html4/frameset.dtd\"&gt;</span></span><br></pre></td></tr></table></figure>\n<p>该 DTD 等同于 HTML 4.01 Transitional，但允许框架集内容。</p>\n<p>同理，XHTML 1.0也有类似的三种风格的<code>&lt;!DOCTYPE&gt;</code>声明。具体的含义参见<a href=\"http://www.w3school.com.cn/tags/tag_doctype.asp\" target=\"_blank\" rel=\"noopener\">W3C关于此标签</a> 的说明。</p>\n<p>   这个是第二个问题的答案。</p>\n<h5 id=\"三、-lt-DOCTYPE-gt-约定浏览器使用哪种模式渲染页面\"><a href=\"#三、-lt-DOCTYPE-gt-约定浏览器使用哪种模式渲染页面\" class=\"headerlink\" title=\"三、&lt;!DOCTYPE&gt;约定浏览器使用哪种模式渲染页面\"></a>三、<code>&lt;!DOCTYPE&gt;</code>约定浏览器使用哪种模式渲染页面</h5><p>  第二点是说怎么解析html文档，这个是说渲染页面，对的，渲染不仅仅是dom节点还包括css样式和javascript事件等等。</p>\n<p>  在标准未出来前html文档中没有使用<code>&lt;!DOCTYPE&gt;</code>标签，所以在现在有了标准后我们强烈建议要添加这个标签，不然开发的页面就跟十几年前一样了，那么浏览器为了兼容旧时代的网页而开启混杂模式。现代浏览器一般在有两种方式渲染页面。一种是混杂模式（主要是使用了上一代的盒模型，为了兼容旧时代的网页），一种是标准模式（目前主流的）。有关浏览器渲染模式可以查看<a href=\"https://hsivonen.fi/doctype/\" target=\"_blank\" rel=\"noopener\">这里</a>。当你写的html页面因为没有声明<code>&lt;!DOCTYPE&gt;</code>标签，就会被混杂模式渲染，那么你css样式和javascript代码的执行都有可能会收到影响，这个问题就大了。</p>\n<p>现在直到了把，<code>&lt;!DOCTYPE&gt;</code>会告知浏览器应使用什么模式渲染页面。</p>\n<p>但是，我们到目前主流的网站，如： 豆瓣，新浪， 淘宝等看看页面发现他们的<code>&lt;!DOCTYPE&gt;</code>标签居然是这样声明的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br></pre></td></tr></table></figure>\n<p>没有html版本也没有dtd链接等，这样也能正常运行？答案是：这个是第五代html版本的<code>&lt;!DOCTYPE&gt;</code>声明方式，也就是HTML 5的声明方式。够简洁把，而且还能够向后兼容。这也是一种很好方式，因为现在主流的浏览器都已经支持HTML 5了。</p>\n<h5 id=\"四：总结\"><a href=\"#四：总结\" class=\"headerlink\" title=\"四：总结\"></a>四：总结</h5><p><code>&lt;!DOCTYPE&gt;</code>作用主要有两个：</p>\n<ul>\n<li>约定浏览器使用什么版本的html解析页面。</li>\n<li>`约定浏览器使用哪种模式渲染页面。</li>\n</ul>\n<p>这是一个很重要的标签。</p>\n","site":{"data":{}},"excerpt":"<p>在写html页面的时候我们一般都会在首行添加<code>〈!DOCTYPE〉</code>的标签，有些编辑器会自动帮我们添加，今天讲讲这个<code>〈!DOCTYPE〉</code>标签的作用。</p>\n<h5 id=\"一、HTML与XHTML\"><a href=\"#一、HTML与XHTML\" class=\"headerlink\" title=\"一、HTML与XHTML\"></a>一、HTML与XHTML</h5><p>在<code>W3C</code>组织还么颁发html标准之前，开发网页的时候大家都没有加这个标签，那个时候.html页面的开发也比较混乱，直到1999年的时候，HTML 4.01成为了推荐标准，那时候起大多数人都使用这个版本。又大概在2000年的时候，W3C组织又颁发了基于HTML4.01的XML版本，并命名为XHTML1.0。</p>\n<p>两者其实主要的差别是XHTML遵循了XML的编码标准，这意味着XHTML文档中增加了标签的属性必须包含在<code>&quot;&quot;</code>中，所有的标签必须闭合等比较严格的规定。这个也是有经验的开发人员经常提醒新手写.html页面的要注意的地方。好了，问题来了：</p>\n<ul>\n<li>前面我们提到在还没使用HTML 4.01作为推荐标准时，html文档是没有<code>〈!DOCTYPE〉</code>标签的，那么浏览器在面对一个.html文档时，如果有这个标签会怎么解析，没有这个文档会怎样解释。</li>\n<li>标准推出后有了两种版本（标准）来写.html文档，那么浏览器在解析html文档的时候应该使用哪种标准呢？</li>\n</ul>\n<p>这个时候<code>〈!DOCTYPE〉</code>标签就派上用场了。</p>","more":"<h5 id=\"二、〈-DOCTYPE〉约定浏览器使用什么版本的html\"><a href=\"#二、〈-DOCTYPE〉约定浏览器使用什么版本的html\" class=\"headerlink\" title=\"二、〈!DOCTYPE〉约定浏览器使用什么版本的html\"></a>二、<code>〈!DOCTYPE〉</code>约定浏览器使用什么版本的html</h5><p>   <code>&lt;!DOCTYPE&gt;</code> 声明html文档引用哪个<a href=\"http://www.w3school.com.cn/dtd/\" target=\"_blank\" rel=\"noopener\">DTD</a>， 和哪个html版本来解析html文档。学过xml的应该对这个比较了解了.而目前的<code>&lt;!DOCTYPE&gt;</code>也存在着三种风格： Strict (严格)、 Transitional（过渡）、 Frameset（框架集）。</p>\n<p>  这三种风格下有这不同的要求和规定，下面看下HTML 4.01版本的声明：</p>\n<ul>\n<li>HTML 4.01 Strict：</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\"&gt;</span></span><br></pre></td></tr></table></figure>\n<p>   该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。这个声明在我们开发中比较少用，因为它比较严格控制了html页面上不应该出现样式控制的属性。</p>\n<ul>\n<li>HTML 4.01 Transitional：</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"meta\">&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" </span></span><br><span class=\"line\"><span class=\"meta\">\"http://www.w3.org/TR/html4/loose.dtd\"&gt;</span></span><br></pre></td></tr></table></figure>\n<p>该 DTD 包含所有 HTML元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。这个是目前比较常用的声明。</p>\n<ul>\n<li>HTML 4.01 Frameset：</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"meta\">&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Frameset//EN\" </span></span><br><span class=\"line\"><span class=\"meta\">\"http://www.w3.org/TR/html4/frameset.dtd\"&gt;</span></span><br></pre></td></tr></table></figure>\n<p>该 DTD 等同于 HTML 4.01 Transitional，但允许框架集内容。</p>\n<p>同理，XHTML 1.0也有类似的三种风格的<code>&lt;!DOCTYPE&gt;</code>声明。具体的含义参见<a href=\"http://www.w3school.com.cn/tags/tag_doctype.asp\" target=\"_blank\" rel=\"noopener\">W3C关于此标签</a> 的说明。</p>\n<p>   这个是第二个问题的答案。</p>\n<h5 id=\"三、-lt-DOCTYPE-gt-约定浏览器使用哪种模式渲染页面\"><a href=\"#三、-lt-DOCTYPE-gt-约定浏览器使用哪种模式渲染页面\" class=\"headerlink\" title=\"三、&lt;!DOCTYPE&gt;约定浏览器使用哪种模式渲染页面\"></a>三、<code>&lt;!DOCTYPE&gt;</code>约定浏览器使用哪种模式渲染页面</h5><p>  第二点是说怎么解析html文档，这个是说渲染页面，对的，渲染不仅仅是dom节点还包括css样式和javascript事件等等。</p>\n<p>  在标准未出来前html文档中没有使用<code>&lt;!DOCTYPE&gt;</code>标签，所以在现在有了标准后我们强烈建议要添加这个标签，不然开发的页面就跟十几年前一样了，那么浏览器为了兼容旧时代的网页而开启混杂模式。现代浏览器一般在有两种方式渲染页面。一种是混杂模式（主要是使用了上一代的盒模型，为了兼容旧时代的网页），一种是标准模式（目前主流的）。有关浏览器渲染模式可以查看<a href=\"https://hsivonen.fi/doctype/\" target=\"_blank\" rel=\"noopener\">这里</a>。当你写的html页面因为没有声明<code>&lt;!DOCTYPE&gt;</code>标签，就会被混杂模式渲染，那么你css样式和javascript代码的执行都有可能会收到影响，这个问题就大了。</p>\n<p>现在直到了把，<code>&lt;!DOCTYPE&gt;</code>会告知浏览器应使用什么模式渲染页面。</p>\n<p>但是，我们到目前主流的网站，如： 豆瓣，新浪， 淘宝等看看页面发现他们的<code>&lt;!DOCTYPE&gt;</code>标签居然是这样声明的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br></pre></td></tr></table></figure>\n<p>没有html版本也没有dtd链接等，这样也能正常运行？答案是：这个是第五代html版本的<code>&lt;!DOCTYPE&gt;</code>声明方式，也就是HTML 5的声明方式。够简洁把，而且还能够向后兼容。这也是一种很好方式，因为现在主流的浏览器都已经支持HTML 5了。</p>\n<h5 id=\"四：总结\"><a href=\"#四：总结\" class=\"headerlink\" title=\"四：总结\"></a>四：总结</h5><p><code>&lt;!DOCTYPE&gt;</code>作用主要有两个：</p>\n<ul>\n<li>约定浏览器使用什么版本的html解析页面。</li>\n<li>`约定浏览器使用哪种模式渲染页面。</li>\n</ul>\n<p>这是一个很重要的标签。</p>"},{"title":"2013年终总结","date":"2014-01-30T14:03:29.000Z","_content":"\n趁着除夕的晚上把2013给总结下吧，其实2013还是对我来说还是蛮重要的一年。最近了看了几部电影，《蝴蝶效应》,《记忆碎片》和《About Time》都是有关于穿越到过去的题材。然后仔细想了想自己2013。\n\n假如我不参加什么航天班，就不会到目前这家公司实习，假如我不参加这个班的选拔，我也就不会参加这个航天班，假如我那个周末去了武汉就不会参加那天的面试，假如那天的火车票刚好因为有我要的那一班，那就不会不去武汉。想到这里，会不会说因为小小的火车票，决定了现在的我。突然有种好神奇的感觉还是说人生就是这样，每一个不经意的决定或许就决定了你后面一段很重要的经历,那么就总结下吧。\n\n从年初回到学校，因为大四了基本上就是课基本没了（学费还是得照缴），其实当时想想自己还是挺着急的，因为面临了毕业后干嘛的的问题。身边好多同学都有了目标，考研的，考公务员的，出国的，就业的，还有保研的，蹲寝室天天玩游戏的。貌似一看好像还挺多选择的，大概分析了发现自己压根就没有考虑过考研,考公务员,出国吧没资本，保研吧，大一挂过一科。好吧，瞬间就剩下了就业和玩游戏了。我不是富二代诶，不能游戏人生。所以就得就业了，所以还是得努力的学好技术，期望到时找个好工作了。\n\n开学没多久就碰到了目前实习的公司在学校的校企合作项目，当时宣传的很好，宣讲会的时候，完全被他们所开设的课程所吸引了，全是分布式系统，数据库，源码分析和云计算等高大上的课程。 当时第一感觉就是可以学到这么多东西应该是个很难得的机会，尽管是说要签三年就业协议的。所以就发生了第二段所描述的过程。\n\n其实在航天班的学习还是挺满意的，有些老师真的很不错。讲的课也很给力。一个很充满挑战的学期，我们一个学期学掉了12门课程。老师和同学们都很辛苦，但是大家熬过来了，考完后大家那种释怀的心情我还记得。恩，那是一个很高三的大四。在这个班里 ，认识了很多新同学，大家也都很优秀的。学期期末后，还全班去了北京一个星期，其实我五一的时候与女朋友去过了一次，也拿了班上的奖学金。这个学期也是大学最充实的学期了吧。\n\n暑假期间还学会了游泳，这个我觉得还蛮值得记忆的，谢谢肥肥。\n\n半年就这么结束了，紧接着就实习了，有了工位，有了新电脑，有了工卡，当然还有勉强能维持生活的工资。初入职场，其实也有蛮多困惑的，第一，觉得上个学期学的高大上的课程都没用上，觉得工作没挑战性，做的工作不够底层，太应用层，怕以后会被淘汰。这个我觉得是大部分初入职场的人都会遇到的困惑，工作的内容不是自己期待的那么有挑战性，其实不然，很感谢我的部长及时指导了我，部长告诉我：“底层和应用层无关贵贱厉害与否，两者都是在解决实际的问题，应当在解决工作中遇到的问题的过程中让自己成长起来，这种方式比单纯的去储备技术（我跟部长说我现在在自学一些比较底层的技术）却遇不到实际要解决的问题要有效的多”。  其实那次谈话对我来说有种被敲醒的感觉。想想的确是这样，我忽略了一个根本的问题，任何一门技术或者产品都是在有了需求才产生，我们只有在遇到实际了问题，在解决问题的过程中不断的去学习去进步。我把这个问题说出来希望以此解答那些跟我有相同困惑的人。技术没有高低贵贱之分，都是在解决实际的问题。其实在工作中还会遇到其他一些问题和困惑，这个时候要及时跟身边有经验的人多多交流，看看Nicholas C. Zakas这篇[博客](http://blog.jobbole.com/53812/)也能收到一些启发。\n还很收启发的一个观点是公司经理说的“要站在你领导的高度来思考问题”，其实这个要实践起来还蛮难的，不信你试试，以此共勉把。\n\n总体来说实习的过程还不错，ps：过年的实习的工资就不能提高点嘛，还让不让过年呀...\n\n说完了学习和工作，谈谈生活，2013上半年还是很不错的，实习开始后就身体不行，去过了好几次医院了，不过有一帮子同学在一起上下班还是挺开心的。很感谢那些给予我帮助和关心的人。新的一年开心要继续...还有下半年的感情生活也挺稳定的，很享受那种平淡的感觉，ps：今年过年不在家，哈哈...\n\n最后说说新年的几个愿望把。\n1. 我觉得我已经爱上了前端的工作，在14年我必须努力的把前端css，html和js三大技术深入学习，把对技术的学习更细致，更细节。当然升职加薪也很重要啦。 \n2. 过去的一年里我很高兴逐渐养成了阅读的习惯，读了大概15本把，我知道有点少，但是我希望在今年我读大概30-50本左右，还希望多涉猎一些不仅是技术方面的书籍。\n   推荐一个我的豆列：[2K13图书推荐](http://book.douban.com/doulist/3424571/)\n3. 觉得有电影的人生很美好，花几十块钱或者一两个小时的时间就可以体会到不同人的人生。过去的一年大概看了100多部电影把，希望今年能看100-200部电影。最好是部部都精彩。哈哈。\n   推荐一个我的豆列：[2k13电影推荐](http://movie.douban.com/doulist/3424641/)\n4. 学习一门新的泛型的语言，虽然语言只是工具，但是我还是很乐意去体会不同的语言带给我不同的惊奇，感觉被《七周七语言》的作者洗脑了。\n5. 每周坚持至少写一篇博客，这个其实比较难，但是我需要养成这样的习惯，督促自己总结。\n6. 锻炼身体，初步觉得考虑网球和羽毛球还有跑步。\n7. 去courseare学习一门公开课。\n8. 附加的愿望，看一场eason的演唱会。\n9. 没有9了。\n\n我没有能回到过去的超能力，所以不能去改变什么，ok, 再见我的2013，你好，2014。\n","source":"_posts/the-summery-of-2013.md","raw":"---\ntitle: 2013年终总结\ndate: 2014/1/30 22:03:29\ncategories:\n- Dream Big\ntags:\n- 年终终结\n---\n\n趁着除夕的晚上把2013给总结下吧，其实2013还是对我来说还是蛮重要的一年。最近了看了几部电影，《蝴蝶效应》,《记忆碎片》和《About Time》都是有关于穿越到过去的题材。然后仔细想了想自己2013。\n\n假如我不参加什么航天班，就不会到目前这家公司实习，假如我不参加这个班的选拔，我也就不会参加这个航天班，假如我那个周末去了武汉就不会参加那天的面试，假如那天的火车票刚好因为有我要的那一班，那就不会不去武汉。想到这里，会不会说因为小小的火车票，决定了现在的我。突然有种好神奇的感觉还是说人生就是这样，每一个不经意的决定或许就决定了你后面一段很重要的经历,那么就总结下吧。\n\n从年初回到学校，因为大四了基本上就是课基本没了（学费还是得照缴），其实当时想想自己还是挺着急的，因为面临了毕业后干嘛的的问题。身边好多同学都有了目标，考研的，考公务员的，出国的，就业的，还有保研的，蹲寝室天天玩游戏的。貌似一看好像还挺多选择的，大概分析了发现自己压根就没有考虑过考研,考公务员,出国吧没资本，保研吧，大一挂过一科。好吧，瞬间就剩下了就业和玩游戏了。我不是富二代诶，不能游戏人生。所以就得就业了，所以还是得努力的学好技术，期望到时找个好工作了。\n\n开学没多久就碰到了目前实习的公司在学校的校企合作项目，当时宣传的很好，宣讲会的时候，完全被他们所开设的课程所吸引了，全是分布式系统，数据库，源码分析和云计算等高大上的课程。 当时第一感觉就是可以学到这么多东西应该是个很难得的机会，尽管是说要签三年就业协议的。所以就发生了第二段所描述的过程。\n\n其实在航天班的学习还是挺满意的，有些老师真的很不错。讲的课也很给力。一个很充满挑战的学期，我们一个学期学掉了12门课程。老师和同学们都很辛苦，但是大家熬过来了，考完后大家那种释怀的心情我还记得。恩，那是一个很高三的大四。在这个班里 ，认识了很多新同学，大家也都很优秀的。学期期末后，还全班去了北京一个星期，其实我五一的时候与女朋友去过了一次，也拿了班上的奖学金。这个学期也是大学最充实的学期了吧。\n\n暑假期间还学会了游泳，这个我觉得还蛮值得记忆的，谢谢肥肥。\n\n半年就这么结束了，紧接着就实习了，有了工位，有了新电脑，有了工卡，当然还有勉强能维持生活的工资。初入职场，其实也有蛮多困惑的，第一，觉得上个学期学的高大上的课程都没用上，觉得工作没挑战性，做的工作不够底层，太应用层，怕以后会被淘汰。这个我觉得是大部分初入职场的人都会遇到的困惑，工作的内容不是自己期待的那么有挑战性，其实不然，很感谢我的部长及时指导了我，部长告诉我：“底层和应用层无关贵贱厉害与否，两者都是在解决实际的问题，应当在解决工作中遇到的问题的过程中让自己成长起来，这种方式比单纯的去储备技术（我跟部长说我现在在自学一些比较底层的技术）却遇不到实际要解决的问题要有效的多”。  其实那次谈话对我来说有种被敲醒的感觉。想想的确是这样，我忽略了一个根本的问题，任何一门技术或者产品都是在有了需求才产生，我们只有在遇到实际了问题，在解决问题的过程中不断的去学习去进步。我把这个问题说出来希望以此解答那些跟我有相同困惑的人。技术没有高低贵贱之分，都是在解决实际的问题。其实在工作中还会遇到其他一些问题和困惑，这个时候要及时跟身边有经验的人多多交流，看看Nicholas C. Zakas这篇[博客](http://blog.jobbole.com/53812/)也能收到一些启发。\n还很收启发的一个观点是公司经理说的“要站在你领导的高度来思考问题”，其实这个要实践起来还蛮难的，不信你试试，以此共勉把。\n\n总体来说实习的过程还不错，ps：过年的实习的工资就不能提高点嘛，还让不让过年呀...\n\n说完了学习和工作，谈谈生活，2013上半年还是很不错的，实习开始后就身体不行，去过了好几次医院了，不过有一帮子同学在一起上下班还是挺开心的。很感谢那些给予我帮助和关心的人。新的一年开心要继续...还有下半年的感情生活也挺稳定的，很享受那种平淡的感觉，ps：今年过年不在家，哈哈...\n\n最后说说新年的几个愿望把。\n1. 我觉得我已经爱上了前端的工作，在14年我必须努力的把前端css，html和js三大技术深入学习，把对技术的学习更细致，更细节。当然升职加薪也很重要啦。 \n2. 过去的一年里我很高兴逐渐养成了阅读的习惯，读了大概15本把，我知道有点少，但是我希望在今年我读大概30-50本左右，还希望多涉猎一些不仅是技术方面的书籍。\n   推荐一个我的豆列：[2K13图书推荐](http://book.douban.com/doulist/3424571/)\n3. 觉得有电影的人生很美好，花几十块钱或者一两个小时的时间就可以体会到不同人的人生。过去的一年大概看了100多部电影把，希望今年能看100-200部电影。最好是部部都精彩。哈哈。\n   推荐一个我的豆列：[2k13电影推荐](http://movie.douban.com/doulist/3424641/)\n4. 学习一门新的泛型的语言，虽然语言只是工具，但是我还是很乐意去体会不同的语言带给我不同的惊奇，感觉被《七周七语言》的作者洗脑了。\n5. 每周坚持至少写一篇博客，这个其实比较难，但是我需要养成这样的习惯，督促自己总结。\n6. 锻炼身体，初步觉得考虑网球和羽毛球还有跑步。\n7. 去courseare学习一门公开课。\n8. 附加的愿望，看一场eason的演唱会。\n9. 没有9了。\n\n我没有能回到过去的超能力，所以不能去改变什么，ok, 再见我的2013，你好，2014。\n","slug":"the-summery-of-2013","published":1,"updated":"2018-08-05T04:32:28.783Z","_id":"cjkgcl6tc002aue8il8cxr1vr","comments":1,"layout":"post","photos":[],"link":"","content":"<p>趁着除夕的晚上把2013给总结下吧，其实2013还是对我来说还是蛮重要的一年。最近了看了几部电影，《蝴蝶效应》,《记忆碎片》和《About Time》都是有关于穿越到过去的题材。然后仔细想了想自己2013。</p>\n<p>假如我不参加什么航天班，就不会到目前这家公司实习，假如我不参加这个班的选拔，我也就不会参加这个航天班，假如我那个周末去了武汉就不会参加那天的面试，假如那天的火车票刚好因为有我要的那一班，那就不会不去武汉。想到这里，会不会说因为小小的火车票，决定了现在的我。突然有种好神奇的感觉还是说人生就是这样，每一个不经意的决定或许就决定了你后面一段很重要的经历,那么就总结下吧。</p>\n<p>从年初回到学校，因为大四了基本上就是课基本没了（学费还是得照缴），其实当时想想自己还是挺着急的，因为面临了毕业后干嘛的的问题。身边好多同学都有了目标，考研的，考公务员的，出国的，就业的，还有保研的，蹲寝室天天玩游戏的。貌似一看好像还挺多选择的，大概分析了发现自己压根就没有考虑过考研,考公务员,出国吧没资本，保研吧，大一挂过一科。好吧，瞬间就剩下了就业和玩游戏了。我不是富二代诶，不能游戏人生。所以就得就业了，所以还是得努力的学好技术，期望到时找个好工作了。</p>\n<p>开学没多久就碰到了目前实习的公司在学校的校企合作项目，当时宣传的很好，宣讲会的时候，完全被他们所开设的课程所吸引了，全是分布式系统，数据库，源码分析和云计算等高大上的课程。 当时第一感觉就是可以学到这么多东西应该是个很难得的机会，尽管是说要签三年就业协议的。所以就发生了第二段所描述的过程。</p>\n<p>其实在航天班的学习还是挺满意的，有些老师真的很不错。讲的课也很给力。一个很充满挑战的学期，我们一个学期学掉了12门课程。老师和同学们都很辛苦，但是大家熬过来了，考完后大家那种释怀的心情我还记得。恩，那是一个很高三的大四。在这个班里 ，认识了很多新同学，大家也都很优秀的。学期期末后，还全班去了北京一个星期，其实我五一的时候与女朋友去过了一次，也拿了班上的奖学金。这个学期也是大学最充实的学期了吧。</p>\n<p>暑假期间还学会了游泳，这个我觉得还蛮值得记忆的，谢谢肥肥。</p>\n<p>半年就这么结束了，紧接着就实习了，有了工位，有了新电脑，有了工卡，当然还有勉强能维持生活的工资。初入职场，其实也有蛮多困惑的，第一，觉得上个学期学的高大上的课程都没用上，觉得工作没挑战性，做的工作不够底层，太应用层，怕以后会被淘汰。这个我觉得是大部分初入职场的人都会遇到的困惑，工作的内容不是自己期待的那么有挑战性，其实不然，很感谢我的部长及时指导了我，部长告诉我：“底层和应用层无关贵贱厉害与否，两者都是在解决实际的问题，应当在解决工作中遇到的问题的过程中让自己成长起来，这种方式比单纯的去储备技术（我跟部长说我现在在自学一些比较底层的技术）却遇不到实际要解决的问题要有效的多”。  其实那次谈话对我来说有种被敲醒的感觉。想想的确是这样，我忽略了一个根本的问题，任何一门技术或者产品都是在有了需求才产生，我们只有在遇到实际了问题，在解决问题的过程中不断的去学习去进步。我把这个问题说出来希望以此解答那些跟我有相同困惑的人。技术没有高低贵贱之分，都是在解决实际的问题。其实在工作中还会遇到其他一些问题和困惑，这个时候要及时跟身边有经验的人多多交流，看看Nicholas C. Zakas这篇<a href=\"http://blog.jobbole.com/53812/\" target=\"_blank\" rel=\"noopener\">博客</a>也能收到一些启发。<br>还很收启发的一个观点是公司经理说的“要站在你领导的高度来思考问题”，其实这个要实践起来还蛮难的，不信你试试，以此共勉把。</p>\n<p>总体来说实习的过程还不错，ps：过年的实习的工资就不能提高点嘛，还让不让过年呀…</p>\n<p>说完了学习和工作，谈谈生活，2013上半年还是很不错的，实习开始后就身体不行，去过了好几次医院了，不过有一帮子同学在一起上下班还是挺开心的。很感谢那些给予我帮助和关心的人。新的一年开心要继续…还有下半年的感情生活也挺稳定的，很享受那种平淡的感觉，ps：今年过年不在家，哈哈…</p>\n<p>最后说说新年的几个愿望把。</p>\n<ol>\n<li>我觉得我已经爱上了前端的工作，在14年我必须努力的把前端css，html和js三大技术深入学习，把对技术的学习更细致，更细节。当然升职加薪也很重要啦。 </li>\n<li>过去的一年里我很高兴逐渐养成了阅读的习惯，读了大概15本把，我知道有点少，但是我希望在今年我读大概30-50本左右，还希望多涉猎一些不仅是技术方面的书籍。<br>推荐一个我的豆列：<a href=\"http://book.douban.com/doulist/3424571/\" target=\"_blank\" rel=\"noopener\">2K13图书推荐</a></li>\n<li>觉得有电影的人生很美好，花几十块钱或者一两个小时的时间就可以体会到不同人的人生。过去的一年大概看了100多部电影把，希望今年能看100-200部电影。最好是部部都精彩。哈哈。<br>推荐一个我的豆列：<a href=\"http://movie.douban.com/doulist/3424641/\" target=\"_blank\" rel=\"noopener\">2k13电影推荐</a></li>\n<li>学习一门新的泛型的语言，虽然语言只是工具，但是我还是很乐意去体会不同的语言带给我不同的惊奇，感觉被《七周七语言》的作者洗脑了。</li>\n<li>每周坚持至少写一篇博客，这个其实比较难，但是我需要养成这样的习惯，督促自己总结。</li>\n<li>锻炼身体，初步觉得考虑网球和羽毛球还有跑步。</li>\n<li>去courseare学习一门公开课。</li>\n<li>附加的愿望，看一场eason的演唱会。</li>\n<li>没有9了。</li>\n</ol>\n<p>我没有能回到过去的超能力，所以不能去改变什么，ok, 再见我的2013，你好，2014。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>趁着除夕的晚上把2013给总结下吧，其实2013还是对我来说还是蛮重要的一年。最近了看了几部电影，《蝴蝶效应》,《记忆碎片》和《About Time》都是有关于穿越到过去的题材。然后仔细想了想自己2013。</p>\n<p>假如我不参加什么航天班，就不会到目前这家公司实习，假如我不参加这个班的选拔，我也就不会参加这个航天班，假如我那个周末去了武汉就不会参加那天的面试，假如那天的火车票刚好因为有我要的那一班，那就不会不去武汉。想到这里，会不会说因为小小的火车票，决定了现在的我。突然有种好神奇的感觉还是说人生就是这样，每一个不经意的决定或许就决定了你后面一段很重要的经历,那么就总结下吧。</p>\n<p>从年初回到学校，因为大四了基本上就是课基本没了（学费还是得照缴），其实当时想想自己还是挺着急的，因为面临了毕业后干嘛的的问题。身边好多同学都有了目标，考研的，考公务员的，出国的，就业的，还有保研的，蹲寝室天天玩游戏的。貌似一看好像还挺多选择的，大概分析了发现自己压根就没有考虑过考研,考公务员,出国吧没资本，保研吧，大一挂过一科。好吧，瞬间就剩下了就业和玩游戏了。我不是富二代诶，不能游戏人生。所以就得就业了，所以还是得努力的学好技术，期望到时找个好工作了。</p>\n<p>开学没多久就碰到了目前实习的公司在学校的校企合作项目，当时宣传的很好，宣讲会的时候，完全被他们所开设的课程所吸引了，全是分布式系统，数据库，源码分析和云计算等高大上的课程。 当时第一感觉就是可以学到这么多东西应该是个很难得的机会，尽管是说要签三年就业协议的。所以就发生了第二段所描述的过程。</p>\n<p>其实在航天班的学习还是挺满意的，有些老师真的很不错。讲的课也很给力。一个很充满挑战的学期，我们一个学期学掉了12门课程。老师和同学们都很辛苦，但是大家熬过来了，考完后大家那种释怀的心情我还记得。恩，那是一个很高三的大四。在这个班里 ，认识了很多新同学，大家也都很优秀的。学期期末后，还全班去了北京一个星期，其实我五一的时候与女朋友去过了一次，也拿了班上的奖学金。这个学期也是大学最充实的学期了吧。</p>\n<p>暑假期间还学会了游泳，这个我觉得还蛮值得记忆的，谢谢肥肥。</p>\n<p>半年就这么结束了，紧接着就实习了，有了工位，有了新电脑，有了工卡，当然还有勉强能维持生活的工资。初入职场，其实也有蛮多困惑的，第一，觉得上个学期学的高大上的课程都没用上，觉得工作没挑战性，做的工作不够底层，太应用层，怕以后会被淘汰。这个我觉得是大部分初入职场的人都会遇到的困惑，工作的内容不是自己期待的那么有挑战性，其实不然，很感谢我的部长及时指导了我，部长告诉我：“底层和应用层无关贵贱厉害与否，两者都是在解决实际的问题，应当在解决工作中遇到的问题的过程中让自己成长起来，这种方式比单纯的去储备技术（我跟部长说我现在在自学一些比较底层的技术）却遇不到实际要解决的问题要有效的多”。  其实那次谈话对我来说有种被敲醒的感觉。想想的确是这样，我忽略了一个根本的问题，任何一门技术或者产品都是在有了需求才产生，我们只有在遇到实际了问题，在解决问题的过程中不断的去学习去进步。我把这个问题说出来希望以此解答那些跟我有相同困惑的人。技术没有高低贵贱之分，都是在解决实际的问题。其实在工作中还会遇到其他一些问题和困惑，这个时候要及时跟身边有经验的人多多交流，看看Nicholas C. Zakas这篇<a href=\"http://blog.jobbole.com/53812/\" target=\"_blank\" rel=\"noopener\">博客</a>也能收到一些启发。<br>还很收启发的一个观点是公司经理说的“要站在你领导的高度来思考问题”，其实这个要实践起来还蛮难的，不信你试试，以此共勉把。</p>\n<p>总体来说实习的过程还不错，ps：过年的实习的工资就不能提高点嘛，还让不让过年呀…</p>\n<p>说完了学习和工作，谈谈生活，2013上半年还是很不错的，实习开始后就身体不行，去过了好几次医院了，不过有一帮子同学在一起上下班还是挺开心的。很感谢那些给予我帮助和关心的人。新的一年开心要继续…还有下半年的感情生活也挺稳定的，很享受那种平淡的感觉，ps：今年过年不在家，哈哈…</p>\n<p>最后说说新年的几个愿望把。</p>\n<ol>\n<li>我觉得我已经爱上了前端的工作，在14年我必须努力的把前端css，html和js三大技术深入学习，把对技术的学习更细致，更细节。当然升职加薪也很重要啦。 </li>\n<li>过去的一年里我很高兴逐渐养成了阅读的习惯，读了大概15本把，我知道有点少，但是我希望在今年我读大概30-50本左右，还希望多涉猎一些不仅是技术方面的书籍。<br>推荐一个我的豆列：<a href=\"http://book.douban.com/doulist/3424571/\" target=\"_blank\" rel=\"noopener\">2K13图书推荐</a></li>\n<li>觉得有电影的人生很美好，花几十块钱或者一两个小时的时间就可以体会到不同人的人生。过去的一年大概看了100多部电影把，希望今年能看100-200部电影。最好是部部都精彩。哈哈。<br>推荐一个我的豆列：<a href=\"http://movie.douban.com/doulist/3424641/\" target=\"_blank\" rel=\"noopener\">2k13电影推荐</a></li>\n<li>学习一门新的泛型的语言，虽然语言只是工具，但是我还是很乐意去体会不同的语言带给我不同的惊奇，感觉被《七周七语言》的作者洗脑了。</li>\n<li>每周坚持至少写一篇博客，这个其实比较难，但是我需要养成这样的习惯，督促自己总结。</li>\n<li>锻炼身体，初步觉得考虑网球和羽毛球还有跑步。</li>\n<li>去courseare学习一门公开课。</li>\n<li>附加的愿望，看一场eason的演唱会。</li>\n<li>没有9了。</li>\n</ol>\n<p>我没有能回到过去的超能力，所以不能去改变什么，ok, 再见我的2013，你好，2014。</p>\n"},{"title":"Javascript 中的正则","date":"2014-08-15T09:47:30.000Z","_content":"\n## 一、RegExp对象\n\n构造正则表达式：\n\n``` javascript\n//方式1：\nvar re = /\\w+/;   //最常用的方式\n\n//方式2：\nvar re = new RegExp(\"\\\\w+\");  //注意转义\n```\n### 1. reg.test(str)\n\n描述：test() 方法执行一个检索，用来查看正则表达式与指定的字符串是否匹配。返回 true 或 false。\n\n``` javascript\nfunction testinput(re, str){\n    var midstring;\n    if (re.test(str)) {\n        midstring = \" contains \";\n    } else {\n        midstring = \" does not contain \";\n    }\n    console.log(str + midstring + re.source);\n}\n\ntestinput(/c{2}/, 'cainiao'); \n//\"cainiao does not contain c{2}\"\n```\n- reference: [MDN参考](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test)\n\n<!-- more -->\n### 2. reg.exec(str)方法\n- exec() 方法为指定的一段字符串执行搜索匹配操作。它的返回值是一个数组或者 null。\n\n``` javascript\nvar re = /d(b+)(d)/ig;\nvar result = re.exec(\"cdbBdbsbz\");\nconsole.log(result); \n//[\"dbBd\", \"bB\", \"d\", index: 1, input: \"cdbBdbsbz\"] \n```\n- 返回的数据：\n\n<table class=\"fullwidth-table\">\n <tbody>\n  <tr>\n   <td class=\"header\">对象</td>\n   <td class=\"header\">属性/索引</td>\n   <td class=\"header\">描述</td>\n   <td class=\"header\">例子</td>\n  </tr>\n  <tr>\n   <td rowspan=\"4\"><code>result</code></td>\n   <td><code>[0]</code></td>\n   <td>正则表达式最后的匹配项</td>\n   <td><code>dbBd</code></td>\n  </tr>\n  <tr>\n   <td><code>[1], ...[\n    <i>\n     n</i>\n    ]</code></td>\n   <td>子表达式匹配项</td>\n   <td><code>[1] = bB<br>\n    [2] = d</code></td>\n  </tr>\n  <tr>\n   <td><code>index</code></td>\n   <td>第一个匹配项在原字符串中的索引</td>\n   <td><code>1</code></td>\n  </tr>\n  <tr>\n   <td><code>input</code></td>\n   <td>方法输入的参数字符串</td>\n   <td><code>cdbBdbsbz</code></td>\n  </tr>\n  <tr>\n   <td rowspan=\"5\"><code>re</code></td>\n   <td><code>lastIndex</code></td>\n   <td>下一次执行匹配开始索引的位置.</td>\n   <td><code>5</code></td>\n  </tr>\n  <tr>\n   <td><code>ignoreCase</code></td>\n   <td>指\"<code>i</code>\" 标识是否启用</td>\n   <td><code>true</code></td>\n  </tr>\n  <tr>\n   <td><code>global</code></td>\n   <td>指\"<code>g</code>\" 标识是否启用</td>\n   <td><code>true</code></td>\n  </tr>\n  <tr>\n   <td><code>multiline</code></td>\n   <td>指\"<code>m</code>\" 标识是否启用</td>\n   <td><code>false</code></td>\n  </tr>\n  <tr>\n   <td><code>source</code></td>\n   <td>正则表达式的文本表示</td>\n   <td><code>d(b+)(d)</code></td>\n  </tr>\n </tbody>\n</table>\n- reference：[MDN参考](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec)\n## 二、String对象\n### 1. str.search(reg) vs reg.test(str)\n\n*描述：search() 方法执行一个查找，看该字符串对象与一个正则表达式是否匹配。参数reg为一个正则表达式对象，否则隐式调用new RegExp(reg)进行转换。\n如果匹配成功，则 search 返回正则表达式在字符串中首次匹配项的索引。否则，返回 -1。\n\n``` javascript\nfunction testinput(re, str){\n  var midstring;\n  if (str.search(re) != -1){\n    midstring = \" contains \";\n  } else {\n    midstring = \" does not contain \";\n  }\n  console.log (str + midstring + re);\n}\ntestinput(/db*/, 'sdbbdee'); //sdbbdee contains /db*/ \n```\n\n＊reference: [MDN参考](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/search)\n### 2. str.match(reg)  vs  reg.exec(str)\n- 描述：当字符串匹配到正则表达式（regular expression）时，match() 方法会提取匹配项。reg参数为一个正则对象，若不是，则隐式地调用new RegExp(reg) 进行转换。返回数组，不匹配返回null。\n\n``` javascript\nvar str = \"For more information, see Chapter 3.4.5.1\";\nvar re = /(chapter \\d+(\\.\\d)*)/i;  //不是用g的情况\nvar found = str.match(re);\nconsole.log(found);\n//[\"Chapter 3.4.5.1\", \"Chapter 3.4.5.1\", \".1\", index: 26, input: \"For more information, see Chapter 3.4.5.1\"] \n```\n\n``` javascript\nvar str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\nvar regexp = /[A-E]/gi;  //使用g时，found不存在index和input属性\nvar found = str.match(regexp);\n//['A', 'B', 'C', 'D', 'E', 'a', 'b', 'c', 'd', 'e']\n```\n\n*reference：[MDN参考](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match)\n### 3. str.replace(regexp|substr, newSubStr|function[,  flags])\n- 描述：replace() 方法使用一个替换值（replacement）替换掉一个匹配模式（pattern）在原字符串中某些或所有的匹配项，并返回替换后的字符串。这个替换模式可以是字符串或者正则表达式，替换值可以是一个字符串或者一个函数。\n- 参数\n  regexp：\n  一个 RegExp 对象。该正则所匹配的内容会被第二个参数的返回值替换掉。\n  substr：\n  一个要被 newSubStr 替换的字符串。\n  newSubStr：\n  替换掉第一个参数在原字符串中的匹配部分。该字符串中可以内插一些特殊的变量名。\n  function：\n  一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果。该函数的参数描述请参考 Specifying a function as a parameter 小节。.\n  flags：\n  注意：flags 参数在 v8 内核（Chrome and NodeJs）中不起作用。一个字符串，用来指定 regular expression flags 或其组合。在 String.replace method 中使用 flags 参数不是符合标准。使用一个带有相应标志（flags）的正则表达式（RegExp）对象来代替此参数。该参数的值应该是下面的一个或多个字符，具体作用见下：\n  g   全局替换\n  i   忽略大小写\n  m   多行模式\n- 返回：\n   一个新字符串，其中匹配模式的某些或所有匹配项被替换为替换值。该方法并不改变调用它的字符串本身,而只是返回替换后的字符串.\n\n``` javascript\nvar re = /apples/gi;\nvar str = \"Apples are round, and apples are juicy.\";\nvar newstr = str.replace(re, \"oranges\");\nprint(newstr);\n//\"oranges are round, and oranges are juicy.\"\n```\n\n等同于：\n\n``` javascript\nvar str = \"Apples are round, and apples are juicy.\";\nvar newstr = str.replace(\"apples\", \"oranges\", \"gi\");\nprint(newstr);\n//\"oranges are round, and oranges are juicy.\"\n```\n\n``` javascript\nvar re = /(\\w+)\\s(\\w+)/;\nvar str = \"John Smith\";\nvar newstr = str.replace(re, \"$2, $1\");\nprint(newstr); //'Smith John'\n```\n- reference: [MDN参考](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_string_as_a_parameter)\n### 4. str.split(seperator, limit)\n- 描述：用来分割字符串的字符（串）。separator 可以是一个字符串或正则表达式。 如果忽略 separator，则返回的数组包含一个由原字符串组成的元素。如果 separator 是一个空字符串，则 str 将会转换成一个由原字符串中字符组成的数组。 limit一个整数，限定返回的分割片段数量。split 方法仍然分割每一个匹配的 separator，但是返回的数组只会截取最多 limit 个元素。\n\n＊注： 如果 separator 是一个正则表达式，且包含捕获括号（capturing parentheses），则每次匹配到 separator 时，捕获括号匹配的结果将会插入到返回的数组中。然而，不是所有浏览器都支持该特性。　\n\n``` javascript\nvar myString = \"Hello 1 word. Sentence number 2.\";\nvar splits = myString.split(/(\\d)/);\nconsole.log(splits);\n//[\"Hello \", \"1\", \" word. Sentence number \", \"2\", \".\"]\n```\n- reference: [MDN参考](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split)\n","source":"_posts/regex-of-javascript.md","raw":"---\ntitle: Javascript 中的正则\ndate: 2014/8/15 17:47:30\ncategories:\n- Shit Done\ntags:\n- Javascript \n- 正则表达式\n---\n\n## 一、RegExp对象\n\n构造正则表达式：\n\n``` javascript\n//方式1：\nvar re = /\\w+/;   //最常用的方式\n\n//方式2：\nvar re = new RegExp(\"\\\\w+\");  //注意转义\n```\n### 1. reg.test(str)\n\n描述：test() 方法执行一个检索，用来查看正则表达式与指定的字符串是否匹配。返回 true 或 false。\n\n``` javascript\nfunction testinput(re, str){\n    var midstring;\n    if (re.test(str)) {\n        midstring = \" contains \";\n    } else {\n        midstring = \" does not contain \";\n    }\n    console.log(str + midstring + re.source);\n}\n\ntestinput(/c{2}/, 'cainiao'); \n//\"cainiao does not contain c{2}\"\n```\n- reference: [MDN参考](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test)\n\n<!-- more -->\n### 2. reg.exec(str)方法\n- exec() 方法为指定的一段字符串执行搜索匹配操作。它的返回值是一个数组或者 null。\n\n``` javascript\nvar re = /d(b+)(d)/ig;\nvar result = re.exec(\"cdbBdbsbz\");\nconsole.log(result); \n//[\"dbBd\", \"bB\", \"d\", index: 1, input: \"cdbBdbsbz\"] \n```\n- 返回的数据：\n\n<table class=\"fullwidth-table\">\n <tbody>\n  <tr>\n   <td class=\"header\">对象</td>\n   <td class=\"header\">属性/索引</td>\n   <td class=\"header\">描述</td>\n   <td class=\"header\">例子</td>\n  </tr>\n  <tr>\n   <td rowspan=\"4\"><code>result</code></td>\n   <td><code>[0]</code></td>\n   <td>正则表达式最后的匹配项</td>\n   <td><code>dbBd</code></td>\n  </tr>\n  <tr>\n   <td><code>[1], ...[\n    <i>\n     n</i>\n    ]</code></td>\n   <td>子表达式匹配项</td>\n   <td><code>[1] = bB<br>\n    [2] = d</code></td>\n  </tr>\n  <tr>\n   <td><code>index</code></td>\n   <td>第一个匹配项在原字符串中的索引</td>\n   <td><code>1</code></td>\n  </tr>\n  <tr>\n   <td><code>input</code></td>\n   <td>方法输入的参数字符串</td>\n   <td><code>cdbBdbsbz</code></td>\n  </tr>\n  <tr>\n   <td rowspan=\"5\"><code>re</code></td>\n   <td><code>lastIndex</code></td>\n   <td>下一次执行匹配开始索引的位置.</td>\n   <td><code>5</code></td>\n  </tr>\n  <tr>\n   <td><code>ignoreCase</code></td>\n   <td>指\"<code>i</code>\" 标识是否启用</td>\n   <td><code>true</code></td>\n  </tr>\n  <tr>\n   <td><code>global</code></td>\n   <td>指\"<code>g</code>\" 标识是否启用</td>\n   <td><code>true</code></td>\n  </tr>\n  <tr>\n   <td><code>multiline</code></td>\n   <td>指\"<code>m</code>\" 标识是否启用</td>\n   <td><code>false</code></td>\n  </tr>\n  <tr>\n   <td><code>source</code></td>\n   <td>正则表达式的文本表示</td>\n   <td><code>d(b+)(d)</code></td>\n  </tr>\n </tbody>\n</table>\n- reference：[MDN参考](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec)\n## 二、String对象\n### 1. str.search(reg) vs reg.test(str)\n\n*描述：search() 方法执行一个查找，看该字符串对象与一个正则表达式是否匹配。参数reg为一个正则表达式对象，否则隐式调用new RegExp(reg)进行转换。\n如果匹配成功，则 search 返回正则表达式在字符串中首次匹配项的索引。否则，返回 -1。\n\n``` javascript\nfunction testinput(re, str){\n  var midstring;\n  if (str.search(re) != -1){\n    midstring = \" contains \";\n  } else {\n    midstring = \" does not contain \";\n  }\n  console.log (str + midstring + re);\n}\ntestinput(/db*/, 'sdbbdee'); //sdbbdee contains /db*/ \n```\n\n＊reference: [MDN参考](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/search)\n### 2. str.match(reg)  vs  reg.exec(str)\n- 描述：当字符串匹配到正则表达式（regular expression）时，match() 方法会提取匹配项。reg参数为一个正则对象，若不是，则隐式地调用new RegExp(reg) 进行转换。返回数组，不匹配返回null。\n\n``` javascript\nvar str = \"For more information, see Chapter 3.4.5.1\";\nvar re = /(chapter \\d+(\\.\\d)*)/i;  //不是用g的情况\nvar found = str.match(re);\nconsole.log(found);\n//[\"Chapter 3.4.5.1\", \"Chapter 3.4.5.1\", \".1\", index: 26, input: \"For more information, see Chapter 3.4.5.1\"] \n```\n\n``` javascript\nvar str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\nvar regexp = /[A-E]/gi;  //使用g时，found不存在index和input属性\nvar found = str.match(regexp);\n//['A', 'B', 'C', 'D', 'E', 'a', 'b', 'c', 'd', 'e']\n```\n\n*reference：[MDN参考](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match)\n### 3. str.replace(regexp|substr, newSubStr|function[,  flags])\n- 描述：replace() 方法使用一个替换值（replacement）替换掉一个匹配模式（pattern）在原字符串中某些或所有的匹配项，并返回替换后的字符串。这个替换模式可以是字符串或者正则表达式，替换值可以是一个字符串或者一个函数。\n- 参数\n  regexp：\n  一个 RegExp 对象。该正则所匹配的内容会被第二个参数的返回值替换掉。\n  substr：\n  一个要被 newSubStr 替换的字符串。\n  newSubStr：\n  替换掉第一个参数在原字符串中的匹配部分。该字符串中可以内插一些特殊的变量名。\n  function：\n  一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果。该函数的参数描述请参考 Specifying a function as a parameter 小节。.\n  flags：\n  注意：flags 参数在 v8 内核（Chrome and NodeJs）中不起作用。一个字符串，用来指定 regular expression flags 或其组合。在 String.replace method 中使用 flags 参数不是符合标准。使用一个带有相应标志（flags）的正则表达式（RegExp）对象来代替此参数。该参数的值应该是下面的一个或多个字符，具体作用见下：\n  g   全局替换\n  i   忽略大小写\n  m   多行模式\n- 返回：\n   一个新字符串，其中匹配模式的某些或所有匹配项被替换为替换值。该方法并不改变调用它的字符串本身,而只是返回替换后的字符串.\n\n``` javascript\nvar re = /apples/gi;\nvar str = \"Apples are round, and apples are juicy.\";\nvar newstr = str.replace(re, \"oranges\");\nprint(newstr);\n//\"oranges are round, and oranges are juicy.\"\n```\n\n等同于：\n\n``` javascript\nvar str = \"Apples are round, and apples are juicy.\";\nvar newstr = str.replace(\"apples\", \"oranges\", \"gi\");\nprint(newstr);\n//\"oranges are round, and oranges are juicy.\"\n```\n\n``` javascript\nvar re = /(\\w+)\\s(\\w+)/;\nvar str = \"John Smith\";\nvar newstr = str.replace(re, \"$2, $1\");\nprint(newstr); //'Smith John'\n```\n- reference: [MDN参考](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_string_as_a_parameter)\n### 4. str.split(seperator, limit)\n- 描述：用来分割字符串的字符（串）。separator 可以是一个字符串或正则表达式。 如果忽略 separator，则返回的数组包含一个由原字符串组成的元素。如果 separator 是一个空字符串，则 str 将会转换成一个由原字符串中字符组成的数组。 limit一个整数，限定返回的分割片段数量。split 方法仍然分割每一个匹配的 separator，但是返回的数组只会截取最多 limit 个元素。\n\n＊注： 如果 separator 是一个正则表达式，且包含捕获括号（capturing parentheses），则每次匹配到 separator 时，捕获括号匹配的结果将会插入到返回的数组中。然而，不是所有浏览器都支持该特性。　\n\n``` javascript\nvar myString = \"Hello 1 word. Sentence number 2.\";\nvar splits = myString.split(/(\\d)/);\nconsole.log(splits);\n//[\"Hello \", \"1\", \" word. Sentence number \", \"2\", \".\"]\n```\n- reference: [MDN参考](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split)\n","slug":"regex-of-javascript","published":1,"updated":"2018-08-05T04:33:56.356Z","_id":"cjkgcpvhi002hue8i3x3fq29v","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"一、RegExp对象\"><a href=\"#一、RegExp对象\" class=\"headerlink\" title=\"一、RegExp对象\"></a>一、RegExp对象</h2><p>构造正则表达式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方式1：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> re = <span class=\"regexp\">/\\w+/</span>;   <span class=\"comment\">//最常用的方式</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//方式2：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> re = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"\\\\w+\"</span>);  <span class=\"comment\">//注意转义</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1-reg-test-str\"><a href=\"#1-reg-test-str\" class=\"headerlink\" title=\"1. reg.test(str)\"></a>1. reg.test(str)</h3><p>描述：test() 方法执行一个检索，用来查看正则表达式与指定的字符串是否匹配。返回 true 或 false。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">testinput</span>(<span class=\"params\">re, str</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> midstring;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (re.test(str)) &#123;</span><br><span class=\"line\">        midstring = <span class=\"string\">\" contains \"</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        midstring = <span class=\"string\">\" does not contain \"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(str + midstring + re.source);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">testinput(<span class=\"regexp\">/c&#123;2&#125;/</span>, <span class=\"string\">'cainiao'</span>); </span><br><span class=\"line\"><span class=\"comment\">//\"cainiao does not contain c&#123;2&#125;\"</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>reference: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test\" target=\"_blank\" rel=\"noopener\">MDN参考</a></li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"2-reg-exec-str-方法\"><a href=\"#2-reg-exec-str-方法\" class=\"headerlink\" title=\"2. reg.exec(str)方法\"></a>2. reg.exec(str)方法</h3><ul>\n<li>exec() 方法为指定的一段字符串执行搜索匹配操作。它的返回值是一个数组或者 null。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> re = <span class=\"regexp\">/d(b+)(d)/ig</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = re.exec(<span class=\"string\">\"cdbBdbsbz\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); </span><br><span class=\"line\"><span class=\"comment\">//[\"dbBd\", \"bB\", \"d\", index: 1, input: \"cdbBdbsbz\"]</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回的数据：</li>\n</ul>\n<p><table class=\"fullwidth-table\"><br> <tbody><br>  <tr><br>   <td class=\"header\">对象</td><br>   <td class=\"header\">属性/索引</td><br>   <td class=\"header\">描述</td><br>   <td class=\"header\">例子</td><br>  </tr><br>  <tr><br>   <td rowspan=\"4\"><code>result</code></td><br>   <td><code>[0]</code></td><br>   <td>正则表达式最后的匹配项</td><br>   <td><code>dbBd</code></td><br>  </tr><br>  <tr><br>   <td><code>[1], …[<br>    <i><br>     n</i><br>    ]</code></td><br>   <td>子表达式匹配项</td><br>   <td><code>[1] = bB<br><br>    [2] = d</code></td><br>  </tr><br>  <tr><br>   <td><code>index</code></td><br>   <td>第一个匹配项在原字符串中的索引</td><br>   <td><code>1</code></td><br>  </tr><br>  <tr><br>   <td><code>input</code></td><br>   <td>方法输入的参数字符串</td><br>   <td><code>cdbBdbsbz</code></td><br>  </tr><br>  <tr><br>   <td rowspan=\"5\"><code>re</code></td><br>   <td><code>lastIndex</code></td><br>   <td>下一次执行匹配开始索引的位置.</td><br>   <td><code>5</code></td><br>  </tr><br>  <tr><br>   <td><code>ignoreCase</code></td><br>   <td>指”<code>i</code>“ 标识是否启用</td><br>   <td><code>true</code></td><br>  </tr><br>  <tr><br>   <td><code>global</code></td><br>   <td>指”<code>g</code>“ 标识是否启用</td><br>   <td><code>true</code></td><br>  </tr><br>  <tr><br>   <td><code>multiline</code></td><br>   <td>指”<code>m</code>“ 标识是否启用</td><br>   <td><code>false</code></td><br>  </tr><br>  <tr><br>   <td><code>source</code></td><br>   <td>正则表达式的文本表示</td><br>   <td><code>d(b+)(d)</code></td><br>  </tr><br> </tbody><br></table></p>\n<ul>\n<li>reference：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec\" target=\"_blank\" rel=\"noopener\">MDN参考</a><h2 id=\"二、String对象\"><a href=\"#二、String对象\" class=\"headerlink\" title=\"二、String对象\"></a>二、String对象</h2><h3 id=\"1-str-search-reg-vs-reg-test-str\"><a href=\"#1-str-search-reg-vs-reg-test-str\" class=\"headerlink\" title=\"1. str.search(reg) vs reg.test(str)\"></a>1. str.search(reg) vs reg.test(str)</h3></li>\n</ul>\n<p>*描述：search() 方法执行一个查找，看该字符串对象与一个正则表达式是否匹配。参数reg为一个正则表达式对象，否则隐式调用new RegExp(reg)进行转换。<br>如果匹配成功，则 search 返回正则表达式在字符串中首次匹配项的索引。否则，返回 -1。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">testinput</span>(<span class=\"params\">re, str</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> midstring;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (str.search(re) != <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">    midstring = <span class=\"string\">\" contains \"</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    midstring = <span class=\"string\">\" does not contain \"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log (str + midstring + re);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">testinput(<span class=\"regexp\">/db*/</span>, <span class=\"string\">'sdbbdee'</span>); <span class=\"comment\">//sdbbdee contains /db*/</span></span><br></pre></td></tr></table></figure>\n<p>＊reference: <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/search\" target=\"_blank\" rel=\"noopener\">MDN参考</a></p>\n<h3 id=\"2-str-match-reg-vs-reg-exec-str\"><a href=\"#2-str-match-reg-vs-reg-exec-str\" class=\"headerlink\" title=\"2. str.match(reg)  vs  reg.exec(str)\"></a>2. str.match(reg)  vs  reg.exec(str)</h3><ul>\n<li>描述：当字符串匹配到正则表达式（regular expression）时，match() 方法会提取匹配项。reg参数为一个正则对象，若不是，则隐式地调用new RegExp(reg) 进行转换。返回数组，不匹配返回null。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"For more information, see Chapter 3.4.5.1\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> re = <span class=\"regexp\">/(chapter \\d+(\\.\\d)*)/i</span>;  <span class=\"comment\">//不是用g的情况</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> found = str.match(re);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(found);</span><br><span class=\"line\"><span class=\"comment\">//[\"Chapter 3.4.5.1\", \"Chapter 3.4.5.1\", \".1\", index: 26, input: \"For more information, see Chapter 3.4.5.1\"]</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> regexp = <span class=\"regexp\">/[A-E]/gi</span>;  <span class=\"comment\">//使用g时，found不存在index和input属性</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> found = str.match(regexp);</span><br><span class=\"line\"><span class=\"comment\">//['A', 'B', 'C', 'D', 'E', 'a', 'b', 'c', 'd', 'e']</span></span><br></pre></td></tr></table></figure>\n<p>*reference：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match\" target=\"_blank\" rel=\"noopener\">MDN参考</a></p>\n<h3 id=\"3-str-replace-regexp-substr-newSubStr-function-flags\"><a href=\"#3-str-replace-regexp-substr-newSubStr-function-flags\" class=\"headerlink\" title=\"3. str.replace(regexp|substr, newSubStr|function[,  flags])\"></a>3. str.replace(regexp|substr, newSubStr|function[,  flags])</h3><ul>\n<li>描述：replace() 方法使用一个替换值（replacement）替换掉一个匹配模式（pattern）在原字符串中某些或所有的匹配项，并返回替换后的字符串。这个替换模式可以是字符串或者正则表达式，替换值可以是一个字符串或者一个函数。</li>\n<li>参数<br>regexp：<br>一个 RegExp 对象。该正则所匹配的内容会被第二个参数的返回值替换掉。<br>substr：<br>一个要被 newSubStr 替换的字符串。<br>newSubStr：<br>替换掉第一个参数在原字符串中的匹配部分。该字符串中可以内插一些特殊的变量名。<br>function：<br>一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果。该函数的参数描述请参考 Specifying a function as a parameter 小节。.<br>flags：<br>注意：flags 参数在 v8 内核（Chrome and NodeJs）中不起作用。一个字符串，用来指定 regular expression flags 或其组合。在 String.replace method 中使用 flags 参数不是符合标准。使用一个带有相应标志（flags）的正则表达式（RegExp）对象来代替此参数。该参数的值应该是下面的一个或多个字符，具体作用见下：<br>g   全局替换<br>i   忽略大小写<br>m   多行模式</li>\n<li>返回：<br> 一个新字符串，其中匹配模式的某些或所有匹配项被替换为替换值。该方法并不改变调用它的字符串本身,而只是返回替换后的字符串.</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> re = <span class=\"regexp\">/apples/gi</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"Apples are round, and apples are juicy.\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> newstr = str.replace(re, <span class=\"string\">\"oranges\"</span>);</span><br><span class=\"line\">print(newstr);</span><br><span class=\"line\"><span class=\"comment\">//\"oranges are round, and oranges are juicy.\"</span></span><br></pre></td></tr></table></figure>\n<p>等同于：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"Apples are round, and apples are juicy.\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> newstr = str.replace(<span class=\"string\">\"apples\"</span>, <span class=\"string\">\"oranges\"</span>, <span class=\"string\">\"gi\"</span>);</span><br><span class=\"line\">print(newstr);</span><br><span class=\"line\"><span class=\"comment\">//\"oranges are round, and oranges are juicy.\"</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> re = <span class=\"regexp\">/(\\w+)\\s(\\w+)/</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"John Smith\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> newstr = str.replace(re, <span class=\"string\">\"$2, $1\"</span>);</span><br><span class=\"line\">print(newstr); <span class=\"comment\">//'Smith John'</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>reference: <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_string_as_a_parameter\" target=\"_blank\" rel=\"noopener\">MDN参考</a><h3 id=\"4-str-split-seperator-limit\"><a href=\"#4-str-split-seperator-limit\" class=\"headerlink\" title=\"4. str.split(seperator, limit)\"></a>4. str.split(seperator, limit)</h3></li>\n<li>描述：用来分割字符串的字符（串）。separator 可以是一个字符串或正则表达式。 如果忽略 separator，则返回的数组包含一个由原字符串组成的元素。如果 separator 是一个空字符串，则 str 将会转换成一个由原字符串中字符组成的数组。 limit一个整数，限定返回的分割片段数量。split 方法仍然分割每一个匹配的 separator，但是返回的数组只会截取最多 limit 个元素。</li>\n</ul>\n<p>＊注： 如果 separator 是一个正则表达式，且包含捕获括号（capturing parentheses），则每次匹配到 separator 时，捕获括号匹配的结果将会插入到返回的数组中。然而，不是所有浏览器都支持该特性。　</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myString = <span class=\"string\">\"Hello 1 word. Sentence number 2.\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> splits = myString.split(<span class=\"regexp\">/(\\d)/</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(splits);</span><br><span class=\"line\"><span class=\"comment\">//[\"Hello \", \"1\", \" word. Sentence number \", \"2\", \".\"]</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>reference: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split\" target=\"_blank\" rel=\"noopener\">MDN参考</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"一、RegExp对象\"><a href=\"#一、RegExp对象\" class=\"headerlink\" title=\"一、RegExp对象\"></a>一、RegExp对象</h2><p>构造正则表达式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方式1：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> re = <span class=\"regexp\">/\\w+/</span>;   <span class=\"comment\">//最常用的方式</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//方式2：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> re = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"\\\\w+\"</span>);  <span class=\"comment\">//注意转义</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1-reg-test-str\"><a href=\"#1-reg-test-str\" class=\"headerlink\" title=\"1. reg.test(str)\"></a>1. reg.test(str)</h3><p>描述：test() 方法执行一个检索，用来查看正则表达式与指定的字符串是否匹配。返回 true 或 false。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">testinput</span>(<span class=\"params\">re, str</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> midstring;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (re.test(str)) &#123;</span><br><span class=\"line\">        midstring = <span class=\"string\">\" contains \"</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        midstring = <span class=\"string\">\" does not contain \"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(str + midstring + re.source);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">testinput(<span class=\"regexp\">/c&#123;2&#125;/</span>, <span class=\"string\">'cainiao'</span>); </span><br><span class=\"line\"><span class=\"comment\">//\"cainiao does not contain c&#123;2&#125;\"</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>reference: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test\" target=\"_blank\" rel=\"noopener\">MDN参考</a></li>\n</ul>","more":"<h3 id=\"2-reg-exec-str-方法\"><a href=\"#2-reg-exec-str-方法\" class=\"headerlink\" title=\"2. reg.exec(str)方法\"></a>2. reg.exec(str)方法</h3><ul>\n<li>exec() 方法为指定的一段字符串执行搜索匹配操作。它的返回值是一个数组或者 null。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> re = <span class=\"regexp\">/d(b+)(d)/ig</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = re.exec(<span class=\"string\">\"cdbBdbsbz\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); </span><br><span class=\"line\"><span class=\"comment\">//[\"dbBd\", \"bB\", \"d\", index: 1, input: \"cdbBdbsbz\"]</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回的数据：</li>\n</ul>\n<p><table class=\"fullwidth-table\"><br> <tbody><br>  <tr><br>   <td class=\"header\">对象</td><br>   <td class=\"header\">属性/索引</td><br>   <td class=\"header\">描述</td><br>   <td class=\"header\">例子</td><br>  </tr><br>  <tr><br>   <td rowspan=\"4\"><code>result</code></td><br>   <td><code>[0]</code></td><br>   <td>正则表达式最后的匹配项</td><br>   <td><code>dbBd</code></td><br>  </tr><br>  <tr><br>   <td><code>[1], …[<br>    <i><br>     n</i><br>    ]</code></td><br>   <td>子表达式匹配项</td><br>   <td><code>[1] = bB<br><br>    [2] = d</code></td><br>  </tr><br>  <tr><br>   <td><code>index</code></td><br>   <td>第一个匹配项在原字符串中的索引</td><br>   <td><code>1</code></td><br>  </tr><br>  <tr><br>   <td><code>input</code></td><br>   <td>方法输入的参数字符串</td><br>   <td><code>cdbBdbsbz</code></td><br>  </tr><br>  <tr><br>   <td rowspan=\"5\"><code>re</code></td><br>   <td><code>lastIndex</code></td><br>   <td>下一次执行匹配开始索引的位置.</td><br>   <td><code>5</code></td><br>  </tr><br>  <tr><br>   <td><code>ignoreCase</code></td><br>   <td>指”<code>i</code>“ 标识是否启用</td><br>   <td><code>true</code></td><br>  </tr><br>  <tr><br>   <td><code>global</code></td><br>   <td>指”<code>g</code>“ 标识是否启用</td><br>   <td><code>true</code></td><br>  </tr><br>  <tr><br>   <td><code>multiline</code></td><br>   <td>指”<code>m</code>“ 标识是否启用</td><br>   <td><code>false</code></td><br>  </tr><br>  <tr><br>   <td><code>source</code></td><br>   <td>正则表达式的文本表示</td><br>   <td><code>d(b+)(d)</code></td><br>  </tr><br> </tbody><br></table></p>\n<ul>\n<li>reference：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec\" target=\"_blank\" rel=\"noopener\">MDN参考</a><h2 id=\"二、String对象\"><a href=\"#二、String对象\" class=\"headerlink\" title=\"二、String对象\"></a>二、String对象</h2><h3 id=\"1-str-search-reg-vs-reg-test-str\"><a href=\"#1-str-search-reg-vs-reg-test-str\" class=\"headerlink\" title=\"1. str.search(reg) vs reg.test(str)\"></a>1. str.search(reg) vs reg.test(str)</h3></li>\n</ul>\n<p>*描述：search() 方法执行一个查找，看该字符串对象与一个正则表达式是否匹配。参数reg为一个正则表达式对象，否则隐式调用new RegExp(reg)进行转换。<br>如果匹配成功，则 search 返回正则表达式在字符串中首次匹配项的索引。否则，返回 -1。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">testinput</span>(<span class=\"params\">re, str</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> midstring;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (str.search(re) != <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">    midstring = <span class=\"string\">\" contains \"</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    midstring = <span class=\"string\">\" does not contain \"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log (str + midstring + re);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">testinput(<span class=\"regexp\">/db*/</span>, <span class=\"string\">'sdbbdee'</span>); <span class=\"comment\">//sdbbdee contains /db*/</span></span><br></pre></td></tr></table></figure>\n<p>＊reference: <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/search\" target=\"_blank\" rel=\"noopener\">MDN参考</a></p>\n<h3 id=\"2-str-match-reg-vs-reg-exec-str\"><a href=\"#2-str-match-reg-vs-reg-exec-str\" class=\"headerlink\" title=\"2. str.match(reg)  vs  reg.exec(str)\"></a>2. str.match(reg)  vs  reg.exec(str)</h3><ul>\n<li>描述：当字符串匹配到正则表达式（regular expression）时，match() 方法会提取匹配项。reg参数为一个正则对象，若不是，则隐式地调用new RegExp(reg) 进行转换。返回数组，不匹配返回null。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"For more information, see Chapter 3.4.5.1\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> re = <span class=\"regexp\">/(chapter \\d+(\\.\\d)*)/i</span>;  <span class=\"comment\">//不是用g的情况</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> found = str.match(re);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(found);</span><br><span class=\"line\"><span class=\"comment\">//[\"Chapter 3.4.5.1\", \"Chapter 3.4.5.1\", \".1\", index: 26, input: \"For more information, see Chapter 3.4.5.1\"]</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> regexp = <span class=\"regexp\">/[A-E]/gi</span>;  <span class=\"comment\">//使用g时，found不存在index和input属性</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> found = str.match(regexp);</span><br><span class=\"line\"><span class=\"comment\">//['A', 'B', 'C', 'D', 'E', 'a', 'b', 'c', 'd', 'e']</span></span><br></pre></td></tr></table></figure>\n<p>*reference：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match\" target=\"_blank\" rel=\"noopener\">MDN参考</a></p>\n<h3 id=\"3-str-replace-regexp-substr-newSubStr-function-flags\"><a href=\"#3-str-replace-regexp-substr-newSubStr-function-flags\" class=\"headerlink\" title=\"3. str.replace(regexp|substr, newSubStr|function[,  flags])\"></a>3. str.replace(regexp|substr, newSubStr|function[,  flags])</h3><ul>\n<li>描述：replace() 方法使用一个替换值（replacement）替换掉一个匹配模式（pattern）在原字符串中某些或所有的匹配项，并返回替换后的字符串。这个替换模式可以是字符串或者正则表达式，替换值可以是一个字符串或者一个函数。</li>\n<li>参数<br>regexp：<br>一个 RegExp 对象。该正则所匹配的内容会被第二个参数的返回值替换掉。<br>substr：<br>一个要被 newSubStr 替换的字符串。<br>newSubStr：<br>替换掉第一个参数在原字符串中的匹配部分。该字符串中可以内插一些特殊的变量名。<br>function：<br>一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果。该函数的参数描述请参考 Specifying a function as a parameter 小节。.<br>flags：<br>注意：flags 参数在 v8 内核（Chrome and NodeJs）中不起作用。一个字符串，用来指定 regular expression flags 或其组合。在 String.replace method 中使用 flags 参数不是符合标准。使用一个带有相应标志（flags）的正则表达式（RegExp）对象来代替此参数。该参数的值应该是下面的一个或多个字符，具体作用见下：<br>g   全局替换<br>i   忽略大小写<br>m   多行模式</li>\n<li>返回：<br> 一个新字符串，其中匹配模式的某些或所有匹配项被替换为替换值。该方法并不改变调用它的字符串本身,而只是返回替换后的字符串.</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> re = <span class=\"regexp\">/apples/gi</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"Apples are round, and apples are juicy.\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> newstr = str.replace(re, <span class=\"string\">\"oranges\"</span>);</span><br><span class=\"line\">print(newstr);</span><br><span class=\"line\"><span class=\"comment\">//\"oranges are round, and oranges are juicy.\"</span></span><br></pre></td></tr></table></figure>\n<p>等同于：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"Apples are round, and apples are juicy.\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> newstr = str.replace(<span class=\"string\">\"apples\"</span>, <span class=\"string\">\"oranges\"</span>, <span class=\"string\">\"gi\"</span>);</span><br><span class=\"line\">print(newstr);</span><br><span class=\"line\"><span class=\"comment\">//\"oranges are round, and oranges are juicy.\"</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> re = <span class=\"regexp\">/(\\w+)\\s(\\w+)/</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"John Smith\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> newstr = str.replace(re, <span class=\"string\">\"$2, $1\"</span>);</span><br><span class=\"line\">print(newstr); <span class=\"comment\">//'Smith John'</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>reference: <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_string_as_a_parameter\" target=\"_blank\" rel=\"noopener\">MDN参考</a><h3 id=\"4-str-split-seperator-limit\"><a href=\"#4-str-split-seperator-limit\" class=\"headerlink\" title=\"4. str.split(seperator, limit)\"></a>4. str.split(seperator, limit)</h3></li>\n<li>描述：用来分割字符串的字符（串）。separator 可以是一个字符串或正则表达式。 如果忽略 separator，则返回的数组包含一个由原字符串组成的元素。如果 separator 是一个空字符串，则 str 将会转换成一个由原字符串中字符组成的数组。 limit一个整数，限定返回的分割片段数量。split 方法仍然分割每一个匹配的 separator，但是返回的数组只会截取最多 limit 个元素。</li>\n</ul>\n<p>＊注： 如果 separator 是一个正则表达式，且包含捕获括号（capturing parentheses），则每次匹配到 separator 时，捕获括号匹配的结果将会插入到返回的数组中。然而，不是所有浏览器都支持该特性。　</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myString = <span class=\"string\">\"Hello 1 word. Sentence number 2.\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> splits = myString.split(<span class=\"regexp\">/(\\d)/</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(splits);</span><br><span class=\"line\"><span class=\"comment\">//[\"Hello \", \"1\", \" word. Sentence number \", \"2\", \".\"]</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>reference: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split\" target=\"_blank\" rel=\"noopener\">MDN参考</a></li>\n</ul>"},{"title":"Javascript 对象简介","date":"2015-02-12T14:03:29.000Z","_content":"\n#### 一、 废话\n\n看着大家都已经写完2014年终总结了好多个月了，心里其实一直也想总结来着，当时是没有心情，后来放假了回家本想效仿去年一样在大年三十总结的，没想到今年电脑带回去了，网没有准备好，失策了。电脑所以也就没有起到什么作用，没起到作用就算了，回北京的路上居然还搞丢了(细节就不展开了，因为这是2015的事情)。好吧，所以你现在知道这篇为啥叫做2015年初总结了吧，ok，废话完毕。\n\n回顾2014年，二分法一看，前半年我还是学生，后半年我已步入社会；前半年我在实习，后半年正式工作；前半年我在南昌，后半年我在北京。这么强烈的反差对我来说肯定是不平凡的一年。\n#### 二、关于毕业\n\n关于大学，其实回忆起来简单总结为:大一玩耍，大二开淘宝，大三学习，大四实习，毕业，找工作。大一玩耍的后果是挂科， 大二开淘宝开始接触互联网(主要目的其实是赚钱)， 大三学习高强度的学习提高了自己的技术和能力。 大四步入工作，知道了什么是真正的开发。现在想想学校学习到了什么，专业知识是有的， 其实我觉得最重要的是入伍了计算机这个行列(而不是外人看来学计算机和修电脑的是一家的观念)，知道了怎么自己学习。其实我在学校学的是嵌入式，自学java后打算毕业后做javaWeb开发的， 谁会想到我实习后却走到了前端的道路上，所以吧学再多不如兴趣使然。下面说说关于在学校中后悔的几件事情：\n1. 实习。这个是我毕业后找工作的时候感触很深的一件事情，因为你发现身边好多都是大二就已经在外面实习了，想想自己还有当时的同学都是比较闭塞的，大家都宁愿玩游戏图乐或者做点小兼职(如送餐， 家教之类)赚钱。一天下班回家路上还跟@lusir探讨过这个问题，总结有两点： `自己当时目光比较短浅`  `家庭原因` 。\n2. 驾驶证。大学除了毕业证学位证其他证一个没有拿，到目前唯一后悔的就是没有在学校考驾驶证，其实这个在大四的时候已经意识到了，报了名了，可是还是由于工作原因退了。现在回想起来那些在大一大二的时候就考了驾照的同学真明智，因为基本上实习了再想要去考驾照了，阻力增加了不少(时间少请假麻烦， 价格也涨了)。\n\n紧接着快毕业了，在公司把毕设做了，答辩也比较顺利。拍毕业照，毕业酒会玩的很high，大家一一道别，祝福，没有想到大学同学到最后也能这么情深。最压抑的是酒会后的那些天，大家分别离开了学校，各自忙碌着。我也在开始找工作。\n#### 三、找工作\n\n决定辞职是在毕业，快要转正的时候了，我毅然选择辞职。其实走的时候还是很不舍的，毕竟这么多朝夕相处的同学在那边。当时因为再等毕业证，只能网投简历然后约电话面试。其实感觉互联网找工作反馈还是比较正面的，一般发了简历人家都会电话你也一般会给你面试的机会。\n\n经过了快大半个月吧通过电话面试我已经拿到了三个offer了。因为当时也没有考虑好去哪个城市，所以都试了试，所以三个offer居然是三个不同的城市，这直接导致我很犹豫是去广州还是北京(当时挺多同学去了广深，有劝我去广州的也有北京的)。最后还是选择了和室友去了北京。\n\n到了北京也没有直接去报道，毕竟没有当面面试的经历，所以想试试。于是就第二天去了我目前的公司，面了三面感觉面试还算顺利，感谢@yy。公司给我感觉也很随性，很open，开始有点心动。之后又去了网易，面了两面说要我等一个月再跟我约hr面(靠，一个月怎么等得起。。)，而且感觉网易好严肃。后来第二天@爱晨同学又帮忙约我去面别的部门，于是又面了两面，一共五面(总监当时安慰我说这次肯定是最后一面了)。最后终于@爱晨电话我说过了，要我最好周末后就入职，于是没多想就这样入职了美丽说。这当然要感谢@爱晨， @先烈等各位的知遇之恩。\n\n关于面试的感受主要有以下几点：\n1. 公司的氛围和你向往的工作环境是否吻合。\n2. 通过面试你尽量了解到可能将要入职的团队的一个状态，比如团队目前的人数，业务是什么，技术架构等等，这个信息主要是考虑是否有必要进入一个团队(面试是一个双向选择的过程)。比如一个团队使用的东西都是很落后的，不是你兴趣所在，那么其实这场面试已经没有意义了。\n3. 一个好团队比一个好公司重要(通过工作之后感受到的)。\n#### 四、工作\n\n几天前@wilee找我谈话问了我一个问题说你觉得入职后最的最牛X的一件事情是什么，其实我觉得这个问题还真是只有面试的时候会遇到。平时都不会去想这个问题，所以当时我就说了我觉得比较开心的一件事情，就是我从入职之后一直负责shop后台经过二次的改版终于上了一档次，比我入职的时候高大上多了。而我是刚好参与了两次的改版，为啥说是开心的事情呢，跟我当年辞职的原因有很大关系，国企我们做过的东西都是没有用户的，做完就给别人了，不用维护的，所以你不知道你做的怎么样，而做自己公司的产品就不一样了你可以看着你做的东西越来越好，越来越多人用，这才是互联网。 @wilee听我说了最后提示到你难道你不觉得bizfe的后台架构当时你一个人先搞起来的挺牛逼的么， 事后想想好像还行(哈哈玩笑，其实建议以后还是不要问这种问题了，估计@wilee也是被迫的)。入职到bizfe感觉真的很赞，完全跟自己想要的工作环境和氛围吻合。要感谢@先烈的对我的信任，并给我机会，让我尝试到了很多新东西包括组织了团队的技术交流， 带实习生， 组织改版了一次shop后台， 用了半个月做了一个webapp，现在也已经嵌入了美丽说主app。厚脸皮拿了一次美丽星。还参加了北京商家的见面会，觉得当年开淘宝店的经历还是有点用的。参与了shopv3的改版，学习了angular。 总之在bizfe机遇多多，也学到了很多。我没有在很多团队待过的经历，但入职没有多久就听公司行政同事当面夸我们团队太团结了，多次看到总监在邮件里面表扬说bizfe小伙伴敢打硬仗，也听@wilee亲口告诉我说bizfe是他见过最有凝聚力的团队，没有之一。所以一个好团队比一个好公司重要。\n#### 五、说说愿望\n\n14年终的时候很流行一句话：`My Goal in 2015 is to accomplish the goals of 2014, which I should have done in 2013 because I made a promise in 2012 and planned in 2011`。哈哈，想想也是, 下面检查下我去年的愿望：\n1. 我觉得我已经爱上了前端的工作，在14年我必须努力的把前端css，html和js三大技术深入学习，把对技术的学习更细致，更细节。当然升职加薪也很重要啦。（其实现在觉得这是一个很含糊的愿望，因为没法量化，而且任重道远。所以今年还得继续）\n2. 过去的一年里我很高兴逐渐养成了阅读的习惯，读了大概15本把，我知道有点少，但是我希望在今年我读大概30-50本左右，还希望多涉猎一些不仅是技术方面的书籍。(失败， 数了下阅读了差不多18本，而且大部分是在南昌读的,新公司基本没有什么时间，今年继续)\n3. 觉得有电影的人生很美好，花几十块钱或者一两个小时的时间就可以体会到不同人的人生。过去的一年大概看了100多部电影把，希望今年能看100-200部电影。最好是部部都精彩。哈哈。（失败，这个不用数了很肯定没有达标）\n4. 学习一门新的泛型的语言，虽然语言只是工具，但是我还是很乐意去体会不同的语言带给我不同的惊奇，感觉被《七周七语言》的作者洗脑了(完成， nodeJs)。\n5. 每周坚持至少写一篇博客，这个其实比较难，但是我需要养成这样的习惯，督促自己总结(失败，这个没有达标，严重没有达标)。\n6. 锻炼身体，初步觉得考虑网球和羽毛球还有跑步(完成，入职新工作后开始打羽毛球了)。\n7. 去courseare学习一门公开课(完成，《公证》)。\n8. 附加的愿望，看一场eason的演唱会(失败，买了票，因为要来北京还是忍痛转手了)。\n\n果然愿望和现实还是有差距的，看了下刚好勉强算完成了一半吧(去年定的有点虚了)。综合去年结合现在，2015年的愿望如下：\n1.  阅读量在30-50本左右, 类别不限。(这个我今年有信心)。\n2. 学习一门新的泛型的语言(初定swift | python)。\n3. 每月至少更新两篇(万一实现了呢)。\n4. 研究某特定的方向（暂定选择器,  webapp,  native)。\n5. 锻炼身体：羽毛球 or 游泳。\n6. 参加一次迷笛或其他音乐节/eason演唱会。\n","source":"_posts/the-summary-of-2014.md","raw":"---\ntitle: Javascript 对象简介\ndate: 2015/2/12 22:03:29\ncategories:\n- Dream Big\ntags:\n- 年终总结\n---\n\n#### 一、 废话\n\n看着大家都已经写完2014年终总结了好多个月了，心里其实一直也想总结来着，当时是没有心情，后来放假了回家本想效仿去年一样在大年三十总结的，没想到今年电脑带回去了，网没有准备好，失策了。电脑所以也就没有起到什么作用，没起到作用就算了，回北京的路上居然还搞丢了(细节就不展开了，因为这是2015的事情)。好吧，所以你现在知道这篇为啥叫做2015年初总结了吧，ok，废话完毕。\n\n回顾2014年，二分法一看，前半年我还是学生，后半年我已步入社会；前半年我在实习，后半年正式工作；前半年我在南昌，后半年我在北京。这么强烈的反差对我来说肯定是不平凡的一年。\n#### 二、关于毕业\n\n关于大学，其实回忆起来简单总结为:大一玩耍，大二开淘宝，大三学习，大四实习，毕业，找工作。大一玩耍的后果是挂科， 大二开淘宝开始接触互联网(主要目的其实是赚钱)， 大三学习高强度的学习提高了自己的技术和能力。 大四步入工作，知道了什么是真正的开发。现在想想学校学习到了什么，专业知识是有的， 其实我觉得最重要的是入伍了计算机这个行列(而不是外人看来学计算机和修电脑的是一家的观念)，知道了怎么自己学习。其实我在学校学的是嵌入式，自学java后打算毕业后做javaWeb开发的， 谁会想到我实习后却走到了前端的道路上，所以吧学再多不如兴趣使然。下面说说关于在学校中后悔的几件事情：\n1. 实习。这个是我毕业后找工作的时候感触很深的一件事情，因为你发现身边好多都是大二就已经在外面实习了，想想自己还有当时的同学都是比较闭塞的，大家都宁愿玩游戏图乐或者做点小兼职(如送餐， 家教之类)赚钱。一天下班回家路上还跟@lusir探讨过这个问题，总结有两点： `自己当时目光比较短浅`  `家庭原因` 。\n2. 驾驶证。大学除了毕业证学位证其他证一个没有拿，到目前唯一后悔的就是没有在学校考驾驶证，其实这个在大四的时候已经意识到了，报了名了，可是还是由于工作原因退了。现在回想起来那些在大一大二的时候就考了驾照的同学真明智，因为基本上实习了再想要去考驾照了，阻力增加了不少(时间少请假麻烦， 价格也涨了)。\n\n紧接着快毕业了，在公司把毕设做了，答辩也比较顺利。拍毕业照，毕业酒会玩的很high，大家一一道别，祝福，没有想到大学同学到最后也能这么情深。最压抑的是酒会后的那些天，大家分别离开了学校，各自忙碌着。我也在开始找工作。\n#### 三、找工作\n\n决定辞职是在毕业，快要转正的时候了，我毅然选择辞职。其实走的时候还是很不舍的，毕竟这么多朝夕相处的同学在那边。当时因为再等毕业证，只能网投简历然后约电话面试。其实感觉互联网找工作反馈还是比较正面的，一般发了简历人家都会电话你也一般会给你面试的机会。\n\n经过了快大半个月吧通过电话面试我已经拿到了三个offer了。因为当时也没有考虑好去哪个城市，所以都试了试，所以三个offer居然是三个不同的城市，这直接导致我很犹豫是去广州还是北京(当时挺多同学去了广深，有劝我去广州的也有北京的)。最后还是选择了和室友去了北京。\n\n到了北京也没有直接去报道，毕竟没有当面面试的经历，所以想试试。于是就第二天去了我目前的公司，面了三面感觉面试还算顺利，感谢@yy。公司给我感觉也很随性，很open，开始有点心动。之后又去了网易，面了两面说要我等一个月再跟我约hr面(靠，一个月怎么等得起。。)，而且感觉网易好严肃。后来第二天@爱晨同学又帮忙约我去面别的部门，于是又面了两面，一共五面(总监当时安慰我说这次肯定是最后一面了)。最后终于@爱晨电话我说过了，要我最好周末后就入职，于是没多想就这样入职了美丽说。这当然要感谢@爱晨， @先烈等各位的知遇之恩。\n\n关于面试的感受主要有以下几点：\n1. 公司的氛围和你向往的工作环境是否吻合。\n2. 通过面试你尽量了解到可能将要入职的团队的一个状态，比如团队目前的人数，业务是什么，技术架构等等，这个信息主要是考虑是否有必要进入一个团队(面试是一个双向选择的过程)。比如一个团队使用的东西都是很落后的，不是你兴趣所在，那么其实这场面试已经没有意义了。\n3. 一个好团队比一个好公司重要(通过工作之后感受到的)。\n#### 四、工作\n\n几天前@wilee找我谈话问了我一个问题说你觉得入职后最的最牛X的一件事情是什么，其实我觉得这个问题还真是只有面试的时候会遇到。平时都不会去想这个问题，所以当时我就说了我觉得比较开心的一件事情，就是我从入职之后一直负责shop后台经过二次的改版终于上了一档次，比我入职的时候高大上多了。而我是刚好参与了两次的改版，为啥说是开心的事情呢，跟我当年辞职的原因有很大关系，国企我们做过的东西都是没有用户的，做完就给别人了，不用维护的，所以你不知道你做的怎么样，而做自己公司的产品就不一样了你可以看着你做的东西越来越好，越来越多人用，这才是互联网。 @wilee听我说了最后提示到你难道你不觉得bizfe的后台架构当时你一个人先搞起来的挺牛逼的么， 事后想想好像还行(哈哈玩笑，其实建议以后还是不要问这种问题了，估计@wilee也是被迫的)。入职到bizfe感觉真的很赞，完全跟自己想要的工作环境和氛围吻合。要感谢@先烈的对我的信任，并给我机会，让我尝试到了很多新东西包括组织了团队的技术交流， 带实习生， 组织改版了一次shop后台， 用了半个月做了一个webapp，现在也已经嵌入了美丽说主app。厚脸皮拿了一次美丽星。还参加了北京商家的见面会，觉得当年开淘宝店的经历还是有点用的。参与了shopv3的改版，学习了angular。 总之在bizfe机遇多多，也学到了很多。我没有在很多团队待过的经历，但入职没有多久就听公司行政同事当面夸我们团队太团结了，多次看到总监在邮件里面表扬说bizfe小伙伴敢打硬仗，也听@wilee亲口告诉我说bizfe是他见过最有凝聚力的团队，没有之一。所以一个好团队比一个好公司重要。\n#### 五、说说愿望\n\n14年终的时候很流行一句话：`My Goal in 2015 is to accomplish the goals of 2014, which I should have done in 2013 because I made a promise in 2012 and planned in 2011`。哈哈，想想也是, 下面检查下我去年的愿望：\n1. 我觉得我已经爱上了前端的工作，在14年我必须努力的把前端css，html和js三大技术深入学习，把对技术的学习更细致，更细节。当然升职加薪也很重要啦。（其实现在觉得这是一个很含糊的愿望，因为没法量化，而且任重道远。所以今年还得继续）\n2. 过去的一年里我很高兴逐渐养成了阅读的习惯，读了大概15本把，我知道有点少，但是我希望在今年我读大概30-50本左右，还希望多涉猎一些不仅是技术方面的书籍。(失败， 数了下阅读了差不多18本，而且大部分是在南昌读的,新公司基本没有什么时间，今年继续)\n3. 觉得有电影的人生很美好，花几十块钱或者一两个小时的时间就可以体会到不同人的人生。过去的一年大概看了100多部电影把，希望今年能看100-200部电影。最好是部部都精彩。哈哈。（失败，这个不用数了很肯定没有达标）\n4. 学习一门新的泛型的语言，虽然语言只是工具，但是我还是很乐意去体会不同的语言带给我不同的惊奇，感觉被《七周七语言》的作者洗脑了(完成， nodeJs)。\n5. 每周坚持至少写一篇博客，这个其实比较难，但是我需要养成这样的习惯，督促自己总结(失败，这个没有达标，严重没有达标)。\n6. 锻炼身体，初步觉得考虑网球和羽毛球还有跑步(完成，入职新工作后开始打羽毛球了)。\n7. 去courseare学习一门公开课(完成，《公证》)。\n8. 附加的愿望，看一场eason的演唱会(失败，买了票，因为要来北京还是忍痛转手了)。\n\n果然愿望和现实还是有差距的，看了下刚好勉强算完成了一半吧(去年定的有点虚了)。综合去年结合现在，2015年的愿望如下：\n1.  阅读量在30-50本左右, 类别不限。(这个我今年有信心)。\n2. 学习一门新的泛型的语言(初定swift | python)。\n3. 每月至少更新两篇(万一实现了呢)。\n4. 研究某特定的方向（暂定选择器,  webapp,  native)。\n5. 锻炼身体：羽毛球 or 游泳。\n6. 参加一次迷笛或其他音乐节/eason演唱会。\n","slug":"the-summary-of-2014","published":1,"updated":"2018-08-05T04:35:04.289Z","_id":"cjkgcrhyh002oue8im96alsj9","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"一、-废话\"><a href=\"#一、-废话\" class=\"headerlink\" title=\"一、 废话\"></a>一、 废话</h4><p>看着大家都已经写完2014年终总结了好多个月了，心里其实一直也想总结来着，当时是没有心情，后来放假了回家本想效仿去年一样在大年三十总结的，没想到今年电脑带回去了，网没有准备好，失策了。电脑所以也就没有起到什么作用，没起到作用就算了，回北京的路上居然还搞丢了(细节就不展开了，因为这是2015的事情)。好吧，所以你现在知道这篇为啥叫做2015年初总结了吧，ok，废话完毕。</p>\n<p>回顾2014年，二分法一看，前半年我还是学生，后半年我已步入社会；前半年我在实习，后半年正式工作；前半年我在南昌，后半年我在北京。这么强烈的反差对我来说肯定是不平凡的一年。</p>\n<h4 id=\"二、关于毕业\"><a href=\"#二、关于毕业\" class=\"headerlink\" title=\"二、关于毕业\"></a>二、关于毕业</h4><p>关于大学，其实回忆起来简单总结为:大一玩耍，大二开淘宝，大三学习，大四实习，毕业，找工作。大一玩耍的后果是挂科， 大二开淘宝开始接触互联网(主要目的其实是赚钱)， 大三学习高强度的学习提高了自己的技术和能力。 大四步入工作，知道了什么是真正的开发。现在想想学校学习到了什么，专业知识是有的， 其实我觉得最重要的是入伍了计算机这个行列(而不是外人看来学计算机和修电脑的是一家的观念)，知道了怎么自己学习。其实我在学校学的是嵌入式，自学java后打算毕业后做javaWeb开发的， 谁会想到我实习后却走到了前端的道路上，所以吧学再多不如兴趣使然。下面说说关于在学校中后悔的几件事情：</p>\n<ol>\n<li>实习。这个是我毕业后找工作的时候感触很深的一件事情，因为你发现身边好多都是大二就已经在外面实习了，想想自己还有当时的同学都是比较闭塞的，大家都宁愿玩游戏图乐或者做点小兼职(如送餐， 家教之类)赚钱。一天下班回家路上还跟@lusir探讨过这个问题，总结有两点： <code>自己当时目光比较短浅</code>  <code>家庭原因</code> 。</li>\n<li>驾驶证。大学除了毕业证学位证其他证一个没有拿，到目前唯一后悔的就是没有在学校考驾驶证，其实这个在大四的时候已经意识到了，报了名了，可是还是由于工作原因退了。现在回想起来那些在大一大二的时候就考了驾照的同学真明智，因为基本上实习了再想要去考驾照了，阻力增加了不少(时间少请假麻烦， 价格也涨了)。</li>\n</ol>\n<p>紧接着快毕业了，在公司把毕设做了，答辩也比较顺利。拍毕业照，毕业酒会玩的很high，大家一一道别，祝福，没有想到大学同学到最后也能这么情深。最压抑的是酒会后的那些天，大家分别离开了学校，各自忙碌着。我也在开始找工作。</p>\n<h4 id=\"三、找工作\"><a href=\"#三、找工作\" class=\"headerlink\" title=\"三、找工作\"></a>三、找工作</h4><p>决定辞职是在毕业，快要转正的时候了，我毅然选择辞职。其实走的时候还是很不舍的，毕竟这么多朝夕相处的同学在那边。当时因为再等毕业证，只能网投简历然后约电话面试。其实感觉互联网找工作反馈还是比较正面的，一般发了简历人家都会电话你也一般会给你面试的机会。</p>\n<p>经过了快大半个月吧通过电话面试我已经拿到了三个offer了。因为当时也没有考虑好去哪个城市，所以都试了试，所以三个offer居然是三个不同的城市，这直接导致我很犹豫是去广州还是北京(当时挺多同学去了广深，有劝我去广州的也有北京的)。最后还是选择了和室友去了北京。</p>\n<p>到了北京也没有直接去报道，毕竟没有当面面试的经历，所以想试试。于是就第二天去了我目前的公司，面了三面感觉面试还算顺利，感谢@yy。公司给我感觉也很随性，很open，开始有点心动。之后又去了网易，面了两面说要我等一个月再跟我约hr面(靠，一个月怎么等得起。。)，而且感觉网易好严肃。后来第二天@爱晨同学又帮忙约我去面别的部门，于是又面了两面，一共五面(总监当时安慰我说这次肯定是最后一面了)。最后终于@爱晨电话我说过了，要我最好周末后就入职，于是没多想就这样入职了美丽说。这当然要感谢@爱晨， @先烈等各位的知遇之恩。</p>\n<p>关于面试的感受主要有以下几点：</p>\n<ol>\n<li>公司的氛围和你向往的工作环境是否吻合。</li>\n<li>通过面试你尽量了解到可能将要入职的团队的一个状态，比如团队目前的人数，业务是什么，技术架构等等，这个信息主要是考虑是否有必要进入一个团队(面试是一个双向选择的过程)。比如一个团队使用的东西都是很落后的，不是你兴趣所在，那么其实这场面试已经没有意义了。</li>\n<li>一个好团队比一个好公司重要(通过工作之后感受到的)。<h4 id=\"四、工作\"><a href=\"#四、工作\" class=\"headerlink\" title=\"四、工作\"></a>四、工作</h4></li>\n</ol>\n<p>几天前@wilee找我谈话问了我一个问题说你觉得入职后最的最牛X的一件事情是什么，其实我觉得这个问题还真是只有面试的时候会遇到。平时都不会去想这个问题，所以当时我就说了我觉得比较开心的一件事情，就是我从入职之后一直负责shop后台经过二次的改版终于上了一档次，比我入职的时候高大上多了。而我是刚好参与了两次的改版，为啥说是开心的事情呢，跟我当年辞职的原因有很大关系，国企我们做过的东西都是没有用户的，做完就给别人了，不用维护的，所以你不知道你做的怎么样，而做自己公司的产品就不一样了你可以看着你做的东西越来越好，越来越多人用，这才是互联网。 @wilee听我说了最后提示到你难道你不觉得bizfe的后台架构当时你一个人先搞起来的挺牛逼的么， 事后想想好像还行(哈哈玩笑，其实建议以后还是不要问这种问题了，估计@wilee也是被迫的)。入职到bizfe感觉真的很赞，完全跟自己想要的工作环境和氛围吻合。要感谢@先烈的对我的信任，并给我机会，让我尝试到了很多新东西包括组织了团队的技术交流， 带实习生， 组织改版了一次shop后台， 用了半个月做了一个webapp，现在也已经嵌入了美丽说主app。厚脸皮拿了一次美丽星。还参加了北京商家的见面会，觉得当年开淘宝店的经历还是有点用的。参与了shopv3的改版，学习了angular。 总之在bizfe机遇多多，也学到了很多。我没有在很多团队待过的经历，但入职没有多久就听公司行政同事当面夸我们团队太团结了，多次看到总监在邮件里面表扬说bizfe小伙伴敢打硬仗，也听@wilee亲口告诉我说bizfe是他见过最有凝聚力的团队，没有之一。所以一个好团队比一个好公司重要。</p>\n<h4 id=\"五、说说愿望\"><a href=\"#五、说说愿望\" class=\"headerlink\" title=\"五、说说愿望\"></a>五、说说愿望</h4><p>14年终的时候很流行一句话：<code>My Goal in 2015 is to accomplish the goals of 2014, which I should have done in 2013 because I made a promise in 2012 and planned in 2011</code>。哈哈，想想也是, 下面检查下我去年的愿望：</p>\n<ol>\n<li>我觉得我已经爱上了前端的工作，在14年我必须努力的把前端css，html和js三大技术深入学习，把对技术的学习更细致，更细节。当然升职加薪也很重要啦。（其实现在觉得这是一个很含糊的愿望，因为没法量化，而且任重道远。所以今年还得继续）</li>\n<li>过去的一年里我很高兴逐渐养成了阅读的习惯，读了大概15本把，我知道有点少，但是我希望在今年我读大概30-50本左右，还希望多涉猎一些不仅是技术方面的书籍。(失败， 数了下阅读了差不多18本，而且大部分是在南昌读的,新公司基本没有什么时间，今年继续)</li>\n<li>觉得有电影的人生很美好，花几十块钱或者一两个小时的时间就可以体会到不同人的人生。过去的一年大概看了100多部电影把，希望今年能看100-200部电影。最好是部部都精彩。哈哈。（失败，这个不用数了很肯定没有达标）</li>\n<li>学习一门新的泛型的语言，虽然语言只是工具，但是我还是很乐意去体会不同的语言带给我不同的惊奇，感觉被《七周七语言》的作者洗脑了(完成， nodeJs)。</li>\n<li>每周坚持至少写一篇博客，这个其实比较难，但是我需要养成这样的习惯，督促自己总结(失败，这个没有达标，严重没有达标)。</li>\n<li>锻炼身体，初步觉得考虑网球和羽毛球还有跑步(完成，入职新工作后开始打羽毛球了)。</li>\n<li>去courseare学习一门公开课(完成，《公证》)。</li>\n<li>附加的愿望，看一场eason的演唱会(失败，买了票，因为要来北京还是忍痛转手了)。</li>\n</ol>\n<p>果然愿望和现实还是有差距的，看了下刚好勉强算完成了一半吧(去年定的有点虚了)。综合去年结合现在，2015年的愿望如下：</p>\n<ol>\n<li>阅读量在30-50本左右, 类别不限。(这个我今年有信心)。</li>\n<li>学习一门新的泛型的语言(初定swift | python)。</li>\n<li>每月至少更新两篇(万一实现了呢)。</li>\n<li>研究某特定的方向（暂定选择器,  webapp,  native)。</li>\n<li>锻炼身体：羽毛球 or 游泳。</li>\n<li>参加一次迷笛或其他音乐节/eason演唱会。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"一、-废话\"><a href=\"#一、-废话\" class=\"headerlink\" title=\"一、 废话\"></a>一、 废话</h4><p>看着大家都已经写完2014年终总结了好多个月了，心里其实一直也想总结来着，当时是没有心情，后来放假了回家本想效仿去年一样在大年三十总结的，没想到今年电脑带回去了，网没有准备好，失策了。电脑所以也就没有起到什么作用，没起到作用就算了，回北京的路上居然还搞丢了(细节就不展开了，因为这是2015的事情)。好吧，所以你现在知道这篇为啥叫做2015年初总结了吧，ok，废话完毕。</p>\n<p>回顾2014年，二分法一看，前半年我还是学生，后半年我已步入社会；前半年我在实习，后半年正式工作；前半年我在南昌，后半年我在北京。这么强烈的反差对我来说肯定是不平凡的一年。</p>\n<h4 id=\"二、关于毕业\"><a href=\"#二、关于毕业\" class=\"headerlink\" title=\"二、关于毕业\"></a>二、关于毕业</h4><p>关于大学，其实回忆起来简单总结为:大一玩耍，大二开淘宝，大三学习，大四实习，毕业，找工作。大一玩耍的后果是挂科， 大二开淘宝开始接触互联网(主要目的其实是赚钱)， 大三学习高强度的学习提高了自己的技术和能力。 大四步入工作，知道了什么是真正的开发。现在想想学校学习到了什么，专业知识是有的， 其实我觉得最重要的是入伍了计算机这个行列(而不是外人看来学计算机和修电脑的是一家的观念)，知道了怎么自己学习。其实我在学校学的是嵌入式，自学java后打算毕业后做javaWeb开发的， 谁会想到我实习后却走到了前端的道路上，所以吧学再多不如兴趣使然。下面说说关于在学校中后悔的几件事情：</p>\n<ol>\n<li>实习。这个是我毕业后找工作的时候感触很深的一件事情，因为你发现身边好多都是大二就已经在外面实习了，想想自己还有当时的同学都是比较闭塞的，大家都宁愿玩游戏图乐或者做点小兼职(如送餐， 家教之类)赚钱。一天下班回家路上还跟@lusir探讨过这个问题，总结有两点： <code>自己当时目光比较短浅</code>  <code>家庭原因</code> 。</li>\n<li>驾驶证。大学除了毕业证学位证其他证一个没有拿，到目前唯一后悔的就是没有在学校考驾驶证，其实这个在大四的时候已经意识到了，报了名了，可是还是由于工作原因退了。现在回想起来那些在大一大二的时候就考了驾照的同学真明智，因为基本上实习了再想要去考驾照了，阻力增加了不少(时间少请假麻烦， 价格也涨了)。</li>\n</ol>\n<p>紧接着快毕业了，在公司把毕设做了，答辩也比较顺利。拍毕业照，毕业酒会玩的很high，大家一一道别，祝福，没有想到大学同学到最后也能这么情深。最压抑的是酒会后的那些天，大家分别离开了学校，各自忙碌着。我也在开始找工作。</p>\n<h4 id=\"三、找工作\"><a href=\"#三、找工作\" class=\"headerlink\" title=\"三、找工作\"></a>三、找工作</h4><p>决定辞职是在毕业，快要转正的时候了，我毅然选择辞职。其实走的时候还是很不舍的，毕竟这么多朝夕相处的同学在那边。当时因为再等毕业证，只能网投简历然后约电话面试。其实感觉互联网找工作反馈还是比较正面的，一般发了简历人家都会电话你也一般会给你面试的机会。</p>\n<p>经过了快大半个月吧通过电话面试我已经拿到了三个offer了。因为当时也没有考虑好去哪个城市，所以都试了试，所以三个offer居然是三个不同的城市，这直接导致我很犹豫是去广州还是北京(当时挺多同学去了广深，有劝我去广州的也有北京的)。最后还是选择了和室友去了北京。</p>\n<p>到了北京也没有直接去报道，毕竟没有当面面试的经历，所以想试试。于是就第二天去了我目前的公司，面了三面感觉面试还算顺利，感谢@yy。公司给我感觉也很随性，很open，开始有点心动。之后又去了网易，面了两面说要我等一个月再跟我约hr面(靠，一个月怎么等得起。。)，而且感觉网易好严肃。后来第二天@爱晨同学又帮忙约我去面别的部门，于是又面了两面，一共五面(总监当时安慰我说这次肯定是最后一面了)。最后终于@爱晨电话我说过了，要我最好周末后就入职，于是没多想就这样入职了美丽说。这当然要感谢@爱晨， @先烈等各位的知遇之恩。</p>\n<p>关于面试的感受主要有以下几点：</p>\n<ol>\n<li>公司的氛围和你向往的工作环境是否吻合。</li>\n<li>通过面试你尽量了解到可能将要入职的团队的一个状态，比如团队目前的人数，业务是什么，技术架构等等，这个信息主要是考虑是否有必要进入一个团队(面试是一个双向选择的过程)。比如一个团队使用的东西都是很落后的，不是你兴趣所在，那么其实这场面试已经没有意义了。</li>\n<li>一个好团队比一个好公司重要(通过工作之后感受到的)。<h4 id=\"四、工作\"><a href=\"#四、工作\" class=\"headerlink\" title=\"四、工作\"></a>四、工作</h4></li>\n</ol>\n<p>几天前@wilee找我谈话问了我一个问题说你觉得入职后最的最牛X的一件事情是什么，其实我觉得这个问题还真是只有面试的时候会遇到。平时都不会去想这个问题，所以当时我就说了我觉得比较开心的一件事情，就是我从入职之后一直负责shop后台经过二次的改版终于上了一档次，比我入职的时候高大上多了。而我是刚好参与了两次的改版，为啥说是开心的事情呢，跟我当年辞职的原因有很大关系，国企我们做过的东西都是没有用户的，做完就给别人了，不用维护的，所以你不知道你做的怎么样，而做自己公司的产品就不一样了你可以看着你做的东西越来越好，越来越多人用，这才是互联网。 @wilee听我说了最后提示到你难道你不觉得bizfe的后台架构当时你一个人先搞起来的挺牛逼的么， 事后想想好像还行(哈哈玩笑，其实建议以后还是不要问这种问题了，估计@wilee也是被迫的)。入职到bizfe感觉真的很赞，完全跟自己想要的工作环境和氛围吻合。要感谢@先烈的对我的信任，并给我机会，让我尝试到了很多新东西包括组织了团队的技术交流， 带实习生， 组织改版了一次shop后台， 用了半个月做了一个webapp，现在也已经嵌入了美丽说主app。厚脸皮拿了一次美丽星。还参加了北京商家的见面会，觉得当年开淘宝店的经历还是有点用的。参与了shopv3的改版，学习了angular。 总之在bizfe机遇多多，也学到了很多。我没有在很多团队待过的经历，但入职没有多久就听公司行政同事当面夸我们团队太团结了，多次看到总监在邮件里面表扬说bizfe小伙伴敢打硬仗，也听@wilee亲口告诉我说bizfe是他见过最有凝聚力的团队，没有之一。所以一个好团队比一个好公司重要。</p>\n<h4 id=\"五、说说愿望\"><a href=\"#五、说说愿望\" class=\"headerlink\" title=\"五、说说愿望\"></a>五、说说愿望</h4><p>14年终的时候很流行一句话：<code>My Goal in 2015 is to accomplish the goals of 2014, which I should have done in 2013 because I made a promise in 2012 and planned in 2011</code>。哈哈，想想也是, 下面检查下我去年的愿望：</p>\n<ol>\n<li>我觉得我已经爱上了前端的工作，在14年我必须努力的把前端css，html和js三大技术深入学习，把对技术的学习更细致，更细节。当然升职加薪也很重要啦。（其实现在觉得这是一个很含糊的愿望，因为没法量化，而且任重道远。所以今年还得继续）</li>\n<li>过去的一年里我很高兴逐渐养成了阅读的习惯，读了大概15本把，我知道有点少，但是我希望在今年我读大概30-50本左右，还希望多涉猎一些不仅是技术方面的书籍。(失败， 数了下阅读了差不多18本，而且大部分是在南昌读的,新公司基本没有什么时间，今年继续)</li>\n<li>觉得有电影的人生很美好，花几十块钱或者一两个小时的时间就可以体会到不同人的人生。过去的一年大概看了100多部电影把，希望今年能看100-200部电影。最好是部部都精彩。哈哈。（失败，这个不用数了很肯定没有达标）</li>\n<li>学习一门新的泛型的语言，虽然语言只是工具，但是我还是很乐意去体会不同的语言带给我不同的惊奇，感觉被《七周七语言》的作者洗脑了(完成， nodeJs)。</li>\n<li>每周坚持至少写一篇博客，这个其实比较难，但是我需要养成这样的习惯，督促自己总结(失败，这个没有达标，严重没有达标)。</li>\n<li>锻炼身体，初步觉得考虑网球和羽毛球还有跑步(完成，入职新工作后开始打羽毛球了)。</li>\n<li>去courseare学习一门公开课(完成，《公证》)。</li>\n<li>附加的愿望，看一场eason的演唱会(失败，买了票，因为要来北京还是忍痛转手了)。</li>\n</ol>\n<p>果然愿望和现实还是有差距的，看了下刚好勉强算完成了一半吧(去年定的有点虚了)。综合去年结合现在，2015年的愿望如下：</p>\n<ol>\n<li>阅读量在30-50本左右, 类别不限。(这个我今年有信心)。</li>\n<li>学习一门新的泛型的语言(初定swift | python)。</li>\n<li>每月至少更新两篇(万一实现了呢)。</li>\n<li>研究某特定的方向（暂定选择器,  webapp,  native)。</li>\n<li>锻炼身体：羽毛球 or 游泳。</li>\n<li>参加一次迷笛或其他音乐节/eason演唱会。</li>\n</ol>\n"},{"title":"JAVA 对象得生命周期","date":"2015-10-07T12:47:30.000Z","_content":"\n\n### 一、背景\n\n放假七天，没什么事情，就想结合自己的工作经验，整理下我的aliyun服务器。那么就从nginx开始。\n### 二、 选型\n\n目前[nginx提供的版本](http://nginx.org/en/download.html)有很多, 面对这么多版本，翻了翻changelog，发现最新版的刚好添加了http2的支持，而且对于我来的个人站点来说，nginx的版本并没有太大的要求，基本上都能满足，所以就决定试试最新版，也为之后可以试试http2的特性做准备。但是大家在生产环境还是尽量选择stable版本 : )\n### 三、安装\n#### 1. 之前的方式\n\n我的aliyun当初配置的是ubuntu系统，之前安装什么软件都是采用`apt-get install`的方式，这种方式对于使用来说很方便，但是有个缺点对于软件安装的目录很分散，导致你要配置一个东西需要找各种目录, 还有就是有些软件要删除的时候使用`apt-get remove`经常删除不完整，导致经常看到这样一个问题[`What is the correct way to completely remove an application`](http://askubuntu.com/questions/187888/what-is-the-correct-way-to-completely-remove-an-application) ，特别是时间久了，自己也会忘记了删除的正确方法。\n#### 2. 目前的方式\n\n所以这次，打算学着sys的做法，建立一个独立的用户`/home/sys` 用来管理和安装这些我们要经常维护的软件。这样安装好了之后，只要把`/home/sys/nginx/sbin/nginx`建立一个软链到/usr/sbin中就可以了(编译安装过程自行建立)。 要删除的时候也可以直接删除nginx文件夹和软链就可以了。但是这种方式就得我们自己编译和安装nginx了，不过这个也很简单。\n#### 3. 操作\n\n``` sh\nuseradd sys -m  #创建/home/sys和sys账号\n\ncd /home/sys\n\nmkdir nginx   #创建/home/sys/nginx目录待会安装使用。\n\nwget  http://nginx.org/download/nginx-1.9.5.tar.gz  #下载nginx源码包\n\ntar -zxvf  nginx-1.9.5.tar.gz ###解压\n\ncd  nginx-1.9.5\n\n./configure --prefix=/home/sys/nginx  #检测依赖和配置安装目录, 会再当前目录中生成makefile文件\n\nmake && make install   # 执行编译和安装。\n```\n\n就这样把nginx独立编译安装到你指定的目录中，当然肯定会在configure步骤中遇到一些依赖问题，这个各位就自行解决啦，因为这个过程和问题google一大堆。\n### 四、配置\n\nnginx安装好了之后，进入nginx目录，我们要重点关注的就是conf文件夹了, 那是我们需要重点配置和维护的地方。可以看到里面每份文件都有两个版本，如：nginx.conf  和 nginx.conf.default，你git diff下发现其实里面内容是一模一样的。这个估计是nginx考虑到经常备份的问题，所以就自己先提供一份备份，这样就可以直接修改_.conf文件，因为搞坏了还可以直接用_.conf.default恢复。\n\n在nginx.conf中我们主要关注是的`http  server location`这种块级的指令，而这次我主要要做的是把nginx的配置合理的解耦, 这个是咱们配置的重点。主要分为三部分，http指令的配置， server指令的配置， 还有upstream的配置。分别对应的如下的文件或文件夹： nginx.conf,   nginx/vhost/_.conf,   nginx/upstream/_.conf;  关于这些名词可参考[这里](http://nginx.org/en/docs/beginners_guide.html#conf_structure)\n#### 1. nginx.conf\n\n先看第一部分，nginx.conf 中咱们把默认http下server配置全部移除，留下http部分的配置。这里我们主要针对的是落在这台nginx的所有请求进行配置。截取主要的配置文件内容如下：\n\n```\nuser       www www;  ## Default: nobody 以什么用户启动nginx\nworker_processes  5;  ## Default: 1  启动后fork多少个work子进程，可以改动后看看效果，根据cpu核数配置，或者直接写 auto；\nerror_log  logs/error.log;\npid        logs/nginx.pid;\nworker_rlimit_nofile 1024;  ###每个work进程最大并发数量\n\nevents {\n  worker_connections  1024;  ## Default: 1024  ####最大连接数，受worker_rlimit_nofile限制\n}\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '  #配置日志的等级main及格式\n                     '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n    log_format  error '$remote_addr - $remote_user [$time_local] \"$request\" '\n                     '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n    access_log  logs/access.log  main;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    #keepalive_timeout  0;\n    keepalive_timeout  65;\n\n    gzip  on;                                      #默认开始gzip压缩\n    include upstream/*.conf;             #通过include指令引入需要代理到的upstream配置。\n    include vhost/fex/*.conf;             #通过include指令引入server部分(virtul host)的配置。\n}\n```\n#### 2. vhost/*.conf\n\n这个目录下里面的文件主要对server进行配置，可以直接连接对某个域名站点进行配置。是对某一个域名下的请求进行配置的，所以可以以域名为单位建立配置文件，如：vhost/fexnotes.com.conf。简单截取文件内容下：\n\n```\nserver {\n    listen       80;      #监听80端口\n    server_name  fexnotes.com *.fexnotes.com;  #服务的域名\n    access_log   logs/fexnotes.access.log main;  #使用main等级配置访问日志。\n    error_log    logs/fexnotes.error.log error;          #使用error等级配置错误日志。\n\n    set $the_fexnotes_upstream   \"to_hexo_all\";   #使用set指令配置upstream为：'to_hexo_all'\n    location / {  #将所有的请求代理到the_fexnotes_upstream中。\n      proxy_pass      http://$the_fexnotes_upstream;    \n    }\n  }\n```\n#### 3. upstream/*.conf\n\nupstream中主要用来从server指令中配置反向代理到的机器列表。同理可以使用域名为单位建立配置文件，如： fexnotes.com.upstream.conf.简单截取内容如下：\n\n```\nupstream to_hexo_all {\n    server x.x.x.x:port max_fails=3 fail_timeout=10s;  #ip端口可以自行配置。 这样请求落最后落到了这台机器上。\n}\n```\n\n经过如上的配置，这样就把原本在nginx.conf一个文件中配置所有的内容，解耦成三部分，这样维护起来就方便多了。以后需要增加域名，只要在vhost和upstream中新建域名相应文件和配置就可以了。\n### 五、启动\n\n大功告成，启动命令如下：\n\n``` sh\n cd /home/sys/sbin/nginx  \n./nginx -t   #检测是否配置有问题\n./nginx -r reload  #没有文件就可以直接reload生效了\n```\n\n现在[点击这里](http://www.fexnotes.com)访问下试试吧. : )\n### 参考：\n1. http://nginx.org/en/docs/beginners_guide.html#conf_structure\n2. https://www.nginx.com/resources/admin-guide/?_ga=1.72470931.143333815.1440149452\n3. http://nginx.org/en/docs/\n","source":"_posts/nginx-config.md","raw":"---\ntitle: JAVA 对象得生命周期\ndate: 2015/10/7 20:47:30\ncategories:\n- Shit Done\ntags:\n- Nginx \n- nginx 配置\n---\n\n\n### 一、背景\n\n放假七天，没什么事情，就想结合自己的工作经验，整理下我的aliyun服务器。那么就从nginx开始。\n### 二、 选型\n\n目前[nginx提供的版本](http://nginx.org/en/download.html)有很多, 面对这么多版本，翻了翻changelog，发现最新版的刚好添加了http2的支持，而且对于我来的个人站点来说，nginx的版本并没有太大的要求，基本上都能满足，所以就决定试试最新版，也为之后可以试试http2的特性做准备。但是大家在生产环境还是尽量选择stable版本 : )\n### 三、安装\n#### 1. 之前的方式\n\n我的aliyun当初配置的是ubuntu系统，之前安装什么软件都是采用`apt-get install`的方式，这种方式对于使用来说很方便，但是有个缺点对于软件安装的目录很分散，导致你要配置一个东西需要找各种目录, 还有就是有些软件要删除的时候使用`apt-get remove`经常删除不完整，导致经常看到这样一个问题[`What is the correct way to completely remove an application`](http://askubuntu.com/questions/187888/what-is-the-correct-way-to-completely-remove-an-application) ，特别是时间久了，自己也会忘记了删除的正确方法。\n#### 2. 目前的方式\n\n所以这次，打算学着sys的做法，建立一个独立的用户`/home/sys` 用来管理和安装这些我们要经常维护的软件。这样安装好了之后，只要把`/home/sys/nginx/sbin/nginx`建立一个软链到/usr/sbin中就可以了(编译安装过程自行建立)。 要删除的时候也可以直接删除nginx文件夹和软链就可以了。但是这种方式就得我们自己编译和安装nginx了，不过这个也很简单。\n#### 3. 操作\n\n``` sh\nuseradd sys -m  #创建/home/sys和sys账号\n\ncd /home/sys\n\nmkdir nginx   #创建/home/sys/nginx目录待会安装使用。\n\nwget  http://nginx.org/download/nginx-1.9.5.tar.gz  #下载nginx源码包\n\ntar -zxvf  nginx-1.9.5.tar.gz ###解压\n\ncd  nginx-1.9.5\n\n./configure --prefix=/home/sys/nginx  #检测依赖和配置安装目录, 会再当前目录中生成makefile文件\n\nmake && make install   # 执行编译和安装。\n```\n\n就这样把nginx独立编译安装到你指定的目录中，当然肯定会在configure步骤中遇到一些依赖问题，这个各位就自行解决啦，因为这个过程和问题google一大堆。\n### 四、配置\n\nnginx安装好了之后，进入nginx目录，我们要重点关注的就是conf文件夹了, 那是我们需要重点配置和维护的地方。可以看到里面每份文件都有两个版本，如：nginx.conf  和 nginx.conf.default，你git diff下发现其实里面内容是一模一样的。这个估计是nginx考虑到经常备份的问题，所以就自己先提供一份备份，这样就可以直接修改_.conf文件，因为搞坏了还可以直接用_.conf.default恢复。\n\n在nginx.conf中我们主要关注是的`http  server location`这种块级的指令，而这次我主要要做的是把nginx的配置合理的解耦, 这个是咱们配置的重点。主要分为三部分，http指令的配置， server指令的配置， 还有upstream的配置。分别对应的如下的文件或文件夹： nginx.conf,   nginx/vhost/_.conf,   nginx/upstream/_.conf;  关于这些名词可参考[这里](http://nginx.org/en/docs/beginners_guide.html#conf_structure)\n#### 1. nginx.conf\n\n先看第一部分，nginx.conf 中咱们把默认http下server配置全部移除，留下http部分的配置。这里我们主要针对的是落在这台nginx的所有请求进行配置。截取主要的配置文件内容如下：\n\n```\nuser       www www;  ## Default: nobody 以什么用户启动nginx\nworker_processes  5;  ## Default: 1  启动后fork多少个work子进程，可以改动后看看效果，根据cpu核数配置，或者直接写 auto；\nerror_log  logs/error.log;\npid        logs/nginx.pid;\nworker_rlimit_nofile 1024;  ###每个work进程最大并发数量\n\nevents {\n  worker_connections  1024;  ## Default: 1024  ####最大连接数，受worker_rlimit_nofile限制\n}\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '  #配置日志的等级main及格式\n                     '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n    log_format  error '$remote_addr - $remote_user [$time_local] \"$request\" '\n                     '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n    access_log  logs/access.log  main;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    #keepalive_timeout  0;\n    keepalive_timeout  65;\n\n    gzip  on;                                      #默认开始gzip压缩\n    include upstream/*.conf;             #通过include指令引入需要代理到的upstream配置。\n    include vhost/fex/*.conf;             #通过include指令引入server部分(virtul host)的配置。\n}\n```\n#### 2. vhost/*.conf\n\n这个目录下里面的文件主要对server进行配置，可以直接连接对某个域名站点进行配置。是对某一个域名下的请求进行配置的，所以可以以域名为单位建立配置文件，如：vhost/fexnotes.com.conf。简单截取文件内容下：\n\n```\nserver {\n    listen       80;      #监听80端口\n    server_name  fexnotes.com *.fexnotes.com;  #服务的域名\n    access_log   logs/fexnotes.access.log main;  #使用main等级配置访问日志。\n    error_log    logs/fexnotes.error.log error;          #使用error等级配置错误日志。\n\n    set $the_fexnotes_upstream   \"to_hexo_all\";   #使用set指令配置upstream为：'to_hexo_all'\n    location / {  #将所有的请求代理到the_fexnotes_upstream中。\n      proxy_pass      http://$the_fexnotes_upstream;    \n    }\n  }\n```\n#### 3. upstream/*.conf\n\nupstream中主要用来从server指令中配置反向代理到的机器列表。同理可以使用域名为单位建立配置文件，如： fexnotes.com.upstream.conf.简单截取内容如下：\n\n```\nupstream to_hexo_all {\n    server x.x.x.x:port max_fails=3 fail_timeout=10s;  #ip端口可以自行配置。 这样请求落最后落到了这台机器上。\n}\n```\n\n经过如上的配置，这样就把原本在nginx.conf一个文件中配置所有的内容，解耦成三部分，这样维护起来就方便多了。以后需要增加域名，只要在vhost和upstream中新建域名相应文件和配置就可以了。\n### 五、启动\n\n大功告成，启动命令如下：\n\n``` sh\n cd /home/sys/sbin/nginx  \n./nginx -t   #检测是否配置有问题\n./nginx -r reload  #没有文件就可以直接reload生效了\n```\n\n现在[点击这里](http://www.fexnotes.com)访问下试试吧. : )\n### 参考：\n1. http://nginx.org/en/docs/beginners_guide.html#conf_structure\n2. https://www.nginx.com/resources/admin-guide/?_ga=1.72470931.143333815.1440149452\n3. http://nginx.org/en/docs/\n","slug":"nginx-config","published":1,"updated":"2018-08-05T04:36:01.560Z","_id":"cjkgcsygw002uue8iv1uako37","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"一、背景\"><a href=\"#一、背景\" class=\"headerlink\" title=\"一、背景\"></a>一、背景</h3><p>放假七天，没什么事情，就想结合自己的工作经验，整理下我的aliyun服务器。那么就从nginx开始。</p>\n<h3 id=\"二、-选型\"><a href=\"#二、-选型\" class=\"headerlink\" title=\"二、 选型\"></a>二、 选型</h3><p>目前<a href=\"http://nginx.org/en/download.html\" target=\"_blank\" rel=\"noopener\">nginx提供的版本</a>有很多, 面对这么多版本，翻了翻changelog，发现最新版的刚好添加了http2的支持，而且对于我来的个人站点来说，nginx的版本并没有太大的要求，基本上都能满足，所以就决定试试最新版，也为之后可以试试http2的特性做准备。但是大家在生产环境还是尽量选择stable版本 : )</p>\n<h3 id=\"三、安装\"><a href=\"#三、安装\" class=\"headerlink\" title=\"三、安装\"></a>三、安装</h3><h4 id=\"1-之前的方式\"><a href=\"#1-之前的方式\" class=\"headerlink\" title=\"1. 之前的方式\"></a>1. 之前的方式</h4><p>我的aliyun当初配置的是ubuntu系统，之前安装什么软件都是采用<code>apt-get install</code>的方式，这种方式对于使用来说很方便，但是有个缺点对于软件安装的目录很分散，导致你要配置一个东西需要找各种目录, 还有就是有些软件要删除的时候使用<code>apt-get remove</code>经常删除不完整，导致经常看到这样一个问题<a href=\"http://askubuntu.com/questions/187888/what-is-the-correct-way-to-completely-remove-an-application\" target=\"_blank\" rel=\"noopener\"><code>What is the correct way to completely remove an application</code></a> ，特别是时间久了，自己也会忘记了删除的正确方法。</p>\n<h4 id=\"2-目前的方式\"><a href=\"#2-目前的方式\" class=\"headerlink\" title=\"2. 目前的方式\"></a>2. 目前的方式</h4><p>所以这次，打算学着sys的做法，建立一个独立的用户<code>/home/sys</code> 用来管理和安装这些我们要经常维护的软件。这样安装好了之后，只要把<code>/home/sys/nginx/sbin/nginx</code>建立一个软链到/usr/sbin中就可以了(编译安装过程自行建立)。 要删除的时候也可以直接删除nginx文件夹和软链就可以了。但是这种方式就得我们自己编译和安装nginx了，不过这个也很简单。</p>\n<h4 id=\"3-操作\"><a href=\"#3-操作\" class=\"headerlink\" title=\"3. 操作\"></a>3. 操作</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useradd sys -m  <span class=\"comment\">#创建/home/sys和sys账号</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /home/sys</span><br><span class=\"line\"></span><br><span class=\"line\">mkdir nginx   <span class=\"comment\">#创建/home/sys/nginx目录待会安装使用。</span></span><br><span class=\"line\"></span><br><span class=\"line\">wget  http://nginx.org/download/nginx-1.9.5.tar.gz  <span class=\"comment\">#下载nginx源码包</span></span><br><span class=\"line\"></span><br><span class=\"line\">tar -zxvf  nginx-1.9.5.tar.gz <span class=\"comment\">###解压</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span>  nginx-1.9.5</span><br><span class=\"line\"></span><br><span class=\"line\">./configure --prefix=/home/sys/nginx  <span class=\"comment\">#检测依赖和配置安装目录, 会再当前目录中生成makefile文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">make &amp;&amp; make install   <span class=\"comment\"># 执行编译和安装。</span></span><br></pre></td></tr></table></figure>\n<p>就这样把nginx独立编译安装到你指定的目录中，当然肯定会在configure步骤中遇到一些依赖问题，这个各位就自行解决啦，因为这个过程和问题google一大堆。</p>\n<h3 id=\"四、配置\"><a href=\"#四、配置\" class=\"headerlink\" title=\"四、配置\"></a>四、配置</h3><p>nginx安装好了之后，进入nginx目录，我们要重点关注的就是conf文件夹了, 那是我们需要重点配置和维护的地方。可以看到里面每份文件都有两个版本，如：nginx.conf  和 nginx.conf.default，你git diff下发现其实里面内容是一模一样的。这个估计是nginx考虑到经常备份的问题，所以就自己先提供一份备份，这样就可以直接修改<em>.conf文件，因为搞坏了还可以直接用</em>.conf.default恢复。</p>\n<p>在nginx.conf中我们主要关注是的<code>http  server location</code>这种块级的指令，而这次我主要要做的是把nginx的配置合理的解耦, 这个是咱们配置的重点。主要分为三部分，http指令的配置， server指令的配置， 还有upstream的配置。分别对应的如下的文件或文件夹： nginx.conf,   nginx/vhost/<em>.conf,   nginx/upstream/</em>.conf;  关于这些名词可参考<a href=\"http://nginx.org/en/docs/beginners_guide.html#conf_structure\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<h4 id=\"1-nginx-conf\"><a href=\"#1-nginx-conf\" class=\"headerlink\" title=\"1. nginx.conf\"></a>1. nginx.conf</h4><p>先看第一部分，nginx.conf 中咱们把默认http下server配置全部移除，留下http部分的配置。这里我们主要针对的是落在这台nginx的所有请求进行配置。截取主要的配置文件内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user       www www;  ## Default: nobody 以什么用户启动nginx</span><br><span class=\"line\">worker_processes  5;  ## Default: 1  启动后fork多少个work子进程，可以改动后看看效果，根据cpu核数配置，或者直接写 auto；</span><br><span class=\"line\">error_log  logs/error.log;</span><br><span class=\"line\">pid        logs/nginx.pid;</span><br><span class=\"line\">worker_rlimit_nofile 1024;  ###每个work进程最大并发数量</span><br><span class=\"line\"></span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">  worker_connections  1024;  ## Default: 1024  ####最大连接数，受worker_rlimit_nofile限制</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    include       mime.types;</span><br><span class=\"line\">    default_type  application/octet-stream;</span><br><span class=\"line\"></span><br><span class=\"line\">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;  #配置日志的等级main及格式</span><br><span class=\"line\">                     &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class=\"line\">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">    log_format  error &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class=\"line\">                     &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class=\"line\">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">    access_log  logs/access.log  main;</span><br><span class=\"line\"></span><br><span class=\"line\">    sendfile        on;</span><br><span class=\"line\">    #tcp_nopush     on;</span><br><span class=\"line\"></span><br><span class=\"line\">    #keepalive_timeout  0;</span><br><span class=\"line\">    keepalive_timeout  65;</span><br><span class=\"line\"></span><br><span class=\"line\">    gzip  on;                                      #默认开始gzip压缩</span><br><span class=\"line\">    include upstream/*.conf;             #通过include指令引入需要代理到的upstream配置。</span><br><span class=\"line\">    include vhost/fex/*.conf;             #通过include指令引入server部分(virtul host)的配置。</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-vhost-conf\"><a href=\"#2-vhost-conf\" class=\"headerlink\" title=\"2. vhost/*.conf\"></a>2. vhost/*.conf</h4><p>这个目录下里面的文件主要对server进行配置，可以直接连接对某个域名站点进行配置。是对某一个域名下的请求进行配置的，所以可以以域名为单位建立配置文件，如：vhost/fexnotes.com.conf。简单截取文件内容下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen       80;      #监听80端口</span><br><span class=\"line\">    server_name  fexnotes.com *.fexnotes.com;  #服务的域名</span><br><span class=\"line\">    access_log   logs/fexnotes.access.log main;  #使用main等级配置访问日志。</span><br><span class=\"line\">    error_log    logs/fexnotes.error.log error;          #使用error等级配置错误日志。</span><br><span class=\"line\"></span><br><span class=\"line\">    set $the_fexnotes_upstream   &quot;to_hexo_all&quot;;   #使用set指令配置upstream为：&apos;to_hexo_all&apos;</span><br><span class=\"line\">    location / &#123;  #将所有的请求代理到the_fexnotes_upstream中。</span><br><span class=\"line\">      proxy_pass      http://$the_fexnotes_upstream;    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-upstream-conf\"><a href=\"#3-upstream-conf\" class=\"headerlink\" title=\"3. upstream/*.conf\"></a>3. upstream/*.conf</h4><p>upstream中主要用来从server指令中配置反向代理到的机器列表。同理可以使用域名为单位建立配置文件，如： fexnotes.com.upstream.conf.简单截取内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream to_hexo_all &#123;</span><br><span class=\"line\">    server x.x.x.x:port max_fails=3 fail_timeout=10s;  #ip端口可以自行配置。 这样请求落最后落到了这台机器上。</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>经过如上的配置，这样就把原本在nginx.conf一个文件中配置所有的内容，解耦成三部分，这样维护起来就方便多了。以后需要增加域名，只要在vhost和upstream中新建域名相应文件和配置就可以了。</p>\n<h3 id=\"五、启动\"><a href=\"#五、启动\" class=\"headerlink\" title=\"五、启动\"></a>五、启动</h3><p>大功告成，启动命令如下：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"built_in\">cd</span> /home/sys/sbin/nginx  </span><br><span class=\"line\">./nginx -t   <span class=\"comment\">#检测是否配置有问题</span></span><br><span class=\"line\">./nginx -r reload  <span class=\"comment\">#没有文件就可以直接reload生效了</span></span><br></pre></td></tr></table></figure>\n<p>现在<a href=\"http://www.fexnotes.com\" target=\"_blank\" rel=\"noopener\">点击这里</a>访问下试试吧. : )</p>\n<h3 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h3><ol>\n<li><a href=\"http://nginx.org/en/docs/beginners_guide.html#conf_structure\" target=\"_blank\" rel=\"noopener\">http://nginx.org/en/docs/beginners_guide.html#conf_structure</a></li>\n<li><a href=\"https://www.nginx.com/resources/admin-guide/?_ga=1.72470931.143333815.1440149452\" target=\"_blank\" rel=\"noopener\">https://www.nginx.com/resources/admin-guide/?_ga=1.72470931.143333815.1440149452</a></li>\n<li><a href=\"http://nginx.org/en/docs/\" target=\"_blank\" rel=\"noopener\">http://nginx.org/en/docs/</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、背景\"><a href=\"#一、背景\" class=\"headerlink\" title=\"一、背景\"></a>一、背景</h3><p>放假七天，没什么事情，就想结合自己的工作经验，整理下我的aliyun服务器。那么就从nginx开始。</p>\n<h3 id=\"二、-选型\"><a href=\"#二、-选型\" class=\"headerlink\" title=\"二、 选型\"></a>二、 选型</h3><p>目前<a href=\"http://nginx.org/en/download.html\" target=\"_blank\" rel=\"noopener\">nginx提供的版本</a>有很多, 面对这么多版本，翻了翻changelog，发现最新版的刚好添加了http2的支持，而且对于我来的个人站点来说，nginx的版本并没有太大的要求，基本上都能满足，所以就决定试试最新版，也为之后可以试试http2的特性做准备。但是大家在生产环境还是尽量选择stable版本 : )</p>\n<h3 id=\"三、安装\"><a href=\"#三、安装\" class=\"headerlink\" title=\"三、安装\"></a>三、安装</h3><h4 id=\"1-之前的方式\"><a href=\"#1-之前的方式\" class=\"headerlink\" title=\"1. 之前的方式\"></a>1. 之前的方式</h4><p>我的aliyun当初配置的是ubuntu系统，之前安装什么软件都是采用<code>apt-get install</code>的方式，这种方式对于使用来说很方便，但是有个缺点对于软件安装的目录很分散，导致你要配置一个东西需要找各种目录, 还有就是有些软件要删除的时候使用<code>apt-get remove</code>经常删除不完整，导致经常看到这样一个问题<a href=\"http://askubuntu.com/questions/187888/what-is-the-correct-way-to-completely-remove-an-application\" target=\"_blank\" rel=\"noopener\"><code>What is the correct way to completely remove an application</code></a> ，特别是时间久了，自己也会忘记了删除的正确方法。</p>\n<h4 id=\"2-目前的方式\"><a href=\"#2-目前的方式\" class=\"headerlink\" title=\"2. 目前的方式\"></a>2. 目前的方式</h4><p>所以这次，打算学着sys的做法，建立一个独立的用户<code>/home/sys</code> 用来管理和安装这些我们要经常维护的软件。这样安装好了之后，只要把<code>/home/sys/nginx/sbin/nginx</code>建立一个软链到/usr/sbin中就可以了(编译安装过程自行建立)。 要删除的时候也可以直接删除nginx文件夹和软链就可以了。但是这种方式就得我们自己编译和安装nginx了，不过这个也很简单。</p>\n<h4 id=\"3-操作\"><a href=\"#3-操作\" class=\"headerlink\" title=\"3. 操作\"></a>3. 操作</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useradd sys -m  <span class=\"comment\">#创建/home/sys和sys账号</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /home/sys</span><br><span class=\"line\"></span><br><span class=\"line\">mkdir nginx   <span class=\"comment\">#创建/home/sys/nginx目录待会安装使用。</span></span><br><span class=\"line\"></span><br><span class=\"line\">wget  http://nginx.org/download/nginx-1.9.5.tar.gz  <span class=\"comment\">#下载nginx源码包</span></span><br><span class=\"line\"></span><br><span class=\"line\">tar -zxvf  nginx-1.9.5.tar.gz <span class=\"comment\">###解压</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span>  nginx-1.9.5</span><br><span class=\"line\"></span><br><span class=\"line\">./configure --prefix=/home/sys/nginx  <span class=\"comment\">#检测依赖和配置安装目录, 会再当前目录中生成makefile文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">make &amp;&amp; make install   <span class=\"comment\"># 执行编译和安装。</span></span><br></pre></td></tr></table></figure>\n<p>就这样把nginx独立编译安装到你指定的目录中，当然肯定会在configure步骤中遇到一些依赖问题，这个各位就自行解决啦，因为这个过程和问题google一大堆。</p>\n<h3 id=\"四、配置\"><a href=\"#四、配置\" class=\"headerlink\" title=\"四、配置\"></a>四、配置</h3><p>nginx安装好了之后，进入nginx目录，我们要重点关注的就是conf文件夹了, 那是我们需要重点配置和维护的地方。可以看到里面每份文件都有两个版本，如：nginx.conf  和 nginx.conf.default，你git diff下发现其实里面内容是一模一样的。这个估计是nginx考虑到经常备份的问题，所以就自己先提供一份备份，这样就可以直接修改<em>.conf文件，因为搞坏了还可以直接用</em>.conf.default恢复。</p>\n<p>在nginx.conf中我们主要关注是的<code>http  server location</code>这种块级的指令，而这次我主要要做的是把nginx的配置合理的解耦, 这个是咱们配置的重点。主要分为三部分，http指令的配置， server指令的配置， 还有upstream的配置。分别对应的如下的文件或文件夹： nginx.conf,   nginx/vhost/<em>.conf,   nginx/upstream/</em>.conf;  关于这些名词可参考<a href=\"http://nginx.org/en/docs/beginners_guide.html#conf_structure\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<h4 id=\"1-nginx-conf\"><a href=\"#1-nginx-conf\" class=\"headerlink\" title=\"1. nginx.conf\"></a>1. nginx.conf</h4><p>先看第一部分，nginx.conf 中咱们把默认http下server配置全部移除，留下http部分的配置。这里我们主要针对的是落在这台nginx的所有请求进行配置。截取主要的配置文件内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user       www www;  ## Default: nobody 以什么用户启动nginx</span><br><span class=\"line\">worker_processes  5;  ## Default: 1  启动后fork多少个work子进程，可以改动后看看效果，根据cpu核数配置，或者直接写 auto；</span><br><span class=\"line\">error_log  logs/error.log;</span><br><span class=\"line\">pid        logs/nginx.pid;</span><br><span class=\"line\">worker_rlimit_nofile 1024;  ###每个work进程最大并发数量</span><br><span class=\"line\"></span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">  worker_connections  1024;  ## Default: 1024  ####最大连接数，受worker_rlimit_nofile限制</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    include       mime.types;</span><br><span class=\"line\">    default_type  application/octet-stream;</span><br><span class=\"line\"></span><br><span class=\"line\">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;  #配置日志的等级main及格式</span><br><span class=\"line\">                     &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class=\"line\">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">    log_format  error &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class=\"line\">                     &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class=\"line\">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">    access_log  logs/access.log  main;</span><br><span class=\"line\"></span><br><span class=\"line\">    sendfile        on;</span><br><span class=\"line\">    #tcp_nopush     on;</span><br><span class=\"line\"></span><br><span class=\"line\">    #keepalive_timeout  0;</span><br><span class=\"line\">    keepalive_timeout  65;</span><br><span class=\"line\"></span><br><span class=\"line\">    gzip  on;                                      #默认开始gzip压缩</span><br><span class=\"line\">    include upstream/*.conf;             #通过include指令引入需要代理到的upstream配置。</span><br><span class=\"line\">    include vhost/fex/*.conf;             #通过include指令引入server部分(virtul host)的配置。</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-vhost-conf\"><a href=\"#2-vhost-conf\" class=\"headerlink\" title=\"2. vhost/*.conf\"></a>2. vhost/*.conf</h4><p>这个目录下里面的文件主要对server进行配置，可以直接连接对某个域名站点进行配置。是对某一个域名下的请求进行配置的，所以可以以域名为单位建立配置文件，如：vhost/fexnotes.com.conf。简单截取文件内容下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen       80;      #监听80端口</span><br><span class=\"line\">    server_name  fexnotes.com *.fexnotes.com;  #服务的域名</span><br><span class=\"line\">    access_log   logs/fexnotes.access.log main;  #使用main等级配置访问日志。</span><br><span class=\"line\">    error_log    logs/fexnotes.error.log error;          #使用error等级配置错误日志。</span><br><span class=\"line\"></span><br><span class=\"line\">    set $the_fexnotes_upstream   &quot;to_hexo_all&quot;;   #使用set指令配置upstream为：&apos;to_hexo_all&apos;</span><br><span class=\"line\">    location / &#123;  #将所有的请求代理到the_fexnotes_upstream中。</span><br><span class=\"line\">      proxy_pass      http://$the_fexnotes_upstream;    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-upstream-conf\"><a href=\"#3-upstream-conf\" class=\"headerlink\" title=\"3. upstream/*.conf\"></a>3. upstream/*.conf</h4><p>upstream中主要用来从server指令中配置反向代理到的机器列表。同理可以使用域名为单位建立配置文件，如： fexnotes.com.upstream.conf.简单截取内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream to_hexo_all &#123;</span><br><span class=\"line\">    server x.x.x.x:port max_fails=3 fail_timeout=10s;  #ip端口可以自行配置。 这样请求落最后落到了这台机器上。</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>经过如上的配置，这样就把原本在nginx.conf一个文件中配置所有的内容，解耦成三部分，这样维护起来就方便多了。以后需要增加域名，只要在vhost和upstream中新建域名相应文件和配置就可以了。</p>\n<h3 id=\"五、启动\"><a href=\"#五、启动\" class=\"headerlink\" title=\"五、启动\"></a>五、启动</h3><p>大功告成，启动命令如下：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"built_in\">cd</span> /home/sys/sbin/nginx  </span><br><span class=\"line\">./nginx -t   <span class=\"comment\">#检测是否配置有问题</span></span><br><span class=\"line\">./nginx -r reload  <span class=\"comment\">#没有文件就可以直接reload生效了</span></span><br></pre></td></tr></table></figure>\n<p>现在<a href=\"http://www.fexnotes.com\" target=\"_blank\" rel=\"noopener\">点击这里</a>访问下试试吧. : )</p>\n<h3 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h3><ol>\n<li><a href=\"http://nginx.org/en/docs/beginners_guide.html#conf_structure\" target=\"_blank\" rel=\"noopener\">http://nginx.org/en/docs/beginners_guide.html#conf_structure</a></li>\n<li><a href=\"https://www.nginx.com/resources/admin-guide/?_ga=1.72470931.143333815.1440149452\" target=\"_blank\" rel=\"noopener\">https://www.nginx.com/resources/admin-guide/?_ga=1.72470931.143333815.1440149452</a></li>\n<li><a href=\"http://nginx.org/en/docs/\" target=\"_blank\" rel=\"noopener\">http://nginx.org/en/docs/</a></li>\n</ol>\n"},{"title":"bootstrap架构","date":"2015-10-17T14:01:25.000Z","_content":"\n## bootstrap架构\n\n### 背景\n\n最新负责的业务正在进行UI改版，因为之前是基于bootstrap进行的UI构造，所以把之前整理的一份bootstrap目录架构记录于此，便于翻阅。\n### 目录结构\n\n其实bootstrap整个目录结构还是挺清晰的，整个bootstrap的大致的结构如下：\n\n```\n├── dist     //build的产出文件\n├── docs     //bs文档\n├── fonts    //bs使用到的文件\n├── grunt    //bs的打包脚本\n├── js       //bs的js插件\n├── less     //bs的less源码\n└── test-infra   //bs构建文档的工具\n```\n\n我们主要关注的是less目录，而less中的目录结构如下\n\n```\n├── mixins               //各个组件使用的函数,以组件为单位划分文件\n├── mixins.less          //mixins目录中文件的入口文件\n├── boostrap.less        //整个bootstrap的入口文件\n├──[components].less     //bootstrap的组件less文件                \n├──theme.less            //bootstrap的主题文件\n```\n### 目录间关系\n\nboostrap中有两个大的入口文件： theme.less 和 bootstrap.less。bootstrap.less引入了整个项目中最原始的组件的样式，而theme.less其实就是用来对bootstrap进行覆盖和重置样式的，以便定制出需要的样式。 其实文字用来描述这个东西有所费力，所以less目录中的文件关系我使用脑图进行了整理，便于后续查阅，截图如下：\n\n并且附上原始的[脑图链接](http://naotu.baidu.com/file/ebc96f510255a9c1e32c980ef4b3cf45?token=cee6c0740a71ecee)\n\nbtw：最新的UI改版方案，已经确定，并且是按着预期设想的那样进行的，之后要是经过实践可行的话，会继续另起一篇blog分享 ：）\n","source":"_posts/bootsrap-learning.md","raw":"---\ntitle: bootstrap架构 \ndate: 2015/10/17 22:01:25\ncategories:\n- Shit Done\ntags:\n- CSS\n- Bootstrap \n---\n\n## bootstrap架构\n\n### 背景\n\n最新负责的业务正在进行UI改版，因为之前是基于bootstrap进行的UI构造，所以把之前整理的一份bootstrap目录架构记录于此，便于翻阅。\n### 目录结构\n\n其实bootstrap整个目录结构还是挺清晰的，整个bootstrap的大致的结构如下：\n\n```\n├── dist     //build的产出文件\n├── docs     //bs文档\n├── fonts    //bs使用到的文件\n├── grunt    //bs的打包脚本\n├── js       //bs的js插件\n├── less     //bs的less源码\n└── test-infra   //bs构建文档的工具\n```\n\n我们主要关注的是less目录，而less中的目录结构如下\n\n```\n├── mixins               //各个组件使用的函数,以组件为单位划分文件\n├── mixins.less          //mixins目录中文件的入口文件\n├── boostrap.less        //整个bootstrap的入口文件\n├──[components].less     //bootstrap的组件less文件                \n├──theme.less            //bootstrap的主题文件\n```\n### 目录间关系\n\nboostrap中有两个大的入口文件： theme.less 和 bootstrap.less。bootstrap.less引入了整个项目中最原始的组件的样式，而theme.less其实就是用来对bootstrap进行覆盖和重置样式的，以便定制出需要的样式。 其实文字用来描述这个东西有所费力，所以less目录中的文件关系我使用脑图进行了整理，便于后续查阅，截图如下：\n\n并且附上原始的[脑图链接](http://naotu.baidu.com/file/ebc96f510255a9c1e32c980ef4b3cf45?token=cee6c0740a71ecee)\n\nbtw：最新的UI改版方案，已经确定，并且是按着预期设想的那样进行的，之后要是经过实践可行的话，会继续另起一篇blog分享 ：）\n","slug":"bootsrap-learning","published":1,"updated":"2018-08-05T04:37:59.339Z","_id":"cjkgcurwu0032ue8ibyckq8yh","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"bootstrap架构\"><a href=\"#bootstrap架构\" class=\"headerlink\" title=\"bootstrap架构\"></a>bootstrap架构</h2><h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>最新负责的业务正在进行UI改版，因为之前是基于bootstrap进行的UI构造，所以把之前整理的一份bootstrap目录架构记录于此，便于翻阅。</p>\n<h3 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h3><p>其实bootstrap整个目录结构还是挺清晰的，整个bootstrap的大致的结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── dist     //build的产出文件</span><br><span class=\"line\">├── docs     //bs文档</span><br><span class=\"line\">├── fonts    //bs使用到的文件</span><br><span class=\"line\">├── grunt    //bs的打包脚本</span><br><span class=\"line\">├── js       //bs的js插件</span><br><span class=\"line\">├── less     //bs的less源码</span><br><span class=\"line\">└── test-infra   //bs构建文档的工具</span><br></pre></td></tr></table></figure>\n<p>我们主要关注的是less目录，而less中的目录结构如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── mixins               //各个组件使用的函数,以组件为单位划分文件</span><br><span class=\"line\">├── mixins.less          //mixins目录中文件的入口文件</span><br><span class=\"line\">├── boostrap.less        //整个bootstrap的入口文件</span><br><span class=\"line\">├──[components].less     //bootstrap的组件less文件                </span><br><span class=\"line\">├──theme.less            //bootstrap的主题文件</span><br></pre></td></tr></table></figure>\n<h3 id=\"目录间关系\"><a href=\"#目录间关系\" class=\"headerlink\" title=\"目录间关系\"></a>目录间关系</h3><p>boostrap中有两个大的入口文件： theme.less 和 bootstrap.less。bootstrap.less引入了整个项目中最原始的组件的样式，而theme.less其实就是用来对bootstrap进行覆盖和重置样式的，以便定制出需要的样式。 其实文字用来描述这个东西有所费力，所以less目录中的文件关系我使用脑图进行了整理，便于后续查阅，截图如下：</p>\n<p>并且附上原始的<a href=\"http://naotu.baidu.com/file/ebc96f510255a9c1e32c980ef4b3cf45?token=cee6c0740a71ecee\" target=\"_blank\" rel=\"noopener\">脑图链接</a></p>\n<p>btw：最新的UI改版方案，已经确定，并且是按着预期设想的那样进行的，之后要是经过实践可行的话，会继续另起一篇blog分享 ：）</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"bootstrap架构\"><a href=\"#bootstrap架构\" class=\"headerlink\" title=\"bootstrap架构\"></a>bootstrap架构</h2><h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>最新负责的业务正在进行UI改版，因为之前是基于bootstrap进行的UI构造，所以把之前整理的一份bootstrap目录架构记录于此，便于翻阅。</p>\n<h3 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h3><p>其实bootstrap整个目录结构还是挺清晰的，整个bootstrap的大致的结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── dist     //build的产出文件</span><br><span class=\"line\">├── docs     //bs文档</span><br><span class=\"line\">├── fonts    //bs使用到的文件</span><br><span class=\"line\">├── grunt    //bs的打包脚本</span><br><span class=\"line\">├── js       //bs的js插件</span><br><span class=\"line\">├── less     //bs的less源码</span><br><span class=\"line\">└── test-infra   //bs构建文档的工具</span><br></pre></td></tr></table></figure>\n<p>我们主要关注的是less目录，而less中的目录结构如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── mixins               //各个组件使用的函数,以组件为单位划分文件</span><br><span class=\"line\">├── mixins.less          //mixins目录中文件的入口文件</span><br><span class=\"line\">├── boostrap.less        //整个bootstrap的入口文件</span><br><span class=\"line\">├──[components].less     //bootstrap的组件less文件                </span><br><span class=\"line\">├──theme.less            //bootstrap的主题文件</span><br></pre></td></tr></table></figure>\n<h3 id=\"目录间关系\"><a href=\"#目录间关系\" class=\"headerlink\" title=\"目录间关系\"></a>目录间关系</h3><p>boostrap中有两个大的入口文件： theme.less 和 bootstrap.less。bootstrap.less引入了整个项目中最原始的组件的样式，而theme.less其实就是用来对bootstrap进行覆盖和重置样式的，以便定制出需要的样式。 其实文字用来描述这个东西有所费力，所以less目录中的文件关系我使用脑图进行了整理，便于后续查阅，截图如下：</p>\n<p>并且附上原始的<a href=\"http://naotu.baidu.com/file/ebc96f510255a9c1e32c980ef4b3cf45?token=cee6c0740a71ecee\" target=\"_blank\" rel=\"noopener\">脑图链接</a></p>\n<p>btw：最新的UI改版方案，已经确定，并且是按着预期设想的那样进行的，之后要是经过实践可行的话，会继续另起一篇blog分享 ：）</p>\n"},{"title":"Python Web 项目架构","date":"2015-10-24T12:47:30.000Z","_content":"\n### 背景\n\n作为整理aliyun的第二弹，把之前项目中用到的python项目的结构备注下来，后续如果要做东西的话除了nodejs又可以多了一项选择: )，这里要感谢@小泽同学，进行的python相关组内分享。\n### 选型\n\n关于python的web框架也是挺多的，这里我就不做各种比较了，因为也没有很多的这方面的经验，不过这次选择用的[flask框架](http://docs.jinkan.org/docs/flask/)还是挺简洁，小巧。而且扩展性很好，具有很多的插件可以用。基于flask继而确定了如下的方案：\n\n| 名称 | 方案 |\n| --- | --- |\n| web 框架 | flask |\n| web server | gunicorn |\n| database | MongoDB |\n\n围绕这些，还安装了Flask-Script，pymongo。其中[Flask-Script]()是Flask的一个扩展，可以往python程序中增加脚本功能，例如查看目前程序中提供了哪些路由：\n`python manage.py urls`  。pymongo可以猜到是mongo的一个驱动。这些都可以通过`pip`来进行安装。\n### 代码目录结构\n\n确定好了选型了之后，就可以对代码结构进行构造了\n\n```\n├── lib    //业务代码依赖的一些库，pyton的扩展\n│   └── flask_plugin   //python的扩展\n│   └── mongoUtils.py    //DB操作的基类\n└── blog               //业务代码\n│   ├── models         //db层，根据或者结构划分文件，封装db的操作。一般继承操作DB的基类\n│   ├── service        //处理业务逻辑的类，调用DB和返回数据给views\n│   └── views          //根据声明的路由，调用业务处理请求。\n│   └── config.py      //一些固定的配置，如db配置。\n│——— manage.py           //项目的启动文件，一些Flask-Script的扩展命令写在这里。\n```\n\n整个项目结构，基本上如此，可以看出，整体上还是一个MVC的结构。其实还可以根据业务看是否把views和service中所有的业务class都从各自的一个基类中继承。这样整个看起来就很清晰了。除此之外，python为了文件之间`import`方便，制定了package的概念，可以[参考这里](http://www.cnpythoner.com/post/2.html)进行了解。一般在文件夹下面创建了`__init__.py`文件，则此文件夹就被当做为一个package，这样就可以通过   `import`的方式进行引入。真怀疑ES6的module机制也是从python抄来的 : )\n\n接下来，会同步下reactjs的入门探索。\n","source":"_posts/python-web-learning.md","raw":"\n---\ntitle: Python Web 项目架构\ndate: 2015/10/24 20:47:30\ncategories:\n- Shit Done\ntags:\n- Python\n- flask\n---\n\n### 背景\n\n作为整理aliyun的第二弹，把之前项目中用到的python项目的结构备注下来，后续如果要做东西的话除了nodejs又可以多了一项选择: )，这里要感谢@小泽同学，进行的python相关组内分享。\n### 选型\n\n关于python的web框架也是挺多的，这里我就不做各种比较了，因为也没有很多的这方面的经验，不过这次选择用的[flask框架](http://docs.jinkan.org/docs/flask/)还是挺简洁，小巧。而且扩展性很好，具有很多的插件可以用。基于flask继而确定了如下的方案：\n\n| 名称 | 方案 |\n| --- | --- |\n| web 框架 | flask |\n| web server | gunicorn |\n| database | MongoDB |\n\n围绕这些，还安装了Flask-Script，pymongo。其中[Flask-Script]()是Flask的一个扩展，可以往python程序中增加脚本功能，例如查看目前程序中提供了哪些路由：\n`python manage.py urls`  。pymongo可以猜到是mongo的一个驱动。这些都可以通过`pip`来进行安装。\n### 代码目录结构\n\n确定好了选型了之后，就可以对代码结构进行构造了\n\n```\n├── lib    //业务代码依赖的一些库，pyton的扩展\n│   └── flask_plugin   //python的扩展\n│   └── mongoUtils.py    //DB操作的基类\n└── blog               //业务代码\n│   ├── models         //db层，根据或者结构划分文件，封装db的操作。一般继承操作DB的基类\n│   ├── service        //处理业务逻辑的类，调用DB和返回数据给views\n│   └── views          //根据声明的路由，调用业务处理请求。\n│   └── config.py      //一些固定的配置，如db配置。\n│——— manage.py           //项目的启动文件，一些Flask-Script的扩展命令写在这里。\n```\n\n整个项目结构，基本上如此，可以看出，整体上还是一个MVC的结构。其实还可以根据业务看是否把views和service中所有的业务class都从各自的一个基类中继承。这样整个看起来就很清晰了。除此之外，python为了文件之间`import`方便，制定了package的概念，可以[参考这里](http://www.cnpythoner.com/post/2.html)进行了解。一般在文件夹下面创建了`__init__.py`文件，则此文件夹就被当做为一个package，这样就可以通过   `import`的方式进行引入。真怀疑ES6的module机制也是从python抄来的 : )\n\n接下来，会同步下reactjs的入门探索。\n","slug":"python-web-learning","published":1,"updated":"2018-08-05T04:39:31.826Z","_id":"cjkgcwrwq003cue8ic7h9prlh","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>作为整理aliyun的第二弹，把之前项目中用到的python项目的结构备注下来，后续如果要做东西的话除了nodejs又可以多了一项选择: )，这里要感谢@小泽同学，进行的python相关组内分享。</p>\n<h3 id=\"选型\"><a href=\"#选型\" class=\"headerlink\" title=\"选型\"></a>选型</h3><p>关于python的web框架也是挺多的，这里我就不做各种比较了，因为也没有很多的这方面的经验，不过这次选择用的<a href=\"http://docs.jinkan.org/docs/flask/\" target=\"_blank\" rel=\"noopener\">flask框架</a>还是挺简洁，小巧。而且扩展性很好，具有很多的插件可以用。基于flask继而确定了如下的方案：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>方案</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>web 框架</td>\n<td>flask</td>\n</tr>\n<tr>\n<td>web server</td>\n<td>gunicorn</td>\n</tr>\n<tr>\n<td>database</td>\n<td>MongoDB</td>\n</tr>\n</tbody>\n</table>\n<p>围绕这些，还安装了Flask-Script，pymongo。其中<a href=\"\">Flask-Script</a>是Flask的一个扩展，可以往python程序中增加脚本功能，例如查看目前程序中提供了哪些路由：<br><code>python manage.py urls</code>  。pymongo可以猜到是mongo的一个驱动。这些都可以通过<code>pip</code>来进行安装。</p>\n<h3 id=\"代码目录结构\"><a href=\"#代码目录结构\" class=\"headerlink\" title=\"代码目录结构\"></a>代码目录结构</h3><p>确定好了选型了之后，就可以对代码结构进行构造了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── lib    //业务代码依赖的一些库，pyton的扩展</span><br><span class=\"line\">│   └── flask_plugin   //python的扩展</span><br><span class=\"line\">│   └── mongoUtils.py    //DB操作的基类</span><br><span class=\"line\">└── blog               //业务代码</span><br><span class=\"line\">│   ├── models         //db层，根据或者结构划分文件，封装db的操作。一般继承操作DB的基类</span><br><span class=\"line\">│   ├── service        //处理业务逻辑的类，调用DB和返回数据给views</span><br><span class=\"line\">│   └── views          //根据声明的路由，调用业务处理请求。</span><br><span class=\"line\">│   └── config.py      //一些固定的配置，如db配置。</span><br><span class=\"line\">│——— manage.py           //项目的启动文件，一些Flask-Script的扩展命令写在这里。</span><br></pre></td></tr></table></figure>\n<p>整个项目结构，基本上如此，可以看出，整体上还是一个MVC的结构。其实还可以根据业务看是否把views和service中所有的业务class都从各自的一个基类中继承。这样整个看起来就很清晰了。除此之外，python为了文件之间<code>import</code>方便，制定了package的概念，可以<a href=\"http://www.cnpythoner.com/post/2.html\" target=\"_blank\" rel=\"noopener\">参考这里</a>进行了解。一般在文件夹下面创建了<code>__init__.py</code>文件，则此文件夹就被当做为一个package，这样就可以通过   <code>import</code>的方式进行引入。真怀疑ES6的module机制也是从python抄来的 : )</p>\n<p>接下来，会同步下reactjs的入门探索。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>作为整理aliyun的第二弹，把之前项目中用到的python项目的结构备注下来，后续如果要做东西的话除了nodejs又可以多了一项选择: )，这里要感谢@小泽同学，进行的python相关组内分享。</p>\n<h3 id=\"选型\"><a href=\"#选型\" class=\"headerlink\" title=\"选型\"></a>选型</h3><p>关于python的web框架也是挺多的，这里我就不做各种比较了，因为也没有很多的这方面的经验，不过这次选择用的<a href=\"http://docs.jinkan.org/docs/flask/\" target=\"_blank\" rel=\"noopener\">flask框架</a>还是挺简洁，小巧。而且扩展性很好，具有很多的插件可以用。基于flask继而确定了如下的方案：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>方案</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>web 框架</td>\n<td>flask</td>\n</tr>\n<tr>\n<td>web server</td>\n<td>gunicorn</td>\n</tr>\n<tr>\n<td>database</td>\n<td>MongoDB</td>\n</tr>\n</tbody>\n</table>\n<p>围绕这些，还安装了Flask-Script，pymongo。其中<a href=\"\">Flask-Script</a>是Flask的一个扩展，可以往python程序中增加脚本功能，例如查看目前程序中提供了哪些路由：<br><code>python manage.py urls</code>  。pymongo可以猜到是mongo的一个驱动。这些都可以通过<code>pip</code>来进行安装。</p>\n<h3 id=\"代码目录结构\"><a href=\"#代码目录结构\" class=\"headerlink\" title=\"代码目录结构\"></a>代码目录结构</h3><p>确定好了选型了之后，就可以对代码结构进行构造了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── lib    //业务代码依赖的一些库，pyton的扩展</span><br><span class=\"line\">│   └── flask_plugin   //python的扩展</span><br><span class=\"line\">│   └── mongoUtils.py    //DB操作的基类</span><br><span class=\"line\">└── blog               //业务代码</span><br><span class=\"line\">│   ├── models         //db层，根据或者结构划分文件，封装db的操作。一般继承操作DB的基类</span><br><span class=\"line\">│   ├── service        //处理业务逻辑的类，调用DB和返回数据给views</span><br><span class=\"line\">│   └── views          //根据声明的路由，调用业务处理请求。</span><br><span class=\"line\">│   └── config.py      //一些固定的配置，如db配置。</span><br><span class=\"line\">│——— manage.py           //项目的启动文件，一些Flask-Script的扩展命令写在这里。</span><br></pre></td></tr></table></figure>\n<p>整个项目结构，基本上如此，可以看出，整体上还是一个MVC的结构。其实还可以根据业务看是否把views和service中所有的业务class都从各自的一个基类中继承。这样整个看起来就很清晰了。除此之外，python为了文件之间<code>import</code>方便，制定了package的概念，可以<a href=\"http://www.cnpythoner.com/post/2.html\" target=\"_blank\" rel=\"noopener\">参考这里</a>进行了解。一般在文件夹下面创建了<code>__init__.py</code>文件，则此文件夹就被当做为一个package，这样就可以通过   <code>import</code>的方式进行引入。真怀疑ES6的module机制也是从python抄来的 : )</p>\n<p>接下来，会同步下reactjs的入门探索。</p>\n"},{"title":"(译)ES6 JavaScript Destructuring in Depth","date":"2015-11-08T11:21:25.000Z","_content":"\n> [原文地址](https://ponyfoo.com/articles/es6-destructuring-in-depth#special-case-import-statements)\n\n这篇文章将专注于讨论ES6中的语言特性。以ES6中的最为有用，同时也存在一些陷阱的解构开始，我们之后将开一个系列文章来讨论ES6。\n#### 简短的声明\n\n当在不确定和有选择的情况下，你可能还是应该使用ES5和老的语法而不是因为你知道ES6就是用ES6。然而我并不是说是用ES6的语法是一种错误的方法--恰恰相反，你正看到我写关于ES6的文章。我提倡的是基于这样一个事实，确定她一定能提高我们代码的质量的时候才使用ES6, 而仅仅是因为她时一个`酷玩意儿`--虽然她是。\n\n到目前为止，我所说的观点是用ES5来写东西，加上一些ES6的语法糖在上面将确切的改善我的代码。我推测在不久后我能快速的意识到某些场景下使用ES6是优于ES5的，但是在目前紧跟着学习她是一个不错的主意，而不要走得太极端。谨慎分析什么是最适合你的代码，并且心里记着可以有ES6这个新的选择就行。\n\n> 这样，你将懂得怎样将新的特性学以致用，而不只是学学语法。\n\n现在就来看看ES6中的新特性把！\n#### 解构\n\n这是ES6中最简单，也是我使用的最多的一个特性。她可以绑定属性到你需要的任意多的变量上面，并且她支持数组和对象。\n\n``` js\n    var foo = { bar: 'pony', baz: 3}\n    var { bar, baz } = foo\n    console.log(bar)  //<- 'pony'\n    console.log(baz)  //<- 'baz'\n```\n\n 她可以十分高效的将指定属性从一个对象中解构出来。你也可以使用映射属性到一个别名。\n\n``` js\n    var foo = {bar: 'pony', baz: 3}\n    var {bar: a, baz: b} = foo \n    console.log(a) //<- 'pony'\n    console.log(b)  //<- '3'\n```\n\n你也可以把属性放到任意深的位置，并且完成别名的绑定。\n\n``` js\n    var foo = { bar: {deep: 'pony', dangerouslySetInnerHTML: 'lol'}}\n    var { bar: {deep, dangerouslySetInnerHTML: sure} } = foo\n    console.log(deep)  //<- 'pony'\n    console.log(sure)  //<- 'lol'\n```\n\n默认的，没有找到的对应的属性的值将使`undefined`,  就像你通过`.`或者`[]`访问一个对象中不存在的属性一样。\n\n``` js\n    var { foo } = {bar: 'baz'}\n    console.log(foo)  //<- undefined\n```\n\n如果尝试去访问对象一个不存在的深嵌套的属性，将会得到一个异常。\n\n``` js\n    var {foo: {bar}} = {baz: 'ouch'} //<- Exception  Cannot read property 'bar' of undefined\n```\n\n如果你知道她只是在ES5上进行了一层语法的包装，你将好理解很多\n\n``` js\n    var _tmp = { baz: 'ouch' }\n    var bar = _temp.foo.bar //<- Exception\n```\n\n解构有个非常酷的特性她允许你不用通过中间变量来交换变量之间的值。\n\n``` js\n    function es5() {\n        var left = 10\n        var right = 20\n        var aux\n        if (right > left) {\n            aux = right\n            right = left\n            left = aux\n        }\n    }\n\n    function es6() {\n        var left = 10\n        var right = 20\n        var aux\n        if (right > left ) {\n            [ right, left ] = [ left, right ]\n        }\n    }\n```\n\n另外一个方便的部分是解构可以让`keys`[使用表达式](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names)。\n\n``` js\n    var key = 'such_dynamic'\n    var [ [key]: foo ] = { such_dynamic: 'bar' }\n    console.log(foo) //<- 'bar'\n```\n\n在ES5中，你要实现的话需要而外的语句和变量声明\n\n``` js\n    var key = 'such_dynamic'\n    var baz = { such_dynamic: 'bar'}\n    var foo = baz[key]\n    console.log(foo)\n```\n\n你可以为变量指定默认值，当解构出来的属性值为`undefined`的时候，比较有用。\n\n``` js\n    var { foo = 3 } = { foo : 2 }\n    console.log(foo) //<- 2\n\n    var { foo = 3 } = { foo: undefined }\n    console.log(foo) //<- 3\n\n    var { foo = 3 } = { bar: 2 }\n    console.log(foo) //<- 3\n```\n\n解构同样对数组有效，且看我用中括号在声明语句中解构数组\n\n``` js\n    var [a] = [10]\n    console.log(a) //<- 10\n```\n\n并且我们同样可以使用相同的规则指定默认值\n\n``` js\n    var [a] = []\n    console.log(a)  //<- undefined\n    var [b = 10] = [undefined]\n    console.log(b) //<- 10\n\n    var [c = 10] = []\n    console.log(c) //<- 10\n```\n\n当是数组的时候你还可以方便的忽略某些你不关心的元素\n\n``` js\n    var [,,a, b] = [1, 2, 3, 4, 5]\n    console.log(a) //<- 3\n    console.log(b)  //<- 4\n```\n\n同样你可以在函数的参数列表中使用解构\n\n``` js\n    function greet ({age, name:greeting='she'}) {\n        consol.log(`${greeting} is ${age} years old.`)\n    }\n    greet({name: 'nico', age: 27}) //<- 'nico is 27 years old'\n\n    greet({age: 24}) //<- 'she is 24 years old'\n```\n\n以上是你可以怎样使用解构的一个粗略的介绍，那解构一般用于什么场景呢？\n#### 解构的使用场景\n\n解构用各种使用场景，这个是最常见的一个，当你有个返回对象的方法时，解构可以通过十分简便的方法提取返回值\n\n``` js\n    function getCoords () {\n        return {\n             x: 10, \n             y: 22\n         }\n    }\n    var {x, y} = getCoords()\n    console.log(x) //<- 10\n    console.log(y) //<- 20\n```\n\n另一个相似的但是相反的是使用结构为函数的一大串参数定义默认值，这个十分有趣，她实现了在其他语言如`Python` 和`C#`中的命名参数。\n\n``` js\n    function random ({ min = 1, max = 30 }) {\n        return Math.floor(Math.random() * (max - min)) + min\n    }\n    console.log(random({}))  //<- 174\n    console.log(random({max:24})) //<- 18\n```\n\n如果你想让形参完全是可选的，你可以改变写法如下\n\n``` js\n    function random({min = 1, max =300 } = {}) {\n        return Math.floor(Math.random() * (max - min)) + min \n    }\n    console.log(random()) //<- 133\n```\n\n解构还非常适用在正则表达式中，当你想给一些缺乏索引的值指定变量的时候，这里有一个解析URL的随机正则的例子，我在[StackOverflow](http://stackoverflow.com/questions/27745/getting-parts-of-a-url-regex/27755#27755)中发现的。\n\n``` js\n    function getUrlParts (url) {\n      var magic = /^(https?):\\/\\/(ponyfoo\\.com)(\\/articles\\/([a-z0-9-]+))$/\n      return magic.exec(url)\n    }\n    var parts = getUrlParts('http://ponyfoo.com/articles/es6-destructuring-in-depth')\n    var [,protocol,host,pathname,slug] = parts\n    console.log(protocol)\n    // <- 'http'\n    console.log(host)\n    // <- 'ponyfoo.com'\n    console.log(pathname)\n    // <- '/articles/es6-destructuring-in-depth'\n    console.log(slug)\n    // <- 'es6-destructuring-in-depth'\n```\n\n特殊的情景：`import`语句\n尽管`import`语句不遵从解构的规则，但是表现有点类似。这可能是我使用的比较多的跟结构类似的场景, 尽管不是真正的解构。当你使用`import`你可以从一个模块暴露的API中获取任何你需要的值。一个使用[`contra`](https://github.com/bevacqua/contra)的例子：\n\n``` js\n    import {series, concurrent, map } from 'contra'\n    series(tasks, done)\n    concurrent(tasks, done)\n    map(items, mapper, done)\n```\n\n注意，尽管，`import`语句有不同的语法，当对比解构，下列`import`声明没有一个是有效的。\n- 使用默认的值类似于 `import { series = noop } from 'contra'` \n- 深度解构雷类似于`import {map: { series }} from 'contra'`\n- 别名语法`import {map: mapAsync} from 'contra'`\n\n以上限制的主要的原因是`import`声明自带绑定的，不是引用或者值，这是非常重要的区别，我们将在之后的`in depth`关于ES6 modules的文章探讨。\n","source":"_posts/es6-destructuring-in-depth.md","raw":"---\ntitle: (译)ES6 JavaScript Destructuring in Depth \ndate: 2015/11/8 19:21:25\ncategories:\n- Shit Done\ntags:\n- ES6\n- Destructuring\n---\n\n> [原文地址](https://ponyfoo.com/articles/es6-destructuring-in-depth#special-case-import-statements)\n\n这篇文章将专注于讨论ES6中的语言特性。以ES6中的最为有用，同时也存在一些陷阱的解构开始，我们之后将开一个系列文章来讨论ES6。\n#### 简短的声明\n\n当在不确定和有选择的情况下，你可能还是应该使用ES5和老的语法而不是因为你知道ES6就是用ES6。然而我并不是说是用ES6的语法是一种错误的方法--恰恰相反，你正看到我写关于ES6的文章。我提倡的是基于这样一个事实，确定她一定能提高我们代码的质量的时候才使用ES6, 而仅仅是因为她时一个`酷玩意儿`--虽然她是。\n\n到目前为止，我所说的观点是用ES5来写东西，加上一些ES6的语法糖在上面将确切的改善我的代码。我推测在不久后我能快速的意识到某些场景下使用ES6是优于ES5的，但是在目前紧跟着学习她是一个不错的主意，而不要走得太极端。谨慎分析什么是最适合你的代码，并且心里记着可以有ES6这个新的选择就行。\n\n> 这样，你将懂得怎样将新的特性学以致用，而不只是学学语法。\n\n现在就来看看ES6中的新特性把！\n#### 解构\n\n这是ES6中最简单，也是我使用的最多的一个特性。她可以绑定属性到你需要的任意多的变量上面，并且她支持数组和对象。\n\n``` js\n    var foo = { bar: 'pony', baz: 3}\n    var { bar, baz } = foo\n    console.log(bar)  //<- 'pony'\n    console.log(baz)  //<- 'baz'\n```\n\n 她可以十分高效的将指定属性从一个对象中解构出来。你也可以使用映射属性到一个别名。\n\n``` js\n    var foo = {bar: 'pony', baz: 3}\n    var {bar: a, baz: b} = foo \n    console.log(a) //<- 'pony'\n    console.log(b)  //<- '3'\n```\n\n你也可以把属性放到任意深的位置，并且完成别名的绑定。\n\n``` js\n    var foo = { bar: {deep: 'pony', dangerouslySetInnerHTML: 'lol'}}\n    var { bar: {deep, dangerouslySetInnerHTML: sure} } = foo\n    console.log(deep)  //<- 'pony'\n    console.log(sure)  //<- 'lol'\n```\n\n默认的，没有找到的对应的属性的值将使`undefined`,  就像你通过`.`或者`[]`访问一个对象中不存在的属性一样。\n\n``` js\n    var { foo } = {bar: 'baz'}\n    console.log(foo)  //<- undefined\n```\n\n如果尝试去访问对象一个不存在的深嵌套的属性，将会得到一个异常。\n\n``` js\n    var {foo: {bar}} = {baz: 'ouch'} //<- Exception  Cannot read property 'bar' of undefined\n```\n\n如果你知道她只是在ES5上进行了一层语法的包装，你将好理解很多\n\n``` js\n    var _tmp = { baz: 'ouch' }\n    var bar = _temp.foo.bar //<- Exception\n```\n\n解构有个非常酷的特性她允许你不用通过中间变量来交换变量之间的值。\n\n``` js\n    function es5() {\n        var left = 10\n        var right = 20\n        var aux\n        if (right > left) {\n            aux = right\n            right = left\n            left = aux\n        }\n    }\n\n    function es6() {\n        var left = 10\n        var right = 20\n        var aux\n        if (right > left ) {\n            [ right, left ] = [ left, right ]\n        }\n    }\n```\n\n另外一个方便的部分是解构可以让`keys`[使用表达式](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names)。\n\n``` js\n    var key = 'such_dynamic'\n    var [ [key]: foo ] = { such_dynamic: 'bar' }\n    console.log(foo) //<- 'bar'\n```\n\n在ES5中，你要实现的话需要而外的语句和变量声明\n\n``` js\n    var key = 'such_dynamic'\n    var baz = { such_dynamic: 'bar'}\n    var foo = baz[key]\n    console.log(foo)\n```\n\n你可以为变量指定默认值，当解构出来的属性值为`undefined`的时候，比较有用。\n\n``` js\n    var { foo = 3 } = { foo : 2 }\n    console.log(foo) //<- 2\n\n    var { foo = 3 } = { foo: undefined }\n    console.log(foo) //<- 3\n\n    var { foo = 3 } = { bar: 2 }\n    console.log(foo) //<- 3\n```\n\n解构同样对数组有效，且看我用中括号在声明语句中解构数组\n\n``` js\n    var [a] = [10]\n    console.log(a) //<- 10\n```\n\n并且我们同样可以使用相同的规则指定默认值\n\n``` js\n    var [a] = []\n    console.log(a)  //<- undefined\n    var [b = 10] = [undefined]\n    console.log(b) //<- 10\n\n    var [c = 10] = []\n    console.log(c) //<- 10\n```\n\n当是数组的时候你还可以方便的忽略某些你不关心的元素\n\n``` js\n    var [,,a, b] = [1, 2, 3, 4, 5]\n    console.log(a) //<- 3\n    console.log(b)  //<- 4\n```\n\n同样你可以在函数的参数列表中使用解构\n\n``` js\n    function greet ({age, name:greeting='she'}) {\n        consol.log(`${greeting} is ${age} years old.`)\n    }\n    greet({name: 'nico', age: 27}) //<- 'nico is 27 years old'\n\n    greet({age: 24}) //<- 'she is 24 years old'\n```\n\n以上是你可以怎样使用解构的一个粗略的介绍，那解构一般用于什么场景呢？\n#### 解构的使用场景\n\n解构用各种使用场景，这个是最常见的一个，当你有个返回对象的方法时，解构可以通过十分简便的方法提取返回值\n\n``` js\n    function getCoords () {\n        return {\n             x: 10, \n             y: 22\n         }\n    }\n    var {x, y} = getCoords()\n    console.log(x) //<- 10\n    console.log(y) //<- 20\n```\n\n另一个相似的但是相反的是使用结构为函数的一大串参数定义默认值，这个十分有趣，她实现了在其他语言如`Python` 和`C#`中的命名参数。\n\n``` js\n    function random ({ min = 1, max = 30 }) {\n        return Math.floor(Math.random() * (max - min)) + min\n    }\n    console.log(random({}))  //<- 174\n    console.log(random({max:24})) //<- 18\n```\n\n如果你想让形参完全是可选的，你可以改变写法如下\n\n``` js\n    function random({min = 1, max =300 } = {}) {\n        return Math.floor(Math.random() * (max - min)) + min \n    }\n    console.log(random()) //<- 133\n```\n\n解构还非常适用在正则表达式中，当你想给一些缺乏索引的值指定变量的时候，这里有一个解析URL的随机正则的例子，我在[StackOverflow](http://stackoverflow.com/questions/27745/getting-parts-of-a-url-regex/27755#27755)中发现的。\n\n``` js\n    function getUrlParts (url) {\n      var magic = /^(https?):\\/\\/(ponyfoo\\.com)(\\/articles\\/([a-z0-9-]+))$/\n      return magic.exec(url)\n    }\n    var parts = getUrlParts('http://ponyfoo.com/articles/es6-destructuring-in-depth')\n    var [,protocol,host,pathname,slug] = parts\n    console.log(protocol)\n    // <- 'http'\n    console.log(host)\n    // <- 'ponyfoo.com'\n    console.log(pathname)\n    // <- '/articles/es6-destructuring-in-depth'\n    console.log(slug)\n    // <- 'es6-destructuring-in-depth'\n```\n\n特殊的情景：`import`语句\n尽管`import`语句不遵从解构的规则，但是表现有点类似。这可能是我使用的比较多的跟结构类似的场景, 尽管不是真正的解构。当你使用`import`你可以从一个模块暴露的API中获取任何你需要的值。一个使用[`contra`](https://github.com/bevacqua/contra)的例子：\n\n``` js\n    import {series, concurrent, map } from 'contra'\n    series(tasks, done)\n    concurrent(tasks, done)\n    map(items, mapper, done)\n```\n\n注意，尽管，`import`语句有不同的语法，当对比解构，下列`import`声明没有一个是有效的。\n- 使用默认的值类似于 `import { series = noop } from 'contra'` \n- 深度解构雷类似于`import {map: { series }} from 'contra'`\n- 别名语法`import {map: mapAsync} from 'contra'`\n\n以上限制的主要的原因是`import`声明自带绑定的，不是引用或者值，这是非常重要的区别，我们将在之后的`in depth`关于ES6 modules的文章探讨。\n","slug":"es6-destructuring-in-depth","published":1,"updated":"2018-08-05T04:48:02.483Z","_id":"cjkgczodv003iue8ico43j6fo","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p><a href=\"https://ponyfoo.com/articles/es6-destructuring-in-depth#special-case-import-statements\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n</blockquote>\n<p>这篇文章将专注于讨论ES6中的语言特性。以ES6中的最为有用，同时也存在一些陷阱的解构开始，我们之后将开一个系列文章来讨论ES6。</p>\n<h4 id=\"简短的声明\"><a href=\"#简短的声明\" class=\"headerlink\" title=\"简短的声明\"></a>简短的声明</h4><p>当在不确定和有选择的情况下，你可能还是应该使用ES5和老的语法而不是因为你知道ES6就是用ES6。然而我并不是说是用ES6的语法是一种错误的方法–恰恰相反，你正看到我写关于ES6的文章。我提倡的是基于这样一个事实，确定她一定能提高我们代码的质量的时候才使用ES6, 而仅仅是因为她时一个<code>酷玩意儿</code>–虽然她是。</p>\n<p>到目前为止，我所说的观点是用ES5来写东西，加上一些ES6的语法糖在上面将确切的改善我的代码。我推测在不久后我能快速的意识到某些场景下使用ES6是优于ES5的，但是在目前紧跟着学习她是一个不错的主意，而不要走得太极端。谨慎分析什么是最适合你的代码，并且心里记着可以有ES6这个新的选择就行。</p>\n<blockquote>\n<p>这样，你将懂得怎样将新的特性学以致用，而不只是学学语法。</p>\n</blockquote>\n<p>现在就来看看ES6中的新特性把！</p>\n<h4 id=\"解构\"><a href=\"#解构\" class=\"headerlink\" title=\"解构\"></a>解构</h4><p>这是ES6中最简单，也是我使用的最多的一个特性。她可以绑定属性到你需要的任意多的变量上面，并且她支持数组和对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123; <span class=\"attr\">bar</span>: <span class=\"string\">'pony'</span>, <span class=\"attr\">baz</span>: <span class=\"number\">3</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123; bar, baz &#125; = foo</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar)  <span class=\"comment\">//&lt;- 'pony'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(baz)  <span class=\"comment\">//&lt;- 'baz'</span></span><br></pre></td></tr></table></figure>\n<p> 她可以十分高效的将指定属性从一个对象中解构出来。你也可以使用映射属性到一个别名。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;<span class=\"attr\">bar</span>: <span class=\"string\">'pony'</span>, <span class=\"attr\">baz</span>: <span class=\"number\">3</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123;<span class=\"attr\">bar</span>: a, <span class=\"attr\">baz</span>: b&#125; = foo </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">//&lt;- 'pony'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b)  <span class=\"comment\">//&lt;- '3'</span></span><br></pre></td></tr></table></figure>\n<p>你也可以把属性放到任意深的位置，并且完成别名的绑定。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123; <span class=\"attr\">bar</span>: &#123;<span class=\"attr\">deep</span>: <span class=\"string\">'pony'</span>, <span class=\"attr\">dangerouslySetInnerHTML</span>: <span class=\"string\">'lol'</span>&#125;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123; <span class=\"attr\">bar</span>: &#123;deep, <span class=\"attr\">dangerouslySetInnerHTML</span>: sure&#125; &#125; = foo</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(deep)  <span class=\"comment\">//&lt;- 'pony'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sure)  <span class=\"comment\">//&lt;- 'lol'</span></span><br></pre></td></tr></table></figure>\n<p>默认的，没有找到的对应的属性的值将使<code>undefined</code>,  就像你通过<code>.</code>或者<code>[]</code>访问一个对象中不存在的属性一样。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> &#123; foo &#125; = &#123;<span class=\"attr\">bar</span>: <span class=\"string\">'baz'</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo)  <span class=\"comment\">//&lt;- undefined</span></span><br></pre></td></tr></table></figure>\n<p>如果尝试去访问对象一个不存在的深嵌套的属性，将会得到一个异常。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> &#123;<span class=\"attr\">foo</span>: &#123;bar&#125;&#125; = &#123;<span class=\"attr\">baz</span>: <span class=\"string\">'ouch'</span>&#125; <span class=\"comment\">//&lt;- Exception  Cannot read property 'bar' of undefined</span></span><br></pre></td></tr></table></figure>\n<p>如果你知道她只是在ES5上进行了一层语法的包装，你将好理解很多</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> _tmp = &#123; <span class=\"attr\">baz</span>: <span class=\"string\">'ouch'</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = _temp.foo.bar <span class=\"comment\">//&lt;- Exception</span></span><br></pre></td></tr></table></figure>\n<p>解构有个非常酷的特性她允许你不用通过中间变量来交换变量之间的值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">es5</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> left = <span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> right = <span class=\"number\">20</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> aux</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (right &gt; left) &#123;</span><br><span class=\"line\">        aux = right</span><br><span class=\"line\">        right = left</span><br><span class=\"line\">        left = aux</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">es6</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> left = <span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> right = <span class=\"number\">20</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> aux</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (right &gt; left ) &#123;</span><br><span class=\"line\">        [ right, left ] = [ left, right ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另外一个方便的部分是解构可以让<code>keys</code><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names\" target=\"_blank\" rel=\"noopener\">使用表达式</a>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> key = <span class=\"string\">'such_dynamic'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> [ [key]: foo ] = &#123; <span class=\"attr\">such_dynamic</span>: <span class=\"string\">'bar'</span> &#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo) <span class=\"comment\">//&lt;- 'bar'</span></span><br></pre></td></tr></table></figure>\n<p>在ES5中，你要实现的话需要而外的语句和变量声明</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> key = <span class=\"string\">'such_dynamic'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> baz = &#123; <span class=\"attr\">such_dynamic</span>: <span class=\"string\">'bar'</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = baz[key]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo)</span><br></pre></td></tr></table></figure>\n<p>你可以为变量指定默认值，当解构出来的属性值为<code>undefined</code>的时候，比较有用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> &#123; foo = <span class=\"number\">3</span> &#125; = &#123; <span class=\"attr\">foo</span> : <span class=\"number\">2</span> &#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo) <span class=\"comment\">//&lt;- 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123; foo = <span class=\"number\">3</span> &#125; = &#123; <span class=\"attr\">foo</span>: <span class=\"literal\">undefined</span> &#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo) <span class=\"comment\">//&lt;- 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123; foo = <span class=\"number\">3</span> &#125; = &#123; <span class=\"attr\">bar</span>: <span class=\"number\">2</span> &#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo) <span class=\"comment\">//&lt;- 3</span></span><br></pre></td></tr></table></figure>\n<p>解构同样对数组有效，且看我用中括号在声明语句中解构数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> [a] = [<span class=\"number\">10</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">//&lt;- 10</span></span><br></pre></td></tr></table></figure>\n<p>并且我们同样可以使用相同的规则指定默认值</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> [a] = []</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a)  <span class=\"comment\">//&lt;- undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> [b = <span class=\"number\">10</span>] = [<span class=\"literal\">undefined</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b) <span class=\"comment\">//&lt;- 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> [c = <span class=\"number\">10</span>] = []</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(c) <span class=\"comment\">//&lt;- 10</span></span><br></pre></td></tr></table></figure>\n<p>当是数组的时候你还可以方便的忽略某些你不关心的元素</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> [,,a, b] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">//&lt;- 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b)  <span class=\"comment\">//&lt;- 4</span></span><br></pre></td></tr></table></figure>\n<p>同样你可以在函数的参数列表中使用解构</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greet</span> (<span class=\"params\">&#123;age, name:greeting=<span class=\"string\">'she'</span>&#125;</span>) </span>&#123;</span><br><span class=\"line\">    consol.log(<span class=\"string\">`<span class=\"subst\">$&#123;greeting&#125;</span> is <span class=\"subst\">$&#123;age&#125;</span> years old.`</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">greet(&#123;<span class=\"attr\">name</span>: <span class=\"string\">'nico'</span>, <span class=\"attr\">age</span>: <span class=\"number\">27</span>&#125;) <span class=\"comment\">//&lt;- 'nico is 27 years old'</span></span><br><span class=\"line\"></span><br><span class=\"line\">greet(&#123;<span class=\"attr\">age</span>: <span class=\"number\">24</span>&#125;) <span class=\"comment\">//&lt;- 'she is 24 years old'</span></span><br></pre></td></tr></table></figure>\n<p>以上是你可以怎样使用解构的一个粗略的介绍，那解构一般用于什么场景呢？</p>\n<h4 id=\"解构的使用场景\"><a href=\"#解构的使用场景\" class=\"headerlink\" title=\"解构的使用场景\"></a>解构的使用场景</h4><p>解构用各种使用场景，这个是最常见的一个，当你有个返回对象的方法时，解构可以通过十分简便的方法提取返回值</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getCoords</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">         x: <span class=\"number\">10</span>, </span><br><span class=\"line\">         y: <span class=\"number\">22</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123;x, y&#125; = getCoords()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x) <span class=\"comment\">//&lt;- 10</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(y) <span class=\"comment\">//&lt;- 20</span></span><br></pre></td></tr></table></figure>\n<p>另一个相似的但是相反的是使用结构为函数的一大串参数定义默认值，这个十分有趣，她实现了在其他语言如<code>Python</code> 和<code>C#</code>中的命名参数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">random</span> (<span class=\"params\">&#123; min = <span class=\"number\">1</span>, max = <span class=\"number\">30</span> &#125;</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * (max - min)) + min</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(random(&#123;&#125;))  <span class=\"comment\">//&lt;- 174</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(random(&#123;<span class=\"attr\">max</span>:<span class=\"number\">24</span>&#125;)) <span class=\"comment\">//&lt;- 18</span></span><br></pre></td></tr></table></figure>\n<p>如果你想让形参完全是可选的，你可以改变写法如下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">random</span>(<span class=\"params\">&#123;min = <span class=\"number\">1</span>, max =<span class=\"number\">300</span> &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * (max - min)) + min </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(random()) <span class=\"comment\">//&lt;- 133</span></span><br></pre></td></tr></table></figure>\n<p>解构还非常适用在正则表达式中，当你想给一些缺乏索引的值指定变量的时候，这里有一个解析URL的随机正则的例子，我在<a href=\"http://stackoverflow.com/questions/27745/getting-parts-of-a-url-regex/27755#27755\" target=\"_blank\" rel=\"noopener\">StackOverflow</a>中发现的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUrlParts</span> (<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> magic = <span class=\"regexp\">/^(https?):\\/\\/(ponyfoo\\.com)(\\/articles\\/([a-z0-9-]+))$/</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> magic.exec(url)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> parts = getUrlParts(<span class=\"string\">'http://ponyfoo.com/articles/es6-destructuring-in-depth'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> [,protocol,host,pathname,slug] = parts</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(protocol)</span><br><span class=\"line\"><span class=\"comment\">// &lt;- 'http'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(host)</span><br><span class=\"line\"><span class=\"comment\">// &lt;- 'ponyfoo.com'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(pathname)</span><br><span class=\"line\"><span class=\"comment\">// &lt;- '/articles/es6-destructuring-in-depth'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(slug)</span><br><span class=\"line\"><span class=\"comment\">// &lt;- 'es6-destructuring-in-depth'</span></span><br></pre></td></tr></table></figure>\n<p>特殊的情景：<code>import</code>语句<br>尽管<code>import</code>语句不遵从解构的规则，但是表现有点类似。这可能是我使用的比较多的跟结构类似的场景, 尽管不是真正的解构。当你使用<code>import</code>你可以从一个模块暴露的API中获取任何你需要的值。一个使用<a href=\"https://github.com/bevacqua/contra\" target=\"_blank\" rel=\"noopener\"><code>contra</code></a>的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;series, concurrent, map &#125; <span class=\"keyword\">from</span> <span class=\"string\">'contra'</span></span><br><span class=\"line\">series(tasks, done)</span><br><span class=\"line\">concurrent(tasks, done)</span><br><span class=\"line\">map(items, mapper, done)</span><br></pre></td></tr></table></figure>\n<p>注意，尽管，<code>import</code>语句有不同的语法，当对比解构，下列<code>import</code>声明没有一个是有效的。</p>\n<ul>\n<li>使用默认的值类似于 <code>import { series = noop } from &#39;contra&#39;</code> </li>\n<li>深度解构雷类似于<code>import {map: { series }} from &#39;contra&#39;</code></li>\n<li>别名语法<code>import {map: mapAsync} from &#39;contra&#39;</code></li>\n</ul>\n<p>以上限制的主要的原因是<code>import</code>声明自带绑定的，不是引用或者值，这是非常重要的区别，我们将在之后的<code>in depth</code>关于ES6 modules的文章探讨。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><a href=\"https://ponyfoo.com/articles/es6-destructuring-in-depth#special-case-import-statements\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n</blockquote>\n<p>这篇文章将专注于讨论ES6中的语言特性。以ES6中的最为有用，同时也存在一些陷阱的解构开始，我们之后将开一个系列文章来讨论ES6。</p>\n<h4 id=\"简短的声明\"><a href=\"#简短的声明\" class=\"headerlink\" title=\"简短的声明\"></a>简短的声明</h4><p>当在不确定和有选择的情况下，你可能还是应该使用ES5和老的语法而不是因为你知道ES6就是用ES6。然而我并不是说是用ES6的语法是一种错误的方法–恰恰相反，你正看到我写关于ES6的文章。我提倡的是基于这样一个事实，确定她一定能提高我们代码的质量的时候才使用ES6, 而仅仅是因为她时一个<code>酷玩意儿</code>–虽然她是。</p>\n<p>到目前为止，我所说的观点是用ES5来写东西，加上一些ES6的语法糖在上面将确切的改善我的代码。我推测在不久后我能快速的意识到某些场景下使用ES6是优于ES5的，但是在目前紧跟着学习她是一个不错的主意，而不要走得太极端。谨慎分析什么是最适合你的代码，并且心里记着可以有ES6这个新的选择就行。</p>\n<blockquote>\n<p>这样，你将懂得怎样将新的特性学以致用，而不只是学学语法。</p>\n</blockquote>\n<p>现在就来看看ES6中的新特性把！</p>\n<h4 id=\"解构\"><a href=\"#解构\" class=\"headerlink\" title=\"解构\"></a>解构</h4><p>这是ES6中最简单，也是我使用的最多的一个特性。她可以绑定属性到你需要的任意多的变量上面，并且她支持数组和对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123; <span class=\"attr\">bar</span>: <span class=\"string\">'pony'</span>, <span class=\"attr\">baz</span>: <span class=\"number\">3</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123; bar, baz &#125; = foo</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar)  <span class=\"comment\">//&lt;- 'pony'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(baz)  <span class=\"comment\">//&lt;- 'baz'</span></span><br></pre></td></tr></table></figure>\n<p> 她可以十分高效的将指定属性从一个对象中解构出来。你也可以使用映射属性到一个别名。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;<span class=\"attr\">bar</span>: <span class=\"string\">'pony'</span>, <span class=\"attr\">baz</span>: <span class=\"number\">3</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123;<span class=\"attr\">bar</span>: a, <span class=\"attr\">baz</span>: b&#125; = foo </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">//&lt;- 'pony'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b)  <span class=\"comment\">//&lt;- '3'</span></span><br></pre></td></tr></table></figure>\n<p>你也可以把属性放到任意深的位置，并且完成别名的绑定。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123; <span class=\"attr\">bar</span>: &#123;<span class=\"attr\">deep</span>: <span class=\"string\">'pony'</span>, <span class=\"attr\">dangerouslySetInnerHTML</span>: <span class=\"string\">'lol'</span>&#125;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123; <span class=\"attr\">bar</span>: &#123;deep, <span class=\"attr\">dangerouslySetInnerHTML</span>: sure&#125; &#125; = foo</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(deep)  <span class=\"comment\">//&lt;- 'pony'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sure)  <span class=\"comment\">//&lt;- 'lol'</span></span><br></pre></td></tr></table></figure>\n<p>默认的，没有找到的对应的属性的值将使<code>undefined</code>,  就像你通过<code>.</code>或者<code>[]</code>访问一个对象中不存在的属性一样。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> &#123; foo &#125; = &#123;<span class=\"attr\">bar</span>: <span class=\"string\">'baz'</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo)  <span class=\"comment\">//&lt;- undefined</span></span><br></pre></td></tr></table></figure>\n<p>如果尝试去访问对象一个不存在的深嵌套的属性，将会得到一个异常。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> &#123;<span class=\"attr\">foo</span>: &#123;bar&#125;&#125; = &#123;<span class=\"attr\">baz</span>: <span class=\"string\">'ouch'</span>&#125; <span class=\"comment\">//&lt;- Exception  Cannot read property 'bar' of undefined</span></span><br></pre></td></tr></table></figure>\n<p>如果你知道她只是在ES5上进行了一层语法的包装，你将好理解很多</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> _tmp = &#123; <span class=\"attr\">baz</span>: <span class=\"string\">'ouch'</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = _temp.foo.bar <span class=\"comment\">//&lt;- Exception</span></span><br></pre></td></tr></table></figure>\n<p>解构有个非常酷的特性她允许你不用通过中间变量来交换变量之间的值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">es5</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> left = <span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> right = <span class=\"number\">20</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> aux</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (right &gt; left) &#123;</span><br><span class=\"line\">        aux = right</span><br><span class=\"line\">        right = left</span><br><span class=\"line\">        left = aux</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">es6</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> left = <span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> right = <span class=\"number\">20</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> aux</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (right &gt; left ) &#123;</span><br><span class=\"line\">        [ right, left ] = [ left, right ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另外一个方便的部分是解构可以让<code>keys</code><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names\" target=\"_blank\" rel=\"noopener\">使用表达式</a>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> key = <span class=\"string\">'such_dynamic'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> [ [key]: foo ] = &#123; <span class=\"attr\">such_dynamic</span>: <span class=\"string\">'bar'</span> &#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo) <span class=\"comment\">//&lt;- 'bar'</span></span><br></pre></td></tr></table></figure>\n<p>在ES5中，你要实现的话需要而外的语句和变量声明</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> key = <span class=\"string\">'such_dynamic'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> baz = &#123; <span class=\"attr\">such_dynamic</span>: <span class=\"string\">'bar'</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = baz[key]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo)</span><br></pre></td></tr></table></figure>\n<p>你可以为变量指定默认值，当解构出来的属性值为<code>undefined</code>的时候，比较有用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> &#123; foo = <span class=\"number\">3</span> &#125; = &#123; <span class=\"attr\">foo</span> : <span class=\"number\">2</span> &#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo) <span class=\"comment\">//&lt;- 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123; foo = <span class=\"number\">3</span> &#125; = &#123; <span class=\"attr\">foo</span>: <span class=\"literal\">undefined</span> &#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo) <span class=\"comment\">//&lt;- 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123; foo = <span class=\"number\">3</span> &#125; = &#123; <span class=\"attr\">bar</span>: <span class=\"number\">2</span> &#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo) <span class=\"comment\">//&lt;- 3</span></span><br></pre></td></tr></table></figure>\n<p>解构同样对数组有效，且看我用中括号在声明语句中解构数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> [a] = [<span class=\"number\">10</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">//&lt;- 10</span></span><br></pre></td></tr></table></figure>\n<p>并且我们同样可以使用相同的规则指定默认值</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> [a] = []</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a)  <span class=\"comment\">//&lt;- undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> [b = <span class=\"number\">10</span>] = [<span class=\"literal\">undefined</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b) <span class=\"comment\">//&lt;- 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> [c = <span class=\"number\">10</span>] = []</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(c) <span class=\"comment\">//&lt;- 10</span></span><br></pre></td></tr></table></figure>\n<p>当是数组的时候你还可以方便的忽略某些你不关心的元素</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> [,,a, b] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">//&lt;- 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b)  <span class=\"comment\">//&lt;- 4</span></span><br></pre></td></tr></table></figure>\n<p>同样你可以在函数的参数列表中使用解构</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greet</span> (<span class=\"params\">&#123;age, name:greeting=<span class=\"string\">'she'</span>&#125;</span>) </span>&#123;</span><br><span class=\"line\">    consol.log(<span class=\"string\">`<span class=\"subst\">$&#123;greeting&#125;</span> is <span class=\"subst\">$&#123;age&#125;</span> years old.`</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">greet(&#123;<span class=\"attr\">name</span>: <span class=\"string\">'nico'</span>, <span class=\"attr\">age</span>: <span class=\"number\">27</span>&#125;) <span class=\"comment\">//&lt;- 'nico is 27 years old'</span></span><br><span class=\"line\"></span><br><span class=\"line\">greet(&#123;<span class=\"attr\">age</span>: <span class=\"number\">24</span>&#125;) <span class=\"comment\">//&lt;- 'she is 24 years old'</span></span><br></pre></td></tr></table></figure>\n<p>以上是你可以怎样使用解构的一个粗略的介绍，那解构一般用于什么场景呢？</p>\n<h4 id=\"解构的使用场景\"><a href=\"#解构的使用场景\" class=\"headerlink\" title=\"解构的使用场景\"></a>解构的使用场景</h4><p>解构用各种使用场景，这个是最常见的一个，当你有个返回对象的方法时，解构可以通过十分简便的方法提取返回值</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getCoords</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">         x: <span class=\"number\">10</span>, </span><br><span class=\"line\">         y: <span class=\"number\">22</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123;x, y&#125; = getCoords()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x) <span class=\"comment\">//&lt;- 10</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(y) <span class=\"comment\">//&lt;- 20</span></span><br></pre></td></tr></table></figure>\n<p>另一个相似的但是相反的是使用结构为函数的一大串参数定义默认值，这个十分有趣，她实现了在其他语言如<code>Python</code> 和<code>C#</code>中的命名参数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">random</span> (<span class=\"params\">&#123; min = <span class=\"number\">1</span>, max = <span class=\"number\">30</span> &#125;</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * (max - min)) + min</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(random(&#123;&#125;))  <span class=\"comment\">//&lt;- 174</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(random(&#123;<span class=\"attr\">max</span>:<span class=\"number\">24</span>&#125;)) <span class=\"comment\">//&lt;- 18</span></span><br></pre></td></tr></table></figure>\n<p>如果你想让形参完全是可选的，你可以改变写法如下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">random</span>(<span class=\"params\">&#123;min = <span class=\"number\">1</span>, max =<span class=\"number\">300</span> &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * (max - min)) + min </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(random()) <span class=\"comment\">//&lt;- 133</span></span><br></pre></td></tr></table></figure>\n<p>解构还非常适用在正则表达式中，当你想给一些缺乏索引的值指定变量的时候，这里有一个解析URL的随机正则的例子，我在<a href=\"http://stackoverflow.com/questions/27745/getting-parts-of-a-url-regex/27755#27755\" target=\"_blank\" rel=\"noopener\">StackOverflow</a>中发现的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUrlParts</span> (<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> magic = <span class=\"regexp\">/^(https?):\\/\\/(ponyfoo\\.com)(\\/articles\\/([a-z0-9-]+))$/</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> magic.exec(url)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> parts = getUrlParts(<span class=\"string\">'http://ponyfoo.com/articles/es6-destructuring-in-depth'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> [,protocol,host,pathname,slug] = parts</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(protocol)</span><br><span class=\"line\"><span class=\"comment\">// &lt;- 'http'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(host)</span><br><span class=\"line\"><span class=\"comment\">// &lt;- 'ponyfoo.com'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(pathname)</span><br><span class=\"line\"><span class=\"comment\">// &lt;- '/articles/es6-destructuring-in-depth'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(slug)</span><br><span class=\"line\"><span class=\"comment\">// &lt;- 'es6-destructuring-in-depth'</span></span><br></pre></td></tr></table></figure>\n<p>特殊的情景：<code>import</code>语句<br>尽管<code>import</code>语句不遵从解构的规则，但是表现有点类似。这可能是我使用的比较多的跟结构类似的场景, 尽管不是真正的解构。当你使用<code>import</code>你可以从一个模块暴露的API中获取任何你需要的值。一个使用<a href=\"https://github.com/bevacqua/contra\" target=\"_blank\" rel=\"noopener\"><code>contra</code></a>的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;series, concurrent, map &#125; <span class=\"keyword\">from</span> <span class=\"string\">'contra'</span></span><br><span class=\"line\">series(tasks, done)</span><br><span class=\"line\">concurrent(tasks, done)</span><br><span class=\"line\">map(items, mapper, done)</span><br></pre></td></tr></table></figure>\n<p>注意，尽管，<code>import</code>语句有不同的语法，当对比解构，下列<code>import</code>声明没有一个是有效的。</p>\n<ul>\n<li>使用默认的值类似于 <code>import { series = noop } from &#39;contra&#39;</code> </li>\n<li>深度解构雷类似于<code>import {map: { series }} from &#39;contra&#39;</code></li>\n<li>别名语法<code>import {map: mapAsync} from &#39;contra&#39;</code></li>\n</ul>\n<p>以上限制的主要的原因是<code>import</code>声明自带绑定的，不是引用或者值，这是非常重要的区别，我们将在之后的<code>in depth</code>关于ES6 modules的文章探讨。</p>\n"},{"title":"(译)ES6 Spread and Butter in Depth","date":"2015-10-30T04:01:25.000Z","_content":"> [原文地址](https://ponyfoo.com/articles/es6-spread-and-butter-in-depth#rest-parameters)\n\n我们在讨论[解构]()的时候已经涉及到了一部分今天的内容。这篇将比其他的内容短一些，因为简单的特性没有太多可以说的。尽管如此，就像我在[ES6 in Depth](https://ponyfoo.com/articles/tagged/es6-in-depth)系统中说的，最简单的特性往往也[最有用](https://github.com/rockcoder23/blog.fexnotes.com/issues/24)，让我们来看看把。\n### Rest 参数\n\n你知道有时候函数有一大堆的参数，你最终不得不用`arguments` 魔法变量来处理他们。考虑下面这样把任意传入的参数的链接为字符串的方法。\n\n``` js\n    function concat() {\n        return Array.prototype.slice.call(arguments).join(' ')\n    }\n    var result = concat('this', 'was', 'no', 'fun')\n    console.log(result)  //<- 'this was no fun'\n```\n\nrest参数语法通过添加`...`在参数名的前面能够让你生成一个包含`function`参数的真实的`Array` 。语法十分的简单，事实上一个真实的数组使用起来也十分的方便。对于我来说我很高兴再也不需要借助于`arguments`了。\n\n``` js\n    function concat (...word) {\n     return word.join(' ')\n    }\n    var result = concat('this', 'is', 'okay')\n    console.log(result); //<- 'this is okay'\n```\n\n当你的`function`有更多的参数的时候略微有一些不同。不管什么时候我声明一个带有rest参数的方法的时候，我会考虑下面几点。\n- Rest 参数将包含所有调用函数的`arguments`。\n- 每次在函数的左边添加一个参数，对于Rest参数形成的数组来说就像调用了rest.shift()。\n- 注意你不允许把参数放到Rest参数的右边，Rest参数只能是最后一个参数。\n\n要形象化的描述这个最好是通过实践，而不是一句话的总结。下面这个方法将计算除了第一个参数(用来乘以后面的参数和)，剩余参数的和。为了不重复的调用函数，`.shift()`移除并且返回数组中的第一个参数，把函数变得类似一个有记忆的设备一样。\n\n``` js\n    function sum(){\n        var number = Array.prototype.slice.call(arguments) //numbers gets all arguments\n        var multiplier = numbers.shift()\n        var base = numbers.shift()\n        var sum = numbers.reduce((accumulator, num) => accumulator + num, base) \n        return multiplier * sum\n    }\n    var total = sum(2,  6,  10,  8,  9)\n    console.log(total)  //<- 66\n```\n\n下面是我们使用rest 参数改造之后的函数的样子，注意我们没有使用`arguments` 也没有再使用shifting。 这将相当赞因为这极大的减小我们函数的复杂度，这样我们将能更专注于它本身的功能而不是更多在处理`arguments`。\n\n``` js\n    function sum(multiplier, base, ...numbers) {\n        var sum = numbers.reduce((accumulator, num) => accumulator + num, base)\n        return multiplier * sum\n    }\n    var total = sum(2, 6, 10, 8, 9)\n    console.log(total) //<- 66\n```\n### 扩展运算符\n\n通常你通过传递参数来调用一个方法。\n\n``` js\n    console.log(1, 2, 3) //<- '1 2 3'\n```\n\n有时你有一些参数是放在一个列表中但是你又不想为了一次函数调用而使用索引来获取，或者这个列表是动态的生产的你根本不能这样获取。所以你一般会使用`.apply()`。这让你觉得不是很方便，因为`.apply`需要指定一个上下文`this`,而你得传入一个或许就不相关的对象(类似 `null`)。\n\n``` js\n    console.log(console, [1, 2, 3])  //<- '1, 2, 3'\n```\n\n扩展运算符可以被当做`.apply`的替代品(原文：butter knife, 黄油刀 Orz..) 。也不需要指定上下文，你只需要在数组前面使用`...` ，就像rest参数一样。\n\n``` js\n    console.log(...[1, 2, 3]) //<- '1, 2, 3'\n```\n\n其实扩展运算符可以用在任何事先iterable接口的对象上，这在我们下周一将要讨论的`iterators`特性中会有更好的补充，甚至能作用在`document.querySelectorAll('div')`的结果。\n\n``` js\n    [...document.querySelectorAll('div')] //<-[<div>, <div>, <div>]\n```\n\n另一个更好的方面是你可以混合搭配正常的参数，并且他们可以按你预期的那样执行。这在你处理有很多的参数的es5代码时非常有用。\n\n``` js\n        console.log(1, ...[2, 3, 4], 5) //becomes `console。log(1，2，3，4，5) //<- '1 2 3 4 5'\n```\n\n是时候讨论个真实的例子了.我有时在Express中使用下面的方法让[`morgan`](https://github.com/expressjs/morgan)(记录Express中的请求日志)通过[`winston`](https://github.com/winstonjs/winston)列化它的数据，为了实现多点传输日志服务。我把换行符从字节流中移除并且赋给message，因为winston已经处理过了，而且我还把一些元数据包括进程id和ip放在了`arguments`中，最后我使用`.apply`来调用winston的处理方法。 如果你仔细查看下面的方法，你会发现真正起作用的是我黄色高亮的那句，而且其他的都是在处理`arguments`.\n\n``` js\n    function createWriteStream (level) {\n        return {\n            write: function(){\n                var bits = Array.prototype.slice.call(arguments)\n                var message = bits.shift().replace(/\\n+$/， '')\n                bits.unshift(message)\n                bits.push({hostname: os.hostname(), pid: process.pid})\n                winston[level].apply(winston, bits)   //上文提到的黄色高亮语句指得是这句\n            }\n        }\n    }\n    app.use(morgan(':status :method :url', {\n        stream.createWriteStream('debug')\n    }))\n```\n\n我们可以使用ES6来彻底简化这个代码，首先，我们可以使用rest 参数来代替`arguments`。rest参数已经给我们一个现成的数组，所以将没有变相的调用。我们可以提取message作为第一个参数，而且我们可以直接调用`winston[level]`通过结合正常参数和`...bits`。这时代码就变得有模有样了，而且每一部分都是跟你想要实现的功能相关，比如改了调用`winston[level]`调用的参数。这代码相比于之前手动维护arguments来说，实现了自我的救赎[原文：a battle of wits against JavaScript itself]。\n\n``` js\n\n    function createWriteStream(level) {\n        return {\n            write: function (message, ..bits) {\n                winston[level](message.replace(/\\n+$/, ''), ...bits, {\n                    hostname: os.hostname(), pid: process.pid\n                })\n            }\n        }\n    }\n```\n\n另一个方法再次精简我们的代码使用箭头函数. 但是在这个场景下，将会是代码理解起来更复杂。你可以使用`msg` 代替`message` 来实现让整个代码在一行，然后使用rest参数和扩展运算符来调用`winston[level]`，让它不论是你还是你的队友在一周之后再看这个代码不思考15分钟都难以理解这个方法的作用。\n\n``` js\n    var proc = {hostname: os.hostname(), pid: process.pid}\n    function createWriteStream (level) {\n        return {\n            write(msg, ...bits) => winston[level](msg,replace(/\\n+$/, ''), ...bits, proc)\n        }\n    }\n```\n\n保持上一版本的写法还是比较明智的选择，然而这很好的证明了在这个情形下使用箭头函数只会增加复杂性。在其他场景下可能不会。这完全取决于你，所以你得理智的使用ES6的特性，到底是为了提高你的代码的可维护性还是只是为了使用ES6而牺牲了代码的可维护性。\n\n下面列举了一些有用的用法，显然你可以使用扩展运算符来创建一个数组，但是你也使用解构，这有点类似...rest原理。有一个不是很常见但是很值得一提的场景是你可以使用扩展运算符来代替`apply`即使是使用`new`运算符的时候。\n\n| 场景 | ES5 | ES6 |\n| --- | --- | --- |\n| Concatenation | [1, 2].concat(more) | [1, 2, ...more] |\n| Push onto list | list.push.apply(list, [3, 4]) | list.push(...[3, 4]) |\n| Destructuring | a = list[0], rest = list.slice(1) | [a, ..rest] = list |\n| new + apply | new (Date.bind.apply(Date, [null, 2015, 31, 8])) | new Date(... [2015, 31, 8]) |\n### 默认赋值操作\n\n默认赋值操作我们在解构那边文章已经涉及到了，但是只是简单的介绍了下。就像你可以在解构中使用默认值一样，你可以为函数的任何参数指定一个默认值，就像下面展示的那样。\n\n``` js\n    function sum (left = 1, right = 2) {\n        return left + right \n    }\n    console.log(sum()) //<- 3\n    console.log(sum(2)) //<- 4\n    console.log(sum(1, 0)) //<- 1\n```\n\n考虑[`dragula`](https://github.com/bevacqua/dragula/blob/f5f4c569780b0db160269e978eaf69dc36e421bb/dragula.js#L27-L37)里面的初始化options的代码。\n\n``` js\n    function dragula (options) {\n        var o = options || {};\n        if (o.moves === void 0) { o.moves = always;}\n        if (o.accepts === void 0) { o.accepts = always; }\n        if (o.invalid === void 0) { o.invalid = invalidTarget; }\n        if (o.containers === void 0) { o.containers = initialContainers || []; }\n        if (o.isContainer === void 0) { o.isContainer = never; }\n        if (o.copy === void 0) { o.copy = false; }\n        if (o.revertOnSpill === void 0) { o.revertOnSpill = false; }\n        if (o.removeOnSpill === void 0) { o.removeOnSpill = false; }\n        if (o.direction === void 0) { o.direction = 'vertical'; }\n        if (o.mirrorContainer === void 0) { o.mirrorContainer = body; }\n    }\n```\n\n你认为是否值得使用ES6的默认赋值操作语法来重构这部分代码？你会怎么重构？\n","source":"_posts/es6-spread-and-buffer.md","raw":"---\ntitle: (译)ES6 Spread and Butter in Depth\ndate: 2015/10/30 12:01:25\ncategories:\n- Shit Done\ntags:\n- ES6\n- Spread\n- Buffer\n---\n> [原文地址](https://ponyfoo.com/articles/es6-spread-and-butter-in-depth#rest-parameters)\n\n我们在讨论[解构]()的时候已经涉及到了一部分今天的内容。这篇将比其他的内容短一些，因为简单的特性没有太多可以说的。尽管如此，就像我在[ES6 in Depth](https://ponyfoo.com/articles/tagged/es6-in-depth)系统中说的，最简单的特性往往也[最有用](https://github.com/rockcoder23/blog.fexnotes.com/issues/24)，让我们来看看把。\n### Rest 参数\n\n你知道有时候函数有一大堆的参数，你最终不得不用`arguments` 魔法变量来处理他们。考虑下面这样把任意传入的参数的链接为字符串的方法。\n\n``` js\n    function concat() {\n        return Array.prototype.slice.call(arguments).join(' ')\n    }\n    var result = concat('this', 'was', 'no', 'fun')\n    console.log(result)  //<- 'this was no fun'\n```\n\nrest参数语法通过添加`...`在参数名的前面能够让你生成一个包含`function`参数的真实的`Array` 。语法十分的简单，事实上一个真实的数组使用起来也十分的方便。对于我来说我很高兴再也不需要借助于`arguments`了。\n\n``` js\n    function concat (...word) {\n     return word.join(' ')\n    }\n    var result = concat('this', 'is', 'okay')\n    console.log(result); //<- 'this is okay'\n```\n\n当你的`function`有更多的参数的时候略微有一些不同。不管什么时候我声明一个带有rest参数的方法的时候，我会考虑下面几点。\n- Rest 参数将包含所有调用函数的`arguments`。\n- 每次在函数的左边添加一个参数，对于Rest参数形成的数组来说就像调用了rest.shift()。\n- 注意你不允许把参数放到Rest参数的右边，Rest参数只能是最后一个参数。\n\n要形象化的描述这个最好是通过实践，而不是一句话的总结。下面这个方法将计算除了第一个参数(用来乘以后面的参数和)，剩余参数的和。为了不重复的调用函数，`.shift()`移除并且返回数组中的第一个参数，把函数变得类似一个有记忆的设备一样。\n\n``` js\n    function sum(){\n        var number = Array.prototype.slice.call(arguments) //numbers gets all arguments\n        var multiplier = numbers.shift()\n        var base = numbers.shift()\n        var sum = numbers.reduce((accumulator, num) => accumulator + num, base) \n        return multiplier * sum\n    }\n    var total = sum(2,  6,  10,  8,  9)\n    console.log(total)  //<- 66\n```\n\n下面是我们使用rest 参数改造之后的函数的样子，注意我们没有使用`arguments` 也没有再使用shifting。 这将相当赞因为这极大的减小我们函数的复杂度，这样我们将能更专注于它本身的功能而不是更多在处理`arguments`。\n\n``` js\n    function sum(multiplier, base, ...numbers) {\n        var sum = numbers.reduce((accumulator, num) => accumulator + num, base)\n        return multiplier * sum\n    }\n    var total = sum(2, 6, 10, 8, 9)\n    console.log(total) //<- 66\n```\n### 扩展运算符\n\n通常你通过传递参数来调用一个方法。\n\n``` js\n    console.log(1, 2, 3) //<- '1 2 3'\n```\n\n有时你有一些参数是放在一个列表中但是你又不想为了一次函数调用而使用索引来获取，或者这个列表是动态的生产的你根本不能这样获取。所以你一般会使用`.apply()`。这让你觉得不是很方便，因为`.apply`需要指定一个上下文`this`,而你得传入一个或许就不相关的对象(类似 `null`)。\n\n``` js\n    console.log(console, [1, 2, 3])  //<- '1, 2, 3'\n```\n\n扩展运算符可以被当做`.apply`的替代品(原文：butter knife, 黄油刀 Orz..) 。也不需要指定上下文，你只需要在数组前面使用`...` ，就像rest参数一样。\n\n``` js\n    console.log(...[1, 2, 3]) //<- '1, 2, 3'\n```\n\n其实扩展运算符可以用在任何事先iterable接口的对象上，这在我们下周一将要讨论的`iterators`特性中会有更好的补充，甚至能作用在`document.querySelectorAll('div')`的结果。\n\n``` js\n    [...document.querySelectorAll('div')] //<-[<div>, <div>, <div>]\n```\n\n另一个更好的方面是你可以混合搭配正常的参数，并且他们可以按你预期的那样执行。这在你处理有很多的参数的es5代码时非常有用。\n\n``` js\n        console.log(1, ...[2, 3, 4], 5) //becomes `console。log(1，2，3，4，5) //<- '1 2 3 4 5'\n```\n\n是时候讨论个真实的例子了.我有时在Express中使用下面的方法让[`morgan`](https://github.com/expressjs/morgan)(记录Express中的请求日志)通过[`winston`](https://github.com/winstonjs/winston)列化它的数据，为了实现多点传输日志服务。我把换行符从字节流中移除并且赋给message，因为winston已经处理过了，而且我还把一些元数据包括进程id和ip放在了`arguments`中，最后我使用`.apply`来调用winston的处理方法。 如果你仔细查看下面的方法，你会发现真正起作用的是我黄色高亮的那句，而且其他的都是在处理`arguments`.\n\n``` js\n    function createWriteStream (level) {\n        return {\n            write: function(){\n                var bits = Array.prototype.slice.call(arguments)\n                var message = bits.shift().replace(/\\n+$/， '')\n                bits.unshift(message)\n                bits.push({hostname: os.hostname(), pid: process.pid})\n                winston[level].apply(winston, bits)   //上文提到的黄色高亮语句指得是这句\n            }\n        }\n    }\n    app.use(morgan(':status :method :url', {\n        stream.createWriteStream('debug')\n    }))\n```\n\n我们可以使用ES6来彻底简化这个代码，首先，我们可以使用rest 参数来代替`arguments`。rest参数已经给我们一个现成的数组，所以将没有变相的调用。我们可以提取message作为第一个参数，而且我们可以直接调用`winston[level]`通过结合正常参数和`...bits`。这时代码就变得有模有样了，而且每一部分都是跟你想要实现的功能相关，比如改了调用`winston[level]`调用的参数。这代码相比于之前手动维护arguments来说，实现了自我的救赎[原文：a battle of wits against JavaScript itself]。\n\n``` js\n\n    function createWriteStream(level) {\n        return {\n            write: function (message, ..bits) {\n                winston[level](message.replace(/\\n+$/, ''), ...bits, {\n                    hostname: os.hostname(), pid: process.pid\n                })\n            }\n        }\n    }\n```\n\n另一个方法再次精简我们的代码使用箭头函数. 但是在这个场景下，将会是代码理解起来更复杂。你可以使用`msg` 代替`message` 来实现让整个代码在一行，然后使用rest参数和扩展运算符来调用`winston[level]`，让它不论是你还是你的队友在一周之后再看这个代码不思考15分钟都难以理解这个方法的作用。\n\n``` js\n    var proc = {hostname: os.hostname(), pid: process.pid}\n    function createWriteStream (level) {\n        return {\n            write(msg, ...bits) => winston[level](msg,replace(/\\n+$/, ''), ...bits, proc)\n        }\n    }\n```\n\n保持上一版本的写法还是比较明智的选择，然而这很好的证明了在这个情形下使用箭头函数只会增加复杂性。在其他场景下可能不会。这完全取决于你，所以你得理智的使用ES6的特性，到底是为了提高你的代码的可维护性还是只是为了使用ES6而牺牲了代码的可维护性。\n\n下面列举了一些有用的用法，显然你可以使用扩展运算符来创建一个数组，但是你也使用解构，这有点类似...rest原理。有一个不是很常见但是很值得一提的场景是你可以使用扩展运算符来代替`apply`即使是使用`new`运算符的时候。\n\n| 场景 | ES5 | ES6 |\n| --- | --- | --- |\n| Concatenation | [1, 2].concat(more) | [1, 2, ...more] |\n| Push onto list | list.push.apply(list, [3, 4]) | list.push(...[3, 4]) |\n| Destructuring | a = list[0], rest = list.slice(1) | [a, ..rest] = list |\n| new + apply | new (Date.bind.apply(Date, [null, 2015, 31, 8])) | new Date(... [2015, 31, 8]) |\n### 默认赋值操作\n\n默认赋值操作我们在解构那边文章已经涉及到了，但是只是简单的介绍了下。就像你可以在解构中使用默认值一样，你可以为函数的任何参数指定一个默认值，就像下面展示的那样。\n\n``` js\n    function sum (left = 1, right = 2) {\n        return left + right \n    }\n    console.log(sum()) //<- 3\n    console.log(sum(2)) //<- 4\n    console.log(sum(1, 0)) //<- 1\n```\n\n考虑[`dragula`](https://github.com/bevacqua/dragula/blob/f5f4c569780b0db160269e978eaf69dc36e421bb/dragula.js#L27-L37)里面的初始化options的代码。\n\n``` js\n    function dragula (options) {\n        var o = options || {};\n        if (o.moves === void 0) { o.moves = always;}\n        if (o.accepts === void 0) { o.accepts = always; }\n        if (o.invalid === void 0) { o.invalid = invalidTarget; }\n        if (o.containers === void 0) { o.containers = initialContainers || []; }\n        if (o.isContainer === void 0) { o.isContainer = never; }\n        if (o.copy === void 0) { o.copy = false; }\n        if (o.revertOnSpill === void 0) { o.revertOnSpill = false; }\n        if (o.removeOnSpill === void 0) { o.removeOnSpill = false; }\n        if (o.direction === void 0) { o.direction = 'vertical'; }\n        if (o.mirrorContainer === void 0) { o.mirrorContainer = body; }\n    }\n```\n\n你认为是否值得使用ES6的默认赋值操作语法来重构这部分代码？你会怎么重构？\n","slug":"es6-spread-and-buffer","published":1,"updated":"2018-08-05T04:48:52.735Z","_id":"cjkgd2nnj003jue8imadtsqzk","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p><a href=\"https://ponyfoo.com/articles/es6-spread-and-butter-in-depth#rest-parameters\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n</blockquote>\n<p>我们在讨论<a href=\"\">解构</a>的时候已经涉及到了一部分今天的内容。这篇将比其他的内容短一些，因为简单的特性没有太多可以说的。尽管如此，就像我在<a href=\"https://ponyfoo.com/articles/tagged/es6-in-depth\" target=\"_blank\" rel=\"noopener\">ES6 in Depth</a>系统中说的，最简单的特性往往也<a href=\"https://github.com/rockcoder23/blog.fexnotes.com/issues/24\" target=\"_blank\" rel=\"noopener\">最有用</a>，让我们来看看把。</p>\n<h3 id=\"Rest-参数\"><a href=\"#Rest-参数\" class=\"headerlink\" title=\"Rest 参数\"></a>Rest 参数</h3><p>你知道有时候函数有一大堆的参数，你最终不得不用<code>arguments</code> 魔法变量来处理他们。考虑下面这样把任意传入的参数的链接为字符串的方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">concat</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>).join(<span class=\"string\">' '</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = concat(<span class=\"string\">'this'</span>, <span class=\"string\">'was'</span>, <span class=\"string\">'no'</span>, <span class=\"string\">'fun'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result)  <span class=\"comment\">//&lt;- 'this was no fun'</span></span><br></pre></td></tr></table></figure>\n<p>rest参数语法通过添加<code>...</code>在参数名的前面能够让你生成一个包含<code>function</code>参数的真实的<code>Array</code> 。语法十分的简单，事实上一个真实的数组使用起来也十分的方便。对于我来说我很高兴再也不需要借助于<code>arguments</code>了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">concat</span> (<span class=\"params\">...word</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> word.join(<span class=\"string\">' '</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = concat(<span class=\"string\">'this'</span>, <span class=\"string\">'is'</span>, <span class=\"string\">'okay'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">//&lt;- 'this is okay'</span></span><br></pre></td></tr></table></figure>\n<p>当你的<code>function</code>有更多的参数的时候略微有一些不同。不管什么时候我声明一个带有rest参数的方法的时候，我会考虑下面几点。</p>\n<ul>\n<li>Rest 参数将包含所有调用函数的<code>arguments</code>。</li>\n<li>每次在函数的左边添加一个参数，对于Rest参数形成的数组来说就像调用了rest.shift()。</li>\n<li>注意你不允许把参数放到Rest参数的右边，Rest参数只能是最后一个参数。</li>\n</ul>\n<p>要形象化的描述这个最好是通过实践，而不是一句话的总结。下面这个方法将计算除了第一个参数(用来乘以后面的参数和)，剩余参数的和。为了不重复的调用函数，<code>.shift()</code>移除并且返回数组中的第一个参数，把函数变得类似一个有记忆的设备一样。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> number = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>) <span class=\"comment\">//numbers gets all arguments</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> multiplier = numbers.shift()</span><br><span class=\"line\">    <span class=\"keyword\">var</span> base = numbers.shift()</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sum = numbers.reduce(<span class=\"function\">(<span class=\"params\">accumulator, num</span>) =&gt;</span> accumulator + num, base) </span><br><span class=\"line\">    <span class=\"keyword\">return</span> multiplier * sum</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> total = sum(<span class=\"number\">2</span>,  <span class=\"number\">6</span>,  <span class=\"number\">10</span>,  <span class=\"number\">8</span>,  <span class=\"number\">9</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(total)  <span class=\"comment\">//&lt;- 66</span></span><br></pre></td></tr></table></figure>\n<p>下面是我们使用rest 参数改造之后的函数的样子，注意我们没有使用<code>arguments</code> 也没有再使用shifting。 这将相当赞因为这极大的减小我们函数的复杂度，这样我们将能更专注于它本身的功能而不是更多在处理<code>arguments</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">multiplier, base, ...numbers</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sum = numbers.reduce(<span class=\"function\">(<span class=\"params\">accumulator, num</span>) =&gt;</span> accumulator + num, base)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> multiplier * sum</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> total = sum(<span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">10</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(total) <span class=\"comment\">//&lt;- 66</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"扩展运算符\"><a href=\"#扩展运算符\" class=\"headerlink\" title=\"扩展运算符\"></a>扩展运算符</h3><p>通常你通过传递参数来调用一个方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>) <span class=\"comment\">//&lt;- '1 2 3'</span></span><br></pre></td></tr></table></figure>\n<p>有时你有一些参数是放在一个列表中但是你又不想为了一次函数调用而使用索引来获取，或者这个列表是动态的生产的你根本不能这样获取。所以你一般会使用<code>.apply()</code>。这让你觉得不是很方便，因为<code>.apply</code>需要指定一个上下文<code>this</code>,而你得传入一个或许就不相关的对象(类似 <code>null</code>)。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">console</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])  <span class=\"comment\">//&lt;- '1, 2, 3'</span></span><br></pre></td></tr></table></figure>\n<p>扩展运算符可以被当做<code>.apply</code>的替代品(原文：butter knife, 黄油刀 Orz..) 。也不需要指定上下文，你只需要在数组前面使用<code>...</code> ，就像rest参数一样。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(...[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]) <span class=\"comment\">//&lt;- '1, 2, 3'</span></span><br></pre></td></tr></table></figure>\n<p>其实扩展运算符可以用在任何事先iterable接口的对象上，这在我们下周一将要讨论的<code>iterators</code>特性中会有更好的补充，甚至能作用在<code>document.querySelectorAll(&#39;div&#39;)</code>的结果。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[...document.querySelectorAll(<span class=\"string\">'div'</span>)] <span class=\"comment\">//&lt;-[&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span></span><br></pre></td></tr></table></figure>\n<p>另一个更好的方面是你可以混合搭配正常的参数，并且他们可以按你预期的那样执行。这在你处理有很多的参数的es5代码时非常有用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>, ...[<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>], <span class=\"number\">5</span>) <span class=\"comment\">//becomes `console。log(1，2，3，4，5) //&lt;- '1 2 3 4 5'</span></span><br></pre></td></tr></table></figure>\n<p>是时候讨论个真实的例子了.我有时在Express中使用下面的方法让<a href=\"https://github.com/expressjs/morgan\" target=\"_blank\" rel=\"noopener\"><code>morgan</code></a>(记录Express中的请求日志)通过<a href=\"https://github.com/winstonjs/winston\" target=\"_blank\" rel=\"noopener\"><code>winston</code></a>列化它的数据，为了实现多点传输日志服务。我把换行符从字节流中移除并且赋给message，因为winston已经处理过了，而且我还把一些元数据包括进程id和ip放在了<code>arguments</code>中，最后我使用<code>.apply</code>来调用winston的处理方法。 如果你仔细查看下面的方法，你会发现真正起作用的是我黄色高亮的那句，而且其他的都是在处理<code>arguments</code>.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createWriteStream</span> (<span class=\"params\">level</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        write: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> bits = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">            <span class=\"keyword\">var</span> message = bits.shift().replace(<span class=\"regexp\">/\\n+$/</span>， <span class=\"string\">''</span>)</span><br><span class=\"line\">            bits.unshift(message)</span><br><span class=\"line\">            bits.push(&#123;<span class=\"attr\">hostname</span>: os.hostname(), <span class=\"attr\">pid</span>: process.pid&#125;)</span><br><span class=\"line\">            winston[level].apply(winston, bits)   <span class=\"comment\">//上文提到的黄色高亮语句指得是这句</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">app.use(morgan(<span class=\"string\">':status :method :url'</span>, &#123;</span><br><span class=\"line\">    stream.createWriteStream(<span class=\"string\">'debug'</span>)</span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n<p>我们可以使用ES6来彻底简化这个代码，首先，我们可以使用rest 参数来代替<code>arguments</code>。rest参数已经给我们一个现成的数组，所以将没有变相的调用。我们可以提取message作为第一个参数，而且我们可以直接调用<code>winston[level]</code>通过结合正常参数和<code>...bits</code>。这时代码就变得有模有样了，而且每一部分都是跟你想要实现的功能相关，比如改了调用<code>winston[level]</code>调用的参数。这代码相比于之前手动维护arguments来说，实现了自我的救赎[原文：a battle of wits against JavaScript itself]。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createWriteStream</span>(<span class=\"params\">level</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        write: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">message, ..bits</span>) </span>&#123;</span><br><span class=\"line\">            winston[level](message.replace(<span class=\"regexp\">/\\n+$/</span>, <span class=\"string\">''</span>), ...bits, &#123;</span><br><span class=\"line\">                hostname: os.hostname(), <span class=\"attr\">pid</span>: process.pid</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另一个方法再次精简我们的代码使用箭头函数. 但是在这个场景下，将会是代码理解起来更复杂。你可以使用<code>msg</code> 代替<code>message</code> 来实现让整个代码在一行，然后使用rest参数和扩展运算符来调用<code>winston[level]</code>，让它不论是你还是你的队友在一周之后再看这个代码不思考15分钟都难以理解这个方法的作用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> proc = &#123;<span class=\"attr\">hostname</span>: os.hostname(), <span class=\"attr\">pid</span>: process.pid&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createWriteStream</span> (<span class=\"params\">level</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        write(msg, ...bits) =&gt; winston[level](msg,replace(<span class=\"regexp\">/\\n+$/</span>, <span class=\"string\">''</span>), ...bits, proc)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>保持上一版本的写法还是比较明智的选择，然而这很好的证明了在这个情形下使用箭头函数只会增加复杂性。在其他场景下可能不会。这完全取决于你，所以你得理智的使用ES6的特性，到底是为了提高你的代码的可维护性还是只是为了使用ES6而牺牲了代码的可维护性。</p>\n<p>下面列举了一些有用的用法，显然你可以使用扩展运算符来创建一个数组，但是你也使用解构，这有点类似…rest原理。有一个不是很常见但是很值得一提的场景是你可以使用扩展运算符来代替<code>apply</code>即使是使用<code>new</code>运算符的时候。</p>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>ES5</th>\n<th>ES6</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Concatenation</td>\n<td>[1, 2].concat(more)</td>\n<td>[1, 2, …more]</td>\n</tr>\n<tr>\n<td>Push onto list</td>\n<td>list.push.apply(list, [3, 4])</td>\n<td>list.push(…[3, 4])</td>\n</tr>\n<tr>\n<td>Destructuring</td>\n<td>a = list[0], rest = list.slice(1)</td>\n<td>[a, ..rest] = list</td>\n</tr>\n<tr>\n<td>new + apply</td>\n<td>new (Date.bind.apply(Date, [null, 2015, 31, 8]))</td>\n<td>new Date(… [2015, 31, 8])</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"默认赋值操作\"><a href=\"#默认赋值操作\" class=\"headerlink\" title=\"默认赋值操作\"></a>默认赋值操作</h3><p>默认赋值操作我们在解构那边文章已经涉及到了，但是只是简单的介绍了下。就像你可以在解构中使用默认值一样，你可以为函数的任何参数指定一个默认值，就像下面展示的那样。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span> (<span class=\"params\">left = <span class=\"number\">1</span>, right = <span class=\"number\">2</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> left + right </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum()) <span class=\"comment\">//&lt;- 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(<span class=\"number\">2</span>)) <span class=\"comment\">//&lt;- 4</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(<span class=\"number\">1</span>, <span class=\"number\">0</span>)) <span class=\"comment\">//&lt;- 1</span></span><br></pre></td></tr></table></figure>\n<p>考虑<a href=\"https://github.com/bevacqua/dragula/blob/f5f4c569780b0db160269e978eaf69dc36e421bb/dragula.js#L27-L37\" target=\"_blank\" rel=\"noopener\"><code>dragula</code></a>里面的初始化options的代码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dragula</span> (<span class=\"params\">options</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> o = options || &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o.moves === <span class=\"keyword\">void</span> <span class=\"number\">0</span>) &#123; o.moves = always;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o.accepts === <span class=\"keyword\">void</span> <span class=\"number\">0</span>) &#123; o.accepts = always; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o.invalid === <span class=\"keyword\">void</span> <span class=\"number\">0</span>) &#123; o.invalid = invalidTarget; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o.containers === <span class=\"keyword\">void</span> <span class=\"number\">0</span>) &#123; o.containers = initialContainers || []; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o.isContainer === <span class=\"keyword\">void</span> <span class=\"number\">0</span>) &#123; o.isContainer = never; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o.copy === <span class=\"keyword\">void</span> <span class=\"number\">0</span>) &#123; o.copy = <span class=\"literal\">false</span>; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o.revertOnSpill === <span class=\"keyword\">void</span> <span class=\"number\">0</span>) &#123; o.revertOnSpill = <span class=\"literal\">false</span>; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o.removeOnSpill === <span class=\"keyword\">void</span> <span class=\"number\">0</span>) &#123; o.removeOnSpill = <span class=\"literal\">false</span>; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o.direction === <span class=\"keyword\">void</span> <span class=\"number\">0</span>) &#123; o.direction = <span class=\"string\">'vertical'</span>; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o.mirrorContainer === <span class=\"keyword\">void</span> <span class=\"number\">0</span>) &#123; o.mirrorContainer = body; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你认为是否值得使用ES6的默认赋值操作语法来重构这部分代码？你会怎么重构？</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><a href=\"https://ponyfoo.com/articles/es6-spread-and-butter-in-depth#rest-parameters\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n</blockquote>\n<p>我们在讨论<a href=\"\">解构</a>的时候已经涉及到了一部分今天的内容。这篇将比其他的内容短一些，因为简单的特性没有太多可以说的。尽管如此，就像我在<a href=\"https://ponyfoo.com/articles/tagged/es6-in-depth\" target=\"_blank\" rel=\"noopener\">ES6 in Depth</a>系统中说的，最简单的特性往往也<a href=\"https://github.com/rockcoder23/blog.fexnotes.com/issues/24\" target=\"_blank\" rel=\"noopener\">最有用</a>，让我们来看看把。</p>\n<h3 id=\"Rest-参数\"><a href=\"#Rest-参数\" class=\"headerlink\" title=\"Rest 参数\"></a>Rest 参数</h3><p>你知道有时候函数有一大堆的参数，你最终不得不用<code>arguments</code> 魔法变量来处理他们。考虑下面这样把任意传入的参数的链接为字符串的方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">concat</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>).join(<span class=\"string\">' '</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = concat(<span class=\"string\">'this'</span>, <span class=\"string\">'was'</span>, <span class=\"string\">'no'</span>, <span class=\"string\">'fun'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result)  <span class=\"comment\">//&lt;- 'this was no fun'</span></span><br></pre></td></tr></table></figure>\n<p>rest参数语法通过添加<code>...</code>在参数名的前面能够让你生成一个包含<code>function</code>参数的真实的<code>Array</code> 。语法十分的简单，事实上一个真实的数组使用起来也十分的方便。对于我来说我很高兴再也不需要借助于<code>arguments</code>了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">concat</span> (<span class=\"params\">...word</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> word.join(<span class=\"string\">' '</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = concat(<span class=\"string\">'this'</span>, <span class=\"string\">'is'</span>, <span class=\"string\">'okay'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">//&lt;- 'this is okay'</span></span><br></pre></td></tr></table></figure>\n<p>当你的<code>function</code>有更多的参数的时候略微有一些不同。不管什么时候我声明一个带有rest参数的方法的时候，我会考虑下面几点。</p>\n<ul>\n<li>Rest 参数将包含所有调用函数的<code>arguments</code>。</li>\n<li>每次在函数的左边添加一个参数，对于Rest参数形成的数组来说就像调用了rest.shift()。</li>\n<li>注意你不允许把参数放到Rest参数的右边，Rest参数只能是最后一个参数。</li>\n</ul>\n<p>要形象化的描述这个最好是通过实践，而不是一句话的总结。下面这个方法将计算除了第一个参数(用来乘以后面的参数和)，剩余参数的和。为了不重复的调用函数，<code>.shift()</code>移除并且返回数组中的第一个参数，把函数变得类似一个有记忆的设备一样。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> number = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>) <span class=\"comment\">//numbers gets all arguments</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> multiplier = numbers.shift()</span><br><span class=\"line\">    <span class=\"keyword\">var</span> base = numbers.shift()</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sum = numbers.reduce(<span class=\"function\">(<span class=\"params\">accumulator, num</span>) =&gt;</span> accumulator + num, base) </span><br><span class=\"line\">    <span class=\"keyword\">return</span> multiplier * sum</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> total = sum(<span class=\"number\">2</span>,  <span class=\"number\">6</span>,  <span class=\"number\">10</span>,  <span class=\"number\">8</span>,  <span class=\"number\">9</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(total)  <span class=\"comment\">//&lt;- 66</span></span><br></pre></td></tr></table></figure>\n<p>下面是我们使用rest 参数改造之后的函数的样子，注意我们没有使用<code>arguments</code> 也没有再使用shifting。 这将相当赞因为这极大的减小我们函数的复杂度，这样我们将能更专注于它本身的功能而不是更多在处理<code>arguments</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">multiplier, base, ...numbers</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sum = numbers.reduce(<span class=\"function\">(<span class=\"params\">accumulator, num</span>) =&gt;</span> accumulator + num, base)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> multiplier * sum</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> total = sum(<span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">10</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(total) <span class=\"comment\">//&lt;- 66</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"扩展运算符\"><a href=\"#扩展运算符\" class=\"headerlink\" title=\"扩展运算符\"></a>扩展运算符</h3><p>通常你通过传递参数来调用一个方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>) <span class=\"comment\">//&lt;- '1 2 3'</span></span><br></pre></td></tr></table></figure>\n<p>有时你有一些参数是放在一个列表中但是你又不想为了一次函数调用而使用索引来获取，或者这个列表是动态的生产的你根本不能这样获取。所以你一般会使用<code>.apply()</code>。这让你觉得不是很方便，因为<code>.apply</code>需要指定一个上下文<code>this</code>,而你得传入一个或许就不相关的对象(类似 <code>null</code>)。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">console</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])  <span class=\"comment\">//&lt;- '1, 2, 3'</span></span><br></pre></td></tr></table></figure>\n<p>扩展运算符可以被当做<code>.apply</code>的替代品(原文：butter knife, 黄油刀 Orz..) 。也不需要指定上下文，你只需要在数组前面使用<code>...</code> ，就像rest参数一样。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(...[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]) <span class=\"comment\">//&lt;- '1, 2, 3'</span></span><br></pre></td></tr></table></figure>\n<p>其实扩展运算符可以用在任何事先iterable接口的对象上，这在我们下周一将要讨论的<code>iterators</code>特性中会有更好的补充，甚至能作用在<code>document.querySelectorAll(&#39;div&#39;)</code>的结果。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[...document.querySelectorAll(<span class=\"string\">'div'</span>)] <span class=\"comment\">//&lt;-[&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span></span><br></pre></td></tr></table></figure>\n<p>另一个更好的方面是你可以混合搭配正常的参数，并且他们可以按你预期的那样执行。这在你处理有很多的参数的es5代码时非常有用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>, ...[<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>], <span class=\"number\">5</span>) <span class=\"comment\">//becomes `console。log(1，2，3，4，5) //&lt;- '1 2 3 4 5'</span></span><br></pre></td></tr></table></figure>\n<p>是时候讨论个真实的例子了.我有时在Express中使用下面的方法让<a href=\"https://github.com/expressjs/morgan\" target=\"_blank\" rel=\"noopener\"><code>morgan</code></a>(记录Express中的请求日志)通过<a href=\"https://github.com/winstonjs/winston\" target=\"_blank\" rel=\"noopener\"><code>winston</code></a>列化它的数据，为了实现多点传输日志服务。我把换行符从字节流中移除并且赋给message，因为winston已经处理过了，而且我还把一些元数据包括进程id和ip放在了<code>arguments</code>中，最后我使用<code>.apply</code>来调用winston的处理方法。 如果你仔细查看下面的方法，你会发现真正起作用的是我黄色高亮的那句，而且其他的都是在处理<code>arguments</code>.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createWriteStream</span> (<span class=\"params\">level</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        write: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> bits = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">            <span class=\"keyword\">var</span> message = bits.shift().replace(<span class=\"regexp\">/\\n+$/</span>， <span class=\"string\">''</span>)</span><br><span class=\"line\">            bits.unshift(message)</span><br><span class=\"line\">            bits.push(&#123;<span class=\"attr\">hostname</span>: os.hostname(), <span class=\"attr\">pid</span>: process.pid&#125;)</span><br><span class=\"line\">            winston[level].apply(winston, bits)   <span class=\"comment\">//上文提到的黄色高亮语句指得是这句</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">app.use(morgan(<span class=\"string\">':status :method :url'</span>, &#123;</span><br><span class=\"line\">    stream.createWriteStream(<span class=\"string\">'debug'</span>)</span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n<p>我们可以使用ES6来彻底简化这个代码，首先，我们可以使用rest 参数来代替<code>arguments</code>。rest参数已经给我们一个现成的数组，所以将没有变相的调用。我们可以提取message作为第一个参数，而且我们可以直接调用<code>winston[level]</code>通过结合正常参数和<code>...bits</code>。这时代码就变得有模有样了，而且每一部分都是跟你想要实现的功能相关，比如改了调用<code>winston[level]</code>调用的参数。这代码相比于之前手动维护arguments来说，实现了自我的救赎[原文：a battle of wits against JavaScript itself]。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createWriteStream</span>(<span class=\"params\">level</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        write: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">message, ..bits</span>) </span>&#123;</span><br><span class=\"line\">            winston[level](message.replace(<span class=\"regexp\">/\\n+$/</span>, <span class=\"string\">''</span>), ...bits, &#123;</span><br><span class=\"line\">                hostname: os.hostname(), <span class=\"attr\">pid</span>: process.pid</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另一个方法再次精简我们的代码使用箭头函数. 但是在这个场景下，将会是代码理解起来更复杂。你可以使用<code>msg</code> 代替<code>message</code> 来实现让整个代码在一行，然后使用rest参数和扩展运算符来调用<code>winston[level]</code>，让它不论是你还是你的队友在一周之后再看这个代码不思考15分钟都难以理解这个方法的作用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> proc = &#123;<span class=\"attr\">hostname</span>: os.hostname(), <span class=\"attr\">pid</span>: process.pid&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createWriteStream</span> (<span class=\"params\">level</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        write(msg, ...bits) =&gt; winston[level](msg,replace(<span class=\"regexp\">/\\n+$/</span>, <span class=\"string\">''</span>), ...bits, proc)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>保持上一版本的写法还是比较明智的选择，然而这很好的证明了在这个情形下使用箭头函数只会增加复杂性。在其他场景下可能不会。这完全取决于你，所以你得理智的使用ES6的特性，到底是为了提高你的代码的可维护性还是只是为了使用ES6而牺牲了代码的可维护性。</p>\n<p>下面列举了一些有用的用法，显然你可以使用扩展运算符来创建一个数组，但是你也使用解构，这有点类似…rest原理。有一个不是很常见但是很值得一提的场景是你可以使用扩展运算符来代替<code>apply</code>即使是使用<code>new</code>运算符的时候。</p>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>ES5</th>\n<th>ES6</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Concatenation</td>\n<td>[1, 2].concat(more)</td>\n<td>[1, 2, …more]</td>\n</tr>\n<tr>\n<td>Push onto list</td>\n<td>list.push.apply(list, [3, 4])</td>\n<td>list.push(…[3, 4])</td>\n</tr>\n<tr>\n<td>Destructuring</td>\n<td>a = list[0], rest = list.slice(1)</td>\n<td>[a, ..rest] = list</td>\n</tr>\n<tr>\n<td>new + apply</td>\n<td>new (Date.bind.apply(Date, [null, 2015, 31, 8]))</td>\n<td>new Date(… [2015, 31, 8])</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"默认赋值操作\"><a href=\"#默认赋值操作\" class=\"headerlink\" title=\"默认赋值操作\"></a>默认赋值操作</h3><p>默认赋值操作我们在解构那边文章已经涉及到了，但是只是简单的介绍了下。就像你可以在解构中使用默认值一样，你可以为函数的任何参数指定一个默认值，就像下面展示的那样。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span> (<span class=\"params\">left = <span class=\"number\">1</span>, right = <span class=\"number\">2</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> left + right </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum()) <span class=\"comment\">//&lt;- 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(<span class=\"number\">2</span>)) <span class=\"comment\">//&lt;- 4</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(<span class=\"number\">1</span>, <span class=\"number\">0</span>)) <span class=\"comment\">//&lt;- 1</span></span><br></pre></td></tr></table></figure>\n<p>考虑<a href=\"https://github.com/bevacqua/dragula/blob/f5f4c569780b0db160269e978eaf69dc36e421bb/dragula.js#L27-L37\" target=\"_blank\" rel=\"noopener\"><code>dragula</code></a>里面的初始化options的代码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dragula</span> (<span class=\"params\">options</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> o = options || &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o.moves === <span class=\"keyword\">void</span> <span class=\"number\">0</span>) &#123; o.moves = always;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o.accepts === <span class=\"keyword\">void</span> <span class=\"number\">0</span>) &#123; o.accepts = always; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o.invalid === <span class=\"keyword\">void</span> <span class=\"number\">0</span>) &#123; o.invalid = invalidTarget; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o.containers === <span class=\"keyword\">void</span> <span class=\"number\">0</span>) &#123; o.containers = initialContainers || []; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o.isContainer === <span class=\"keyword\">void</span> <span class=\"number\">0</span>) &#123; o.isContainer = never; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o.copy === <span class=\"keyword\">void</span> <span class=\"number\">0</span>) &#123; o.copy = <span class=\"literal\">false</span>; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o.revertOnSpill === <span class=\"keyword\">void</span> <span class=\"number\">0</span>) &#123; o.revertOnSpill = <span class=\"literal\">false</span>; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o.removeOnSpill === <span class=\"keyword\">void</span> <span class=\"number\">0</span>) &#123; o.removeOnSpill = <span class=\"literal\">false</span>; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o.direction === <span class=\"keyword\">void</span> <span class=\"number\">0</span>) &#123; o.direction = <span class=\"string\">'vertical'</span>; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o.mirrorContainer === <span class=\"keyword\">void</span> <span class=\"number\">0</span>) &#123; o.mirrorContainer = body; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你认为是否值得使用ES6的默认赋值操作语法来重构这部分代码？你会怎么重构？</p>\n"},{"title":"(译)ES6 Arrow Functions in Depth","date":"2015-10-24T16:03:29.000Z","_content":"> [原文地址](https://ponyfoo.com/articles/es6-arrow-functions-in-depth)\n\n继续每日更新[es6-in-depth](https://ponyfoo.com/articles/es6-arrow-functions-in-depth)文章，今天我们将会讨论箭头函数。 在前一篇文章中我们涉及到了[解构](https://ponyfoo.com/articles/es6-destructuring-in-depth)和[模板字符串](https://ponyfoo.com/articles/es6-template-strings-in-depth)。我尽力去覆盖所有ES6的特性，甚至我们会讨论到ES7.我发现总结这些特性同时也很容易让我印象更加深刻。\n\n因为你已经在阅读这一系列的文章，我建议你[安装Babel和babel-node]((https://ponyfoo.com/articles/universal-react-babel#setting-up-babel)，并把例子复制到文件里面，然后你可以通过`babel-node yourfile`在控制台中运行。自己在控制台中运行这些例子或者对它们稍作一些修改将对你更好的理解这些特性很有帮助。即使你只是添加`console.log` 语句来弄懂其中的缘由。\n\n> 让我们开始今天的话题吧\n\n在之前的文章中我们一起见识过了箭头函数，然后我们没有更多的对她进行解释。这篇文章我们将主要关注箭头函数并且先抛开其他的ES6特性。我认为这是最好的总结ES6的方式--把每个特性分篇，并且在每篇中逐渐的增加一些其他相关联的概念，这样有助于我们理解他们是怎么协作的。我已经关注到在ES6中有很多非常棒的相互协助的例子。慢慢的深入ES6中的语法和特性仍然是非常重要的而不是一头扎进温水中，因为你将无法适应之后的水温---这可能是一个失败的比喻。我们继续。\n### 箭头函数\n\n箭头函数是很多现代的语言都提供的一个功能，也是我从C# 转到Javascript后很想念的特性之一。非常幸运，她现在是ES6中一部分，我们能直接在javascript中使用。箭头函数的语法也是十分的形象。我们已经有了匿名函数，但是有一个精简的替代品也是不错的选择。\n\n如果我们有一个单独的参数和只是想返回一个表达式的结果，下面就是使用箭头函数的写法。\n\n``` js\n    [1, 2, 3].map(num => num * 2)  //<- [2, 4, 6]\n```\n\n等同下面ES5的写法。\n\n``` js\n    [1, 2, 3].map(function (num) {\n        return num * 2  //<- [2, 4, 6]\n    })\n```\n\n如果我们想声明更多参数或者不需要参数，我们得使用圆括号。\n\n``` js\n    [1, 2, 3, 4].map((num, index) => num * 2 + index) //<- [2, 5, 8, 11]\n```\n\n你可能还有其他的语句，而不只是返回一个表达式。这种情况你将使用大括号。\n\n``` js\n    [1, 2, 3, 4].map(num => {\n        var multiplier = 2 + num\n        return num * multiplier\n    })\n    //<- [3, 8, 15, 24]\n```\n\n你也可以使用圆括号添加更多的参数。\n\n``` js\n    [1, 2, 3, 4].map((num, index) => {\n        var multiplier = 2 + index\n        return num * multiplier\n    })\n    //<- [2, 6,12, 20]\n```\n\n尽管如此，有时候你最好还是使用命名函数声明，理由如下：\n-  `（num, index）=>`只是比`function (num, index)`稍微简短了点。\n-  `function` 关键字能够让你为函数取名，提高代码质量。\n-  当一个函数有多个参数和多条语句时，我不得不说不太可能因为多了六个字符就造成什么影响(注:这个地方没弄明白作者意图，为啥是六个字符？)\n-  然而，命名函数能够增加上下文那才使得加了六个字符(function)变得非常有价值\n\n如果我们想返回一个对象常量，我们得使用圆括号包裹下。这样对象常量才不会被解释为语句声明块(这也会导致静态的语法错误，因为`number: n`在下面的例子中不是一个合法的表达式)。第一个例子中解释`number`作为属性名，n作为表达式。因为我们这是在一个代码块里面，并且没有返回任何东西，map遍历值返回`undefined`。第二个例子，在number和n之后 `something:else`将无法被编译，所以抛出`SyntaxError`异常。\n\n``` js\n[1, 2, 3].map(n => { number: n })\n// [undefined, undefined, undefined]\n[1, 2, 3].map(n => { number: n, something: 'else' })\n// <- SyntaxError\n[1, 2, 3].map(n => ({ number: n }))\n// <- [{ number: 1 }, { number: 2 }, { number: 3 }]\n[1, 2, 3].map(n => ({ number: n, something: 'else' }))\n/* <- [\n  { number: 1, something: 'else' },\n  { number: 2, something: 'else' },\n  { number: 3, something: 'else' }]\n*/\n```\n\n箭头函数有个一个相当好的特点是他们已经预先绑定了词法词法作用域。这表明你将可以为了保持深度嵌套的函数上下文的`var self = this` 和`.bind（this）`类似的hack说拜拜了。\n\n``` js\nfunction Timer () {\n  this.seconds = 0\n  setInterval(() => this.seconds++, 1000)\n}\nvar timer = new Timer()\nsetTimeout(() => console.log(timer.seconds), 3100)\n// <- 3\n```\n\n记住箭头函数所保持的`this`引用一位置你使用`.call` 和`.apply` 将不会改变这个上下文。这是一个看起很像bug的特性。\n### 总结\n\n使用箭头函数来定义一个自绑定上下文的匿名的函数时是很精简的，它可以极大的简化你 代码。\n\n除非你的函数参数和语句是十分的简单易懂，否则没有理由把所有的函数都声明成箭头函数。我十分倡导使用命名函数，因为它不用注释就可以提高代码的可读性，也意味着我将每次纠结是否使用箭头函数。\n\n最后不得不说，我认为箭头函数在函数式变成场景下是十分有用的，例如当你对列表使用`.map`, `.filter`, `.reduce`时。类似的箭头函数在异步的场景下也非常有用，因为典型的是这种场景有一大堆的回调来处理参数，这是的箭头函数可以发挥它的作用。\n","source":"_posts/es6-array-function.md","raw":"---\ntitle: (译)ES6 Arrow Functions in Depth\ndate: 2015/10/25 00:03:29\ncategories:\n- Shit Done\ntags:\n- ES6\n- array function\n---\n> [原文地址](https://ponyfoo.com/articles/es6-arrow-functions-in-depth)\n\n继续每日更新[es6-in-depth](https://ponyfoo.com/articles/es6-arrow-functions-in-depth)文章，今天我们将会讨论箭头函数。 在前一篇文章中我们涉及到了[解构](https://ponyfoo.com/articles/es6-destructuring-in-depth)和[模板字符串](https://ponyfoo.com/articles/es6-template-strings-in-depth)。我尽力去覆盖所有ES6的特性，甚至我们会讨论到ES7.我发现总结这些特性同时也很容易让我印象更加深刻。\n\n因为你已经在阅读这一系列的文章，我建议你[安装Babel和babel-node]((https://ponyfoo.com/articles/universal-react-babel#setting-up-babel)，并把例子复制到文件里面，然后你可以通过`babel-node yourfile`在控制台中运行。自己在控制台中运行这些例子或者对它们稍作一些修改将对你更好的理解这些特性很有帮助。即使你只是添加`console.log` 语句来弄懂其中的缘由。\n\n> 让我们开始今天的话题吧\n\n在之前的文章中我们一起见识过了箭头函数，然后我们没有更多的对她进行解释。这篇文章我们将主要关注箭头函数并且先抛开其他的ES6特性。我认为这是最好的总结ES6的方式--把每个特性分篇，并且在每篇中逐渐的增加一些其他相关联的概念，这样有助于我们理解他们是怎么协作的。我已经关注到在ES6中有很多非常棒的相互协助的例子。慢慢的深入ES6中的语法和特性仍然是非常重要的而不是一头扎进温水中，因为你将无法适应之后的水温---这可能是一个失败的比喻。我们继续。\n### 箭头函数\n\n箭头函数是很多现代的语言都提供的一个功能，也是我从C# 转到Javascript后很想念的特性之一。非常幸运，她现在是ES6中一部分，我们能直接在javascript中使用。箭头函数的语法也是十分的形象。我们已经有了匿名函数，但是有一个精简的替代品也是不错的选择。\n\n如果我们有一个单独的参数和只是想返回一个表达式的结果，下面就是使用箭头函数的写法。\n\n``` js\n    [1, 2, 3].map(num => num * 2)  //<- [2, 4, 6]\n```\n\n等同下面ES5的写法。\n\n``` js\n    [1, 2, 3].map(function (num) {\n        return num * 2  //<- [2, 4, 6]\n    })\n```\n\n如果我们想声明更多参数或者不需要参数，我们得使用圆括号。\n\n``` js\n    [1, 2, 3, 4].map((num, index) => num * 2 + index) //<- [2, 5, 8, 11]\n```\n\n你可能还有其他的语句，而不只是返回一个表达式。这种情况你将使用大括号。\n\n``` js\n    [1, 2, 3, 4].map(num => {\n        var multiplier = 2 + num\n        return num * multiplier\n    })\n    //<- [3, 8, 15, 24]\n```\n\n你也可以使用圆括号添加更多的参数。\n\n``` js\n    [1, 2, 3, 4].map((num, index) => {\n        var multiplier = 2 + index\n        return num * multiplier\n    })\n    //<- [2, 6,12, 20]\n```\n\n尽管如此，有时候你最好还是使用命名函数声明，理由如下：\n-  `（num, index）=>`只是比`function (num, index)`稍微简短了点。\n-  `function` 关键字能够让你为函数取名，提高代码质量。\n-  当一个函数有多个参数和多条语句时，我不得不说不太可能因为多了六个字符就造成什么影响(注:这个地方没弄明白作者意图，为啥是六个字符？)\n-  然而，命名函数能够增加上下文那才使得加了六个字符(function)变得非常有价值\n\n如果我们想返回一个对象常量，我们得使用圆括号包裹下。这样对象常量才不会被解释为语句声明块(这也会导致静态的语法错误，因为`number: n`在下面的例子中不是一个合法的表达式)。第一个例子中解释`number`作为属性名，n作为表达式。因为我们这是在一个代码块里面，并且没有返回任何东西，map遍历值返回`undefined`。第二个例子，在number和n之后 `something:else`将无法被编译，所以抛出`SyntaxError`异常。\n\n``` js\n[1, 2, 3].map(n => { number: n })\n// [undefined, undefined, undefined]\n[1, 2, 3].map(n => { number: n, something: 'else' })\n// <- SyntaxError\n[1, 2, 3].map(n => ({ number: n }))\n// <- [{ number: 1 }, { number: 2 }, { number: 3 }]\n[1, 2, 3].map(n => ({ number: n, something: 'else' }))\n/* <- [\n  { number: 1, something: 'else' },\n  { number: 2, something: 'else' },\n  { number: 3, something: 'else' }]\n*/\n```\n\n箭头函数有个一个相当好的特点是他们已经预先绑定了词法词法作用域。这表明你将可以为了保持深度嵌套的函数上下文的`var self = this` 和`.bind（this）`类似的hack说拜拜了。\n\n``` js\nfunction Timer () {\n  this.seconds = 0\n  setInterval(() => this.seconds++, 1000)\n}\nvar timer = new Timer()\nsetTimeout(() => console.log(timer.seconds), 3100)\n// <- 3\n```\n\n记住箭头函数所保持的`this`引用一位置你使用`.call` 和`.apply` 将不会改变这个上下文。这是一个看起很像bug的特性。\n### 总结\n\n使用箭头函数来定义一个自绑定上下文的匿名的函数时是很精简的，它可以极大的简化你 代码。\n\n除非你的函数参数和语句是十分的简单易懂，否则没有理由把所有的函数都声明成箭头函数。我十分倡导使用命名函数，因为它不用注释就可以提高代码的可读性，也意味着我将每次纠结是否使用箭头函数。\n\n最后不得不说，我认为箭头函数在函数式变成场景下是十分有用的，例如当你对列表使用`.map`, `.filter`, `.reduce`时。类似的箭头函数在异步的场景下也非常有用，因为典型的是这种场景有一大堆的回调来处理参数，这是的箭头函数可以发挥它的作用。\n","slug":"es6-array-function","published":1,"updated":"2018-08-05T04:49:07.814Z","_id":"cjkgd67dj003kue8itj9ydzql","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p><a href=\"https://ponyfoo.com/articles/es6-arrow-functions-in-depth\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n</blockquote>\n<p>继续每日更新<a href=\"https://ponyfoo.com/articles/es6-arrow-functions-in-depth\" target=\"_blank\" rel=\"noopener\">es6-in-depth</a>文章，今天我们将会讨论箭头函数。 在前一篇文章中我们涉及到了<a href=\"https://ponyfoo.com/articles/es6-destructuring-in-depth\" target=\"_blank\" rel=\"noopener\">解构</a>和<a href=\"https://ponyfoo.com/articles/es6-template-strings-in-depth\" target=\"_blank\" rel=\"noopener\">模板字符串</a>。我尽力去覆盖所有ES6的特性，甚至我们会讨论到ES7.我发现总结这些特性同时也很容易让我印象更加深刻。</p>\n<p>因为你已经在阅读这一系列的文章，我建议你<a href=\"(https://ponyfoo.com/articles/universal-react-babel#setting-up-babel\">安装Babel和babel-node</a>，并把例子复制到文件里面，然后你可以通过<code>babel-node yourfile</code>在控制台中运行。自己在控制台中运行这些例子或者对它们稍作一些修改将对你更好的理解这些特性很有帮助。即使你只是添加<code>console.log</code> 语句来弄懂其中的缘由。</p>\n<blockquote>\n<p>让我们开始今天的话题吧</p>\n</blockquote>\n<p>在之前的文章中我们一起见识过了箭头函数，然后我们没有更多的对她进行解释。这篇文章我们将主要关注箭头函数并且先抛开其他的ES6特性。我认为这是最好的总结ES6的方式–把每个特性分篇，并且在每篇中逐渐的增加一些其他相关联的概念，这样有助于我们理解他们是怎么协作的。我已经关注到在ES6中有很多非常棒的相互协助的例子。慢慢的深入ES6中的语法和特性仍然是非常重要的而不是一头扎进温水中，因为你将无法适应之后的水温—这可能是一个失败的比喻。我们继续。</p>\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><p>箭头函数是很多现代的语言都提供的一个功能，也是我从C# 转到Javascript后很想念的特性之一。非常幸运，她现在是ES6中一部分，我们能直接在javascript中使用。箭头函数的语法也是十分的形象。我们已经有了匿名函数，但是有一个精简的替代品也是不错的选择。</p>\n<p>如果我们有一个单独的参数和只是想返回一个表达式的结果，下面就是使用箭头函数的写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].map(<span class=\"function\"><span class=\"params\">num</span> =&gt;</span> num * <span class=\"number\">2</span>)  <span class=\"comment\">//&lt;- [2, 4, 6]</span></span><br></pre></td></tr></table></figure>\n<p>等同下面ES5的写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num * <span class=\"number\">2</span>  <span class=\"comment\">//&lt;- [2, 4, 6]</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>如果我们想声明更多参数或者不需要参数，我们得使用圆括号。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>].map(<span class=\"function\">(<span class=\"params\">num, index</span>) =&gt;</span> num * <span class=\"number\">2</span> + index) <span class=\"comment\">//&lt;- [2, 5, 8, 11]</span></span><br></pre></td></tr></table></figure>\n<p>你可能还有其他的语句，而不只是返回一个表达式。这种情况你将使用大括号。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>].map(<span class=\"function\"><span class=\"params\">num</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> multiplier = <span class=\"number\">2</span> + num</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num * multiplier</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">//&lt;- [3, 8, 15, 24]</span></span><br></pre></td></tr></table></figure>\n<p>你也可以使用圆括号添加更多的参数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>].map(<span class=\"function\">(<span class=\"params\">num, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> multiplier = <span class=\"number\">2</span> + index</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num * multiplier</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">//&lt;- [2, 6,12, 20]</span></span><br></pre></td></tr></table></figure>\n<p>尽管如此，有时候你最好还是使用命名函数声明，理由如下：</p>\n<ul>\n<li><code>（num, index）=&gt;</code>只是比<code>function (num, index)</code>稍微简短了点。</li>\n<li><code>function</code> 关键字能够让你为函数取名，提高代码质量。</li>\n<li>当一个函数有多个参数和多条语句时，我不得不说不太可能因为多了六个字符就造成什么影响(注:这个地方没弄明白作者意图，为啥是六个字符？)</li>\n<li>然而，命名函数能够增加上下文那才使得加了六个字符(function)变得非常有价值</li>\n</ul>\n<p>如果我们想返回一个对象常量，我们得使用圆括号包裹下。这样对象常量才不会被解释为语句声明块(这也会导致静态的语法错误，因为<code>number: n</code>在下面的例子中不是一个合法的表达式)。第一个例子中解释<code>number</code>作为属性名，n作为表达式。因为我们这是在一个代码块里面，并且没有返回任何东西，map遍历值返回<code>undefined</code>。第二个例子，在number和n之后 <code>something:else</code>将无法被编译，所以抛出<code>SyntaxError</code>异常。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].map(<span class=\"function\"><span class=\"params\">n</span> =&gt;</span> &#123; <span class=\"attr\">number</span>: n &#125;)</span><br><span class=\"line\"><span class=\"comment\">// [undefined, undefined, undefined]</span></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].map(<span class=\"function\"><span class=\"params\">n</span> =&gt;</span> &#123; <span class=\"attr\">number</span>: n, <span class=\"attr\">something</span>: <span class=\"string\">'else'</span> &#125;)</span><br><span class=\"line\"><span class=\"comment\">// &lt;- SyntaxError</span></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].map(<span class=\"function\"><span class=\"params\">n</span> =&gt;</span> (&#123; <span class=\"attr\">number</span>: n &#125;))</span><br><span class=\"line\"><span class=\"comment\">// &lt;- [&#123; number: 1 &#125;, &#123; number: 2 &#125;, &#123; number: 3 &#125;]</span></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].map(<span class=\"function\"><span class=\"params\">n</span> =&gt;</span> (&#123; <span class=\"attr\">number</span>: n, <span class=\"attr\">something</span>: <span class=\"string\">'else'</span> &#125;))</span><br><span class=\"line\"><span class=\"comment\">/* &lt;- [</span></span><br><span class=\"line\"><span class=\"comment\">  &#123; number: 1, something: 'else' &#125;,</span></span><br><span class=\"line\"><span class=\"comment\">  &#123; number: 2, something: 'else' &#125;,</span></span><br><span class=\"line\"><span class=\"comment\">  &#123; number: 3, something: 'else' &#125;]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>箭头函数有个一个相当好的特点是他们已经预先绑定了词法词法作用域。这表明你将可以为了保持深度嵌套的函数上下文的<code>var self = this</code> 和<code>.bind（this）</code>类似的hack说拜拜了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Timer</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.seconds = <span class=\"number\">0</span></span><br><span class=\"line\">  setInterval(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">this</span>.seconds++, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> timer = <span class=\"keyword\">new</span> Timer()</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(timer.seconds), <span class=\"number\">3100</span>)</span><br><span class=\"line\"><span class=\"comment\">// &lt;- 3</span></span><br></pre></td></tr></table></figure>\n<p>记住箭头函数所保持的<code>this</code>引用一位置你使用<code>.call</code> 和<code>.apply</code> 将不会改变这个上下文。这是一个看起很像bug的特性。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>使用箭头函数来定义一个自绑定上下文的匿名的函数时是很精简的，它可以极大的简化你 代码。</p>\n<p>除非你的函数参数和语句是十分的简单易懂，否则没有理由把所有的函数都声明成箭头函数。我十分倡导使用命名函数，因为它不用注释就可以提高代码的可读性，也意味着我将每次纠结是否使用箭头函数。</p>\n<p>最后不得不说，我认为箭头函数在函数式变成场景下是十分有用的，例如当你对列表使用<code>.map</code>, <code>.filter</code>, <code>.reduce</code>时。类似的箭头函数在异步的场景下也非常有用，因为典型的是这种场景有一大堆的回调来处理参数，这是的箭头函数可以发挥它的作用。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><a href=\"https://ponyfoo.com/articles/es6-arrow-functions-in-depth\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n</blockquote>\n<p>继续每日更新<a href=\"https://ponyfoo.com/articles/es6-arrow-functions-in-depth\" target=\"_blank\" rel=\"noopener\">es6-in-depth</a>文章，今天我们将会讨论箭头函数。 在前一篇文章中我们涉及到了<a href=\"https://ponyfoo.com/articles/es6-destructuring-in-depth\" target=\"_blank\" rel=\"noopener\">解构</a>和<a href=\"https://ponyfoo.com/articles/es6-template-strings-in-depth\" target=\"_blank\" rel=\"noopener\">模板字符串</a>。我尽力去覆盖所有ES6的特性，甚至我们会讨论到ES7.我发现总结这些特性同时也很容易让我印象更加深刻。</p>\n<p>因为你已经在阅读这一系列的文章，我建议你<a href=\"(https://ponyfoo.com/articles/universal-react-babel#setting-up-babel\">安装Babel和babel-node</a>，并把例子复制到文件里面，然后你可以通过<code>babel-node yourfile</code>在控制台中运行。自己在控制台中运行这些例子或者对它们稍作一些修改将对你更好的理解这些特性很有帮助。即使你只是添加<code>console.log</code> 语句来弄懂其中的缘由。</p>\n<blockquote>\n<p>让我们开始今天的话题吧</p>\n</blockquote>\n<p>在之前的文章中我们一起见识过了箭头函数，然后我们没有更多的对她进行解释。这篇文章我们将主要关注箭头函数并且先抛开其他的ES6特性。我认为这是最好的总结ES6的方式–把每个特性分篇，并且在每篇中逐渐的增加一些其他相关联的概念，这样有助于我们理解他们是怎么协作的。我已经关注到在ES6中有很多非常棒的相互协助的例子。慢慢的深入ES6中的语法和特性仍然是非常重要的而不是一头扎进温水中，因为你将无法适应之后的水温—这可能是一个失败的比喻。我们继续。</p>\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><p>箭头函数是很多现代的语言都提供的一个功能，也是我从C# 转到Javascript后很想念的特性之一。非常幸运，她现在是ES6中一部分，我们能直接在javascript中使用。箭头函数的语法也是十分的形象。我们已经有了匿名函数，但是有一个精简的替代品也是不错的选择。</p>\n<p>如果我们有一个单独的参数和只是想返回一个表达式的结果，下面就是使用箭头函数的写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].map(<span class=\"function\"><span class=\"params\">num</span> =&gt;</span> num * <span class=\"number\">2</span>)  <span class=\"comment\">//&lt;- [2, 4, 6]</span></span><br></pre></td></tr></table></figure>\n<p>等同下面ES5的写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num * <span class=\"number\">2</span>  <span class=\"comment\">//&lt;- [2, 4, 6]</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>如果我们想声明更多参数或者不需要参数，我们得使用圆括号。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>].map(<span class=\"function\">(<span class=\"params\">num, index</span>) =&gt;</span> num * <span class=\"number\">2</span> + index) <span class=\"comment\">//&lt;- [2, 5, 8, 11]</span></span><br></pre></td></tr></table></figure>\n<p>你可能还有其他的语句，而不只是返回一个表达式。这种情况你将使用大括号。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>].map(<span class=\"function\"><span class=\"params\">num</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> multiplier = <span class=\"number\">2</span> + num</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num * multiplier</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">//&lt;- [3, 8, 15, 24]</span></span><br></pre></td></tr></table></figure>\n<p>你也可以使用圆括号添加更多的参数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>].map(<span class=\"function\">(<span class=\"params\">num, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> multiplier = <span class=\"number\">2</span> + index</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num * multiplier</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">//&lt;- [2, 6,12, 20]</span></span><br></pre></td></tr></table></figure>\n<p>尽管如此，有时候你最好还是使用命名函数声明，理由如下：</p>\n<ul>\n<li><code>（num, index）=&gt;</code>只是比<code>function (num, index)</code>稍微简短了点。</li>\n<li><code>function</code> 关键字能够让你为函数取名，提高代码质量。</li>\n<li>当一个函数有多个参数和多条语句时，我不得不说不太可能因为多了六个字符就造成什么影响(注:这个地方没弄明白作者意图，为啥是六个字符？)</li>\n<li>然而，命名函数能够增加上下文那才使得加了六个字符(function)变得非常有价值</li>\n</ul>\n<p>如果我们想返回一个对象常量，我们得使用圆括号包裹下。这样对象常量才不会被解释为语句声明块(这也会导致静态的语法错误，因为<code>number: n</code>在下面的例子中不是一个合法的表达式)。第一个例子中解释<code>number</code>作为属性名，n作为表达式。因为我们这是在一个代码块里面，并且没有返回任何东西，map遍历值返回<code>undefined</code>。第二个例子，在number和n之后 <code>something:else</code>将无法被编译，所以抛出<code>SyntaxError</code>异常。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].map(<span class=\"function\"><span class=\"params\">n</span> =&gt;</span> &#123; <span class=\"attr\">number</span>: n &#125;)</span><br><span class=\"line\"><span class=\"comment\">// [undefined, undefined, undefined]</span></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].map(<span class=\"function\"><span class=\"params\">n</span> =&gt;</span> &#123; <span class=\"attr\">number</span>: n, <span class=\"attr\">something</span>: <span class=\"string\">'else'</span> &#125;)</span><br><span class=\"line\"><span class=\"comment\">// &lt;- SyntaxError</span></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].map(<span class=\"function\"><span class=\"params\">n</span> =&gt;</span> (&#123; <span class=\"attr\">number</span>: n &#125;))</span><br><span class=\"line\"><span class=\"comment\">// &lt;- [&#123; number: 1 &#125;, &#123; number: 2 &#125;, &#123; number: 3 &#125;]</span></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].map(<span class=\"function\"><span class=\"params\">n</span> =&gt;</span> (&#123; <span class=\"attr\">number</span>: n, <span class=\"attr\">something</span>: <span class=\"string\">'else'</span> &#125;))</span><br><span class=\"line\"><span class=\"comment\">/* &lt;- [</span></span><br><span class=\"line\"><span class=\"comment\">  &#123; number: 1, something: 'else' &#125;,</span></span><br><span class=\"line\"><span class=\"comment\">  &#123; number: 2, something: 'else' &#125;,</span></span><br><span class=\"line\"><span class=\"comment\">  &#123; number: 3, something: 'else' &#125;]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>箭头函数有个一个相当好的特点是他们已经预先绑定了词法词法作用域。这表明你将可以为了保持深度嵌套的函数上下文的<code>var self = this</code> 和<code>.bind（this）</code>类似的hack说拜拜了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Timer</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.seconds = <span class=\"number\">0</span></span><br><span class=\"line\">  setInterval(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">this</span>.seconds++, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> timer = <span class=\"keyword\">new</span> Timer()</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(timer.seconds), <span class=\"number\">3100</span>)</span><br><span class=\"line\"><span class=\"comment\">// &lt;- 3</span></span><br></pre></td></tr></table></figure>\n<p>记住箭头函数所保持的<code>this</code>引用一位置你使用<code>.call</code> 和<code>.apply</code> 将不会改变这个上下文。这是一个看起很像bug的特性。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>使用箭头函数来定义一个自绑定上下文的匿名的函数时是很精简的，它可以极大的简化你 代码。</p>\n<p>除非你的函数参数和语句是十分的简单易懂，否则没有理由把所有的函数都声明成箭头函数。我十分倡导使用命名函数，因为它不用注释就可以提高代码的可读性，也意味着我将每次纠结是否使用箭头函数。</p>\n<p>最后不得不说，我认为箭头函数在函数式变成场景下是十分有用的，例如当你对列表使用<code>.map</code>, <code>.filter</code>, <code>.reduce</code>时。类似的箭头函数在异步的场景下也非常有用，因为典型的是这种场景有一大堆的回调来处理参数，这是的箭头函数可以发挥它的作用。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjkgbd09f000aue8i8f9tn8dh","category_id":"cjkgbh63o000gue8i7avhjgh4","_id":"cjkgbh63p000jue8iwbwwe8tl"},{"post_id":"cjkgbk2o5000oue8igvn28cv4","category_id":"cjkgblykr000tue8i2rnsl3vl","_id":"cjkgblyks000wue8io26j2wb3"},{"post_id":"cjkgbngp3000zue8irap9w3m9","category_id":"cjkgblykr000tue8i2rnsl3vl","_id":"cjkgbnw230012ue8it5j6cxis"},{"post_id":"cjkgbqfsi0017ue8in3169kxq","category_id":"cjkgblykr000tue8i2rnsl3vl","_id":"cjkgbr0vr001aue8i5tf7lsqo"},{"post_id":"cjkgbutym001due8iu0auhfnq","category_id":"cjkgblykr000tue8i2rnsl3vl","_id":"cjkgbvdc1001gue8isemdyu3e"},{"post_id":"cjkgc0cch001iue8ija2betrj","category_id":"cjkgblykr000tue8i2rnsl3vl","_id":"cjkgc538s001kue8i4tet52vc"},{"post_id":"cjkgc7dfp001nue8i5i1n5sre","category_id":"cjkgblykr000tue8i2rnsl3vl","_id":"cjkgc7pho001que8itjojauh2"},{"post_id":"cjkgcb2yr001rue8ie29mww1q","category_id":"cjkgblykr000tue8i2rnsl3vl","_id":"cjkgcc7bt001uue8io15pab1f"},{"post_id":"cjkgcdvlo001vue8icfj6kfpn","category_id":"cjkgblykr000tue8i2rnsl3vl","_id":"cjkgcebw3001yue8i2csp6brn"},{"post_id":"cjkgch03o0021ue8i9q6gyosc","category_id":"cjkgblykr000tue8i2rnsl3vl","_id":"cjkgchq0k0023ue8i5aozop0p"},{"post_id":"cjkgciq030024ue8itd3y3xzu","category_id":"cjkgblykr000tue8i2rnsl3vl","_id":"cjkgcjllo0026ue8icedgwkdc"},{"post_id":"cjkgcl6tc002aue8il8cxr1vr","category_id":"cjkgbh63o000gue8i7avhjgh4","_id":"cjkgcmh3c002fue8inbc5iays"},{"post_id":"cjkgcpvhi002hue8i3x3fq29v","category_id":"cjkgblykr000tue8i2rnsl3vl","_id":"cjkgcqabk002kue8iejxbm13o"},{"post_id":"cjkgcrhyh002oue8im96alsj9","category_id":"cjkgbh63o000gue8i7avhjgh4","_id":"cjkgcsb80002rue8iwgpflwlv"},{"post_id":"cjkgcsygw002uue8iv1uako37","category_id":"cjkgblykr000tue8i2rnsl3vl","_id":"cjkgct5zq002xue8i81ccsbdq"},{"post_id":"cjkgcurwu0032ue8ibyckq8yh","category_id":"cjkgblykr000tue8i2rnsl3vl","_id":"cjkgcvr8t0037ue8i3pi56h2u"},{"post_id":"cjkgcwrwq003cue8ic7h9prlh","category_id":"cjkgblykr000tue8i2rnsl3vl","_id":"cjkgcxs8j003eue8i6fxrno1f"},{"post_id":"cjkgd67dj003kue8itj9ydzql","category_id":"cjkgblykr000tue8i2rnsl3vl","_id":"cjkgd8nk6003mue8ifux17f8l"},{"post_id":"cjkgczodv003iue8ico43j6fo","category_id":"cjkgblykr000tue8i2rnsl3vl","_id":"cjkgd930z003rue8ikr8i1zff"},{"post_id":"cjkgd2nnj003jue8imadtsqzk","category_id":"cjkgblykr000tue8i2rnsl3vl","_id":"cjkgd9fzf003vue8izz4p3yhz"}],"PostTag":[{"post_id":"cjkgbd09f000aue8i8f9tn8dh","tag_id":"cjkgbh63o000hue8ivnmnqohz","_id":"cjkgbh63p000iue8iormzjwwc"},{"post_id":"cjkgbd09f000aue8i8f9tn8dh","tag_id":"cjkgbhjtm000kue8ihzs6bh8g","_id":"cjkgbhjtp000mue8ic7laujlc"},{"post_id":"cjkgbd09f000aue8i8f9tn8dh","tag_id":"cjkgbhjtn000lue8in4fbschn","_id":"cjkgbhjtp000nue8ig6ulbco6"},{"post_id":"cjkgbk2o5000oue8igvn28cv4","tag_id":"cjkgblykr000uue8ijmyide5l","_id":"cjkgblyks000xue8ie3blgxkh"},{"post_id":"cjkgbk2o5000oue8igvn28cv4","tag_id":"cjkgblykr000vue8i3flrcym5","_id":"cjkgblyks000yue8idvwqq46e"},{"post_id":"cjkgbngp3000zue8irap9w3m9","tag_id":"cjkgbox9g0013ue8i04hsdlde","_id":"cjkgbox9h0015ue8idr6soqjf"},{"post_id":"cjkgbngp3000zue8irap9w3m9","tag_id":"cjkgbox9g0014ue8idhbtwdu3","_id":"cjkgbox9h0016ue8istkbzerl"},{"post_id":"cjkgbqfsi0017ue8in3169kxq","tag_id":"cjkgblykr000uue8ijmyide5l","_id":"cjkgbr0vq0018ue8ibvf2fz63"},{"post_id":"cjkgbqfsi0017ue8in3169kxq","tag_id":"cjkgbr9um001bue8iwqm5r9zq","_id":"cjkgbr9un001cue8imu0ygch1"},{"post_id":"cjkgbutym001due8iu0auhfnq","tag_id":"cjkgbox9g0013ue8i04hsdlde","_id":"cjkgbw1yp001hue8ihhkjij2u"},{"post_id":"cjkgc0cch001iue8ija2betrj","tag_id":"cjkgc5u4p001lue8ich4dm15t","_id":"cjkgc5u4p001mue8i4rj0xcjj"},{"post_id":"cjkgc7dfp001nue8i5i1n5sre","tag_id":"cjkgblykr000uue8ijmyide5l","_id":"cjkgc7phn001oue8inn9zofg5"},{"post_id":"cjkgc7dfp001nue8i5i1n5sre","tag_id":"cjkgbr9um001bue8iwqm5r9zq","_id":"cjkgc7pho001pue8ioajzei6r"},{"post_id":"cjkgcb2yr001rue8ie29mww1q","tag_id":"cjkgbox9g0013ue8i04hsdlde","_id":"cjkgcc7bs001sue8i7cbl6a7f"},{"post_id":"cjkgcb2yr001rue8ie29mww1q","tag_id":"cjkgbox9g0014ue8idhbtwdu3","_id":"cjkgcc7bt001tue8iusm3z0ap"},{"post_id":"cjkgcdvlo001vue8icfj6kfpn","tag_id":"cjkgcetm8001zue8io5dr0cio","_id":"cjkgcetm90020ue8ideix5u82"},{"post_id":"cjkgch03o0021ue8i9q6gyosc","tag_id":"cjkgcetm8001zue8io5dr0cio","_id":"cjkgchq0k0022ue8i0m3en2pq"},{"post_id":"cjkgciq030024ue8itd3y3xzu","tag_id":"cjkgcjlln0025ue8i5wt73imj","_id":"cjkgcjllp0028ue8io3vprkll"},{"post_id":"cjkgciq030024ue8itd3y3xzu","tag_id":"cjkgcjllo0027ue8iimuyls2o","_id":"cjkgcjllp0029ue8ic3cr18nh"},{"post_id":"cjkgcl6tc002aue8il8cxr1vr","tag_id":"cjkgcmh3a002eue8isw6e1hmw","_id":"cjkgcmh3d002gue8izhi0ai1u"},{"post_id":"cjkgcpvhi002hue8i3x3fq29v","tag_id":"cjkgcetm8001zue8io5dr0cio","_id":"cjkgcqxml002mue8i2ebwni47"},{"post_id":"cjkgcpvhi002hue8i3x3fq29v","tag_id":"cjkgcqxml002lue8ig6dzfzja","_id":"cjkgcqxml002nue8ie013g9i1"},{"post_id":"cjkgcrhyh002oue8im96alsj9","tag_id":"cjkgcserz002sue8iklatlkpz","_id":"cjkgcses0002tue8icwkh3qxh"},{"post_id":"cjkgcsygw002uue8iv1uako37","tag_id":"cjkgctmse002yue8i2y8rg2vd","_id":"cjkgctmsg0030ue8i38xnjwon"},{"post_id":"cjkgcsygw002uue8iv1uako37","tag_id":"cjkgctmsf002zue8i9kwt5zbk","_id":"cjkgctmsg0031ue8idjoty3lu"},{"post_id":"cjkgcurwu0032ue8ibyckq8yh","tag_id":"cjkgcw5wk0038ue8it36ykqak","_id":"cjkgcw5wk003aue8it5gjm6rr"},{"post_id":"cjkgcurwu0032ue8ibyckq8yh","tag_id":"cjkgcw5wk0039ue8ibhfii7lk","_id":"cjkgcw5wk003bue8ijm5zwkuc"},{"post_id":"cjkgcwrwq003cue8ic7h9prlh","tag_id":"cjkgcxs8i003due8i5oq432o8","_id":"cjkgcxs8j003gue8il4h21v1e"},{"post_id":"cjkgcwrwq003cue8ic7h9prlh","tag_id":"cjkgcxs8j003fue8ivgfxfgse","_id":"cjkgcxs8j003hue8ifk1typsh"},{"post_id":"cjkgd67dj003kue8itj9ydzql","tag_id":"cjkgd8nk5003lue8i7aw7xrlj","_id":"cjkgd8nk7003oue8iasqik2xh"},{"post_id":"cjkgd67dj003kue8itj9ydzql","tag_id":"cjkgd8nk6003nue8ipjzncrjo","_id":"cjkgd8nk7003pue8iwmr6sr55"},{"post_id":"cjkgczodv003iue8ico43j6fo","tag_id":"cjkgd8nk5003lue8i7aw7xrlj","_id":"cjkgd9310003sue8it1fobev9"},{"post_id":"cjkgczodv003iue8ico43j6fo","tag_id":"cjkgd930z003que8ikdkvno4r","_id":"cjkgd9310003tue8iar5zxcer"},{"post_id":"cjkgd2nnj003jue8imadtsqzk","tag_id":"cjkgd8nk5003lue8i7aw7xrlj","_id":"cjkgd9fzg003xue8iz7xxsh9i"},{"post_id":"cjkgd2nnj003jue8imadtsqzk","tag_id":"cjkgd9fzf003uue8imscn01tn","_id":"cjkgd9fzh003yue8idtf4ccbz"},{"post_id":"cjkgd2nnj003jue8imadtsqzk","tag_id":"cjkgd9fzg003wue8imz00d2ap","_id":"cjkgd9fzh003zue8iq7qy4sbp"}],"Tag":[{"name":"Injury","_id":"cjkgb3bwc0001ue8iunec5rnl"},{"name":"Fight","_id":"cjkgb3bwd0002ue8ilfzwp7ou"},{"name":"Shocking","_id":"cjkgb3bwe0004ue8ir3fvjlc6"},{"name":"历史","_id":"cjkgbh63o000hue8ivnmnqohz"},{"name":"北京","_id":"cjkgbhjtm000kue8ihzs6bh8g"},{"name":"城门","_id":"cjkgbhjtn000lue8in4fbschn"},{"name":"java","_id":"cjkgblykr000uue8ijmyide5l"},{"name":"相对路径","_id":"cjkgblykr000vue8i3flrcym5"},{"name":"JVM","_id":"cjkgbox9g0013ue8i04hsdlde"},{"name":"内存模型","_id":"cjkgbox9g0014ue8idhbtwdu3"},{"name":"对象的生命周期","_id":"cjkgbr9um001bue8iwqm5r9zq"},{"name":"Network","_id":"cjkgc5u4p001lue8ich4dm15t"},{"name":"Javascript","_id":"cjkgcetm8001zue8io5dr0cio"},{"name":"HTML","_id":"cjkgcjlln0025ue8i5wt73imj"},{"name":"DOCTYPE","_id":"cjkgcjllo0027ue8iimuyls2o"},{"name":"年终终结","_id":"cjkgcmh3a002eue8isw6e1hmw"},{"name":"正则表达式","_id":"cjkgcqxml002lue8ig6dzfzja"},{"name":"年终总结","_id":"cjkgcserz002sue8iklatlkpz"},{"name":"Nginx","_id":"cjkgctmse002yue8i2y8rg2vd"},{"name":"nginx 配置","_id":"cjkgctmsf002zue8i9kwt5zbk"},{"name":"CSS","_id":"cjkgcw5wk0038ue8it36ykqak"},{"name":"Bootstrap","_id":"cjkgcw5wk0039ue8ibhfii7lk"},{"name":"Python","_id":"cjkgcxs8i003due8i5oq432o8"},{"name":"flask","_id":"cjkgcxs8j003fue8ivgfxfgse"},{"name":"ES6","_id":"cjkgd8nk5003lue8i7aw7xrlj"},{"name":"array function","_id":"cjkgd8nk6003nue8ipjzncrjo"},{"name":"Destructuring","_id":"cjkgd930z003que8ikdkvno4r"},{"name":"Spread","_id":"cjkgd9fzf003uue8imscn01tn"},{"name":"Buffer","_id":"cjkgd9fzg003wue8imz00d2ap"}]}}